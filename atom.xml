<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Evan的博客]]></title>
  <link href="https://evanoyam.github.io/atom.xml" rel="self"/>
  <link href="https://evanoyam.github.io/"/>
  <updated>2020-10-09T10:41:23+08:00</updated>
  <id>https://evanoyam.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[七牛图床测试]]></title>
    <link href="https://evanoyam.github.io/16022112559168.html"/>
    <updated>2020-10-09T10:40:55+08:00</updated>
    <id>https://evanoyam.github.io/16022112559168.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16022112559168/2D985BA1-26FB-4698-BE3A-67C87B6BE5C9_4_5005_c.jpeg" alt="2D985BA1-26FB-4698-BE3A-67C87B6BE5C9_4_5005_c"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见 JS 面试题]]></title>
    <link href="https://evanoyam.github.io/16021877148099.html"/>
    <updated>2020-10-09T04:08:34+08:00</updated>
    <id>https://evanoyam.github.io/16021877148099.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">1. JS的基本数据类型和引用数据类型有哪些，他们的存储结构有什么不同？</h4>

<p>基本数据类型有String，Number，Boolean，Null，Undefined，Symbol。引用数据类型有Object，Array，Function。</p>

<blockquote>
<ul>
<li>基本数据类型存储在内存的栈空间中，每个自定义起就是唯一的</li>
<li>引用数据类型是存储在内存的堆空间中，然后堆地址存在栈空间里，其实读的是堆空间的引用。当一个引用类型赋值给一个变量，本质上是把这个地址的指针赋值过去了，这个地址指向的其实还是同一个堆空间</li>
</ul>
</blockquote>

<h4 id="toc_1">2. 如何判断JS数据类型？</h4>

<ol>
<li>基础类型用typeof就可以了，但是null是个例外，null要用 <code>===</code> 来判断，因为一个早期的bug导致了typeof null是Object</li>
<li>typeof引用数据类型（除了Function）都是Object，Array.isArray判断数组</li>
<li>isNaN来判断NaN，NaN连他自己都不等</li>
</ol>

<h4 id="toc_2">3. null，undefined 的区别？</h4>

<p>null表示这是一个空值，而undefined表示这是一个值，只是还没定义而已</p>

<h4 id="toc_3">4. NaN？</h4>

<p>NaN和全世界都不相等，包括它自己。用isNaN()判断一个参数是不是NaN</p>

<h4 id="toc_4">5. 介绍JavaScript的原型，原型链（画图）</h4>

<p><img src="https://img.bluepay.asia/upload/manual/20200426/17120534.png" alt="image"/></p>

<h4 id="toc_5">6. JavaScript如何实现一个类？</h4>

<p>JS的类是一个语法糖，本质上就是new一个对象出来，然后return出去，具体看new的原理，以及手写new</p>

<h4 id="toc_6">7. 什么是节流？介绍一下应用场景和原理，且手写一个节流函数</h4>

<p>节流指的是某一段时间内，某段代码或者说方法，仅执行一次。是触发立即执行的，然后某一段时间内重复执行将被无视，直到过了限制期，下一次触发才生效</p>

<p>常见的应用场景比如滚动触发某些事件，或者touchmove之类的事件，可以用节流</p>

<pre><code class="language-javascript">/**
 *
 * @param {Function} func 需要节流的函数
 * @param {Number} wait 需要节流的时间
 * @param {Boolean} immediate 是否立即执行
 * @param  {...any} args 节流函数的参数
 */
const throttle = (func, wait, immediate, ...args) =&gt; {
  if (immediate) {
    let pre = 0
    return function() {
      const now = +new Date()
      if (now - pre &gt; wait) {
        func.apply(this, args)
        pre = now
      }
    }
  } else {
    let timeout = null
    return function() {
      const ctx = this
      if (!timeout) {
        timeout = setTimeout(() =&gt; {
          timeout = null
          func.apply(ctx, args)
        }, wait)
      }
    }
  }
}

const fn = n =&gt; {
  console.log(n)
}

const run = throttle(fn, 1000, 1, 123)

setInterval(() =&gt; {
  run()
}, 0)
</code></pre>

<h4 id="toc_7">8. 什么是防抖？介绍一下应用场景和原理，且手写一个防抖函数</h4>

<p>防抖就是避免频繁触发同一个事件，两个事件之间必须相隔一段时间才可执行，如果一个事件触发后，还没间隔够就触发下一个事件，那么下一个事件不执行</p>

<pre><code class="language-javascript">/**
 *
 * @param {Function} func 需要防抖的方法
 * @param {Number} wait 等待时长
 * @param {Boolean} immediate 是否立即执行
 * @param  {...any} args 需要防抖的方法所需的参数
 */
const debounce = (func, wait, immediate, ...args) =&gt; {
  let timeout = null
  return function() {
    const ctx = this
    if (timeout) clearTimeout(timeout)
    if (immediate) {
      const callNow = !timeout
      timeout = setTimeout(() =&gt; {
        timeout = null
      }, wait)
      if (callNow) func.apply(ctx, args)
    } else {
      timeout = setTimeout(() =&gt; {
        func.apply(ctx, args)
      }, wait)
    }
  }
}
</code></pre>

<h4 id="toc_8">9. == 和 === 的区别</h4>

<p>双等号会做类型隐式转换，三等号不会做类型隐式转换</p>

<h4 id="toc_9">10. 什么是作用域，什么是作用域链</h4>

<p>作用域就是当前环境下的变量和内存空间的可访问性。在ES6的const和let出现之前，是没有块级作用域的，只有全局作用域和函数作用域。这也是为什么一些框架代码写在IIFE内，这是为了产生一个独立的作用域，避免污染全局环境。</p>

<p>当代码执行的时候，在当前作用域找不到变量，会去父级的作用域查找，这种链式查找就是作用域链。注意这里的作用域是定义时候就产生的，也就是说js在解释阶段就确定了作用域，而非在运行阶段</p>

<blockquote>
<p>JS是解释型语言，分为解释和执行两个阶段。  </p>

<p>解释阶段包括:</p>

<ul>
<li>语法分析</li>
<li>词法环境分析（也就是确定作用域）</li>
</ul>

<p>执行阶段包括:</p>

<ul>
<li>创建执行上下文</li>
<li>将函数推入执行栈顶并且执行函数</li>
<li>垃圾回收</li>
</ul>
</blockquote>

<h4 id="toc_10">11. 什么是闭包</h4>

<p>函数外部访问函数内部的变量。闭包本是为了纯函数式编程的。函数内声明函数的同时，还会保留当前函数作用域内的变量，return函数出去或者赋值给外部对象，这些变量会跟着携带出去。只要闭包函数还存在，就会一直携带这些变量</p>

<p>闭包能避免全局污染: 闭包携带了属于自己的函数执行时需要的上下文（私有属性）就像在气泡内，每个闭包环境有自己的变量，如果定义在全局，那变量是可共享的，状态不唯一就无法追踪</p>

<h4 id="toc_11">12. 介绍一下this</h4>

<p>this是执行时的上下文对象。一般可归纳为三种：</p>

<ol>
<li>正常执行语句，调用方法的时候，谁调用了方法，this就绑定在谁身上。如果直接使用方法，就绑定在window对象上（node在global上）
<code>js
const obj = {<br/>
name: &#39;Evan&#39;,<br/>
fn: function () {<br/>
console.log(this.name)<br/>
}<br/>
}<br/>
const newFn = obj.fn()<br/>
obj.fn() // obj调用fn，this（上下文对象）就是obj，输出obj.name 即 Evan<br/>
newFn() // 直接使用方法，浏览器中等价于window调用，this（上下文对象）就是window，输出window.name 即 undefined
</code></li>
<li>new xxx()的时候，会生成一个新的对象（最终构造函数会return这个对象）this就绑定在这个对象身上。this.xx 就相当于这个对象.xx</li>
<li>箭头函数没有this，而是继承于定义时的外层词法环境，如果没有则跟着作用域链一路查找直到最外层（浏览器是window对象，node环境是exports对象，后面解释）<br/>
```js<br/>
const obj = {<br/>
a: function() {<br/>
console.log(this)<br/>
},<br/>
b: () =&gt; {<br/>
console.log(this)<br/>
},<br/>
c: {<br/>
d: function() {<br/>
  console.log(this)<br/>
},<br/>
e: () =&gt; {<br/>
  console.log(this)<br/>
}<br/>
}<br/>
}</li>
</ol>

<p>// 正常函数，谁调用this就在谁身上<br/>
obj.a() // obj<br/>
// 箭头函数没有this，this取决于定义时的最外层上下文<br/>
obj.b() // 浏览器 =&gt; window；node =&gt; exports<br/>
// 正常函数，谁调用this就在谁身上<br/>
obj.c.d() // obj.c<br/>
// 箭头函数没有this，this取决于定义时的最外层上下文<br/>
obj.c.e() // 浏览器 =&gt; window；node =&gt; exports</p>

<pre><code class="language-text">&gt; 为什么在node环境执行箭头函数this会指向exports而不是global（module.exports），因为Node是模块化的，node执行每个文件会给一个单独的作用域（模块），这是一个闭包环境。
&gt; 
&gt; 在一个模块（文件）中，声明的变量都是在这个闭包环境内的，不会污染global，而this指向的是module.exports，而不是global
&gt; 
&gt; 如果直接调用一个正常定义的函数，那么这个就是由global对象调用的，this会绑定在global上。如果调用一个箭头函数，this是向上级词法环境查找的，如果上级没有作用域，就跟着作用域链一路找到定义时的最外层对象上（exports）
&gt; 
&gt; 所以 obj.c.e() 输出的是exports，也就是module.exports，这是当前文件的顶级对象，箭头函数没有this，依赖定义时的外层对象，外层对象也没有词法环境，就一路往上找到exports

#### 13. 箭头函数的特点
箭头函数没有this，而是继承于定义时的外层词法环境，如果没有则跟着作用域链一路查找直到最外层

#### 14. 原生JavaScript如何实现对DOM节点的增删查改
```js
// 增
const fatherDOM = document.querySelector(&#39;#father&#39;)
const sonDOM = document.createElement(&#39;div&#39;)
fatherDOM.appendChild(sonDOM)

// 删
const fatherDOM = document.querySelector(&#39;#father&#39;)
const sonDOM = document.querySelector(&#39;#son&#39;)
fatherDOM.removeChild(sonDOM)

// 查
const DOM = document.querySelectorAll(&#39;.box&#39;)
</code></pre>

<h4 id="toc_12">15. Array.slice() 与 Array.splice() 的区别？</h4>

<p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。</p>

<p>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p>

<h4 id="toc_13">16. 数组有哪些方法不改变原数组？有哪些方法会改变原数组？</h4>

<p>不改变原数组的方法:</p>

<ol>
<li>slice</li>
<li>map</li>
<li>fliter</li>
<li>concat</li>
<li>join</li>
</ol>

<p>改变原数组的方法:</p>

<ol>
<li>pop</li>
<li>push</li>
<li>shift</li>
<li>unshift</li>
<li>splice</li>
</ol>

<h4 id="toc_14">17. 介绍一下数组高阶方法</h4>

<ol>
<li>find：找出第一个符合条件的成员</li>
<li>findindex：找出第一个符合条件的成员下标</li>
<li>includes：数组中是否存在某成员</li>
<li>reduce：递归方法</li>
<li>map：映射方法</li>
<li>filter：过滤方法</li>
</ol>

<h4 id="toc_15">18. typeof 和 instanceof 的区别</h4>

<p>typeof是判断变量是否属于某个类型，instanceof是判断实例是否属于某个构造函数。</p>

<p>instanceof的原理就是，在对象的原型链中能否找到构造函数的prototype</p>

<pre><code class="language-javascript">function myInstanceof(left, right) {
  let rightPrototype = right.prototype
  let leftPrototype = left.__proto__
  while (true) {
    if (leftPrototype === null || leftPrototype === undefined) return false
    if (rightPrototype === leftPrototype) return true
    leftPrototype = leftPrototype.__proto__
  }
}
</code></pre>

<h4 id="toc_16">19. Javascript有哪些兼容性写法</h4>

<p>document.body 和 document.documentElement</p>

<h4 id="toc_17">20. 什么是变量提升</h4>

<p>var声明的变量会变量提升到顶部，也就是提前声明，但是还未赋值</p>

<h4 id="toc_18">21. 显示转换 / 隐式转换</h4>

<p><strong>强制转换:</strong></p>

<ol>
<li>Number<br/>
Number(Number) -&gt; 不变<br/>
Number(String) -&gt; 可解析成数字/NaN<br/>
Number(Boolean) -&gt; true为1，false为0<br/>
Number(undefined) -&gt; NaN<br/>
Number(null) -&gt; 0<br/>
Number(Array) -&gt; 单数字/NaN<br/>
Number(Object) -&gt; NaN</li>
<li>String<br/>
String(基础类型) -&gt; 字符串<br/>
String(Object) -&gt; [object object]（字符串）<br/>
String(Array) -&gt; 相当于Array.prototype.join</li>
<li>Boolean<br/>
Boolean(undefined、0、-0、NaN、null、&#39;&#39;) -&gt; false<br/>
Boolean(其他) -&gt; true</li>
</ol>

<p><strong>隐式转换</strong></p>

<ol>
<li>逻辑类（如if，三元运算，!等）以布尔类型为准，其他转换成布尔</li>
<li>算数类（+、-、*、/、%）以数字类型为准，其他转换成数字类型</li>
<li>特殊“+”以字符串为准，其他转换成字符串</li>
<li>“==”比较运算符<br/>
null == undefined<br/>
数字为准，其他遵循：obj先转，后转布尔，再转字符串</li>
</ol>

<h4 id="toc_19">22. 手写一个Promise</h4>

<p><a href="http://note.youdao.com/noteshare?id=f3a2cd6d1cbd16a833539bb355bdacfa">到这里看答案</a></p>

<h4 id="toc_20">23. promise和await async有什么差别</h4>

<ol>
<li>从用法上，promise是链式调用，await async是类似同步的写法，await async其实是自动执行next的generator的语法糖</li>
<li>从错误捕获上，promise有catch，await async可以用try catch</li>
<li>从性能上await async有堆栈追踪，性能比promise好。await/async本质是生成器和迭代器的语法糖，它是将异步暂停且挂起，它不需要保留完整的堆栈信息，只需要保留读取堆栈的地址指针就可以了。<br/>
而promise的链式调用并没有&quot;暂停代码&quot;，它通过then收集到了所有的回调依赖，保存在resolveQueue或者rejectQueue中。当它resolve或者reject的时候，从队列中把回调全部拿出来执行。这意味着它仍要保存回调的堆栈信息，那怕promise已经执行完毕了。</li>
</ol>

<h4 id="toc_21">24. 介绍一下promise.all和promise.race</h4>

<p>promise.all是等待一个promise数组，全部resolve了promise.all才会resolve，其中任何一个reject了，promise.all都会被reject</p>

<p>promise.race是等待若干个promise中最快resolve的那个结果</p>

<h4 id="toc_22">25. Object.create()的时候做了什么</h4>

<p>Object.create()用来创建一个对象，接收两个参数</p>

<ol>
<li>第一个是__proto__指向的对象，如果设置为null，那么这个新创建的对象不会拥有Object原型上的方法（包括toString()等）</li>
<li>第二个参数是对象上的属性所拥有的属性（是否可读写等，作用与Object.defineProperties一样）</li>
</ol>

<pre><code class="language-javascript">const obj = Object.create(null, {
  name: {
    writable: true,
    configurable: true,
    value: &#39;Evan&#39;
  }
})
</code></pre>

<h4 id="toc_23">26. 什么称之为“对象属性的属性”，如何查看，如何修改</h4>

<ol>
<li>对象上的属性都有其定义自身的属性，如是否可修改，删除，枚举等</li>
<li>通过Object.getOwnPropertyDescriptor(obj,&#39;property&#39;)可查看这个属性的属性</li>
<li>通过Object.defineProperty(obj,&#39;property&#39;,{define:prop})。接收3个参数，第一个是对象本身，第二个是对象所需要修改的属性，第三个是对这个属性的描述，是一个对象。常见的描述有：
<code>js
{ <br/>
value: &#39;Evan&#39;,  //值<br/>
writable: true,  //是否可修改value<br/>
enumerable: true,  //是否可枚举<br/>
configurable: true  //是否可删除<br/>
}
</code></li>
</ol>

<h4 id="toc_24">27. 介绍一下宏任务与微任务，且以下代码的输出结果是什么</h4>

<p>宏任务和微任务都是事件循环队列里的一部分。队列中的每个宏任务都有一个属于其自己的微任务队列。每一轮事件循环只会执行一个宏任务和其对应的微任务队列，当宏任务执行完，就会去执行其对应的微任务队列。其下所有微任务执行完，结束这轮的事件循环，回过头检查宏任务队列，执行新的宏任务和其下微任务队列中的所有微任务。</p>

<p>常见的宏任务有：</p>

<ol>
<li>同步的代码</li>
<li>setTimeout，setInterval</li>
<li>requestAnimationFrame</li>
<li>node中的setImmediate</li>
</ol>

<p>常见的微任务有：</p>

<ol>
<li>promise，await async等（注意如果用setTimeout模拟的promise，那还是宏任务）</li>
<li>node中的process.nextTick</li>
</ol>

<p>对于代码中的输出结果，思路只要找到所有宏任务和微任务就好了：第一轮宏任务输出 -&gt; 第一轮宏任务中的微任务输出 -&gt; 第二轮宏任务输出...</p>

<p>输出结果是：（开始输出第一轮宏任务）script start =&gt; async2 end =&gt; Promise =&gt; script end（第一轮宏任务输出结束） =&gt; （开始输出第一轮宏任务所属的微任务）async1 end =&gt; promise1 =&gt; promise2（第一轮宏任务所属的微任务结束） =&gt; （第二轮宏任务）setTimeout</p>

<h4 id="toc_25">28. 介绍一下Set数据结构何其方法，并说出常用的场景</h4>

<p>Set的成员都是唯一的，有add，delete，has，clear等方法，也是可枚举的，所以可遍历，也可以用扩展运算符展开。常用来存储唯一结果的数据，或者去重等</p>

<h4 id="toc_26">29. 介绍一下Map数据结构何其方法，并说出常用的场景</h4>

<p>Map是一种键值对形式的，映射（字典）数据结构。有set，delete，get，has，clear等方法。也是可以遍历的，常用于做映射</p>

<h4 id="toc_27">30. 介绍一下get和set方法</h4>

<p>get和set都是对象属性的一种特性（可通过Object.defineProperty设置）</p>

<p>在访问对象某个属性的时候，会触发get，比如obj.a将会触发a的getter；在设置对象某个属性的时候，会触发set，比如obj.a = 123将会触发a的setter。换句话说这两个东西可以作为钩子去处理一些逻辑。</p>

<h4 id="toc_28">31. 说一下运算符优先级</h4>

<p>算数类&gt;逻辑类&gt;赋值</p>

<p>括号&gt;算数运算符&gt;大小判断运算符&gt;等号与非&gt;与&gt;或&gt;三元运算&gt;赋值</p>

<h4 id="toc_29">32. 介绍一下深拷贝和浅拷贝，手写一个深拷贝</h4>

<p>对于引用类型来说，赋值的时候其实是把地址赋值过去，并不是真正意义上的复制。于是有了浅拷贝和深拷贝的概念。</p>

<p>浅拷贝就是把对象第一层拥有的属性复制一份，但是如果属性中有引用类型的话，还是复制了它的引用地址</p>

<p>深拷贝就是递归下去的浅拷贝，保证每个属性和他的子属性都复制一份</p>

<pre><code class="language-javascript">function deepClone(obj) {
  function isObject(o) {
    return (typeof o === &#39;object&#39; || typeof o === &#39;function&#39;) &amp;&amp; o !== null
  }
  if (!isObject(obj)) return obj
  let newObj = Array.isArray(obj) ? [] : {}
  Reflect.ownKeys(obj).forEach(key =&gt; {
    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
  })
  return newObj
}
</code></pre>

<h4 id="toc_30">33. indexOf() findIndex() find() 三者的区别</h4>

<ol>
<li>indexOf()在String和Array类型中都有，用来匹配字符串（如果是数组就匹配元素），找到了返回目标位置，找不到就返回-1</li>
<li>findIndex()是ES6数组新增的方法，查找数组中符合条件的下标，找不到就返回-1</li>
<li>find()是ES6数组新增的方法，查找符合条件的元素，找不到就返回-1</li>
</ol>

<h4 id="toc_31">34. 介绍一下Date对象常用方法</h4>

<p>Date是JS内置的日期对象，常用如getTime(),getFullYear(),getMonth(),getDate()等，通过<code>+new Date()</code>可以很方便转换为时间戳</p>

<h4 id="toc_32">35. 介绍一下Math对象常用方法</h4>

<p>Math是JS内置的数学处理库，常见如Math.floor(),Math.ceil(),Math.round()等</p>

<h4 id="toc_33">36. vue如何实现双向绑定</h4>

<p>Vue 2.x 是通过defineProperty来劫持对象的属性，从而感知数据的变化，进而驱动视图变更。 在这个过程中，通过一个发布订阅机制来控制什么数据需要响应式，什么数据又不需要响应</p>

<blockquote>
<p>比如没有渲染的数据，其实没必要追踪变化，只需要追踪template中的{{}}即可。需要渲染的数据发起订阅，收集依赖；数据改变时通知各个订阅方，未订阅的不通知</p>
</blockquote>

<p>defineProperty有几个弊端:</p>

<ol>
<li>并不能劫持数组，所以Vue重写了数组相关的劫持方法</li>
<li>defineProperty不能响应式追踪新增的元素，所以Vue提供了vue.$set</li>
<li>defineProperty是深度遍历的，不管多少层，反正就递归遍历完，对性能损耗很大</li>
</ol>

<p>Vue 3.x 是通过Proxy来劫持对象的（包括数组）所以原生上就解决了无法追踪数组的问题（包括新增元素也是一个道理）。而且这里不需要深度递归，只需要递归到目标层级就好了</p>

<blockquote>
<p>Proxy还能结合Reflect很方便的获取和设置函数，这里就不演示了</p>
</blockquote>

<pre><code class="language-javascript">// vue 2.x
const observe = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj
  Reflect.ownKeys(obj).forEach(item =&gt; {
    reactiveFn(obj, item, obj[item])
  })
}

const reactiveFn = (obj, key, val) =&gt; {
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      console.log(&#39;getter&#39;, val)
      return val
    },
    set(newV) {
      console.log(&#39;setter&#39;, newV)
      val = newV
    }
  })
}

let data = {
  name: &#39;Evan&#39;,
  age: 24
}

observe(data)
const name = data.name
data.age = 25
</code></pre>

<pre><code class="language-javascript">// vue 3.x
const proxyGenerator = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj

  const handler = {
    get(obj, key) {
      console.log(&#39;getter&#39;, obj[key])
      // 仅递归到目标层次，不用深度递归
      return proxyGenerator(obj[key])
    },
    set(obj, key, newV) {
      console.log(&#39;setter&#39;, newV)
      obj[key] = newV
    }
  }

  return new Proxy(obj, handler)
}

const userInfo = {
  name: &#39;Evan&#39;,
  age: 24
}

let userInfoProxy = proxyGenerator(userInfo)

const name = userInfoProxy.name
userInfoProxy.age = 25
</code></pre>

<h4 id="toc_34">37. new XXX() 的时候发生了什么</h4>

<ol>
<li>创建新对象并且this指向这个对象，即this就是这个对象。this.xx 其实就是这个对象.xx。</li>
<li>新对象的__proto__指向构造函数的原型，因此new的对象拥有构造函数原型上的所有属性与方法。这也是instanceof的原理。</li>
<li>最终构造函数会返回这个this对象。所以构造函数的目的本身是用于批量初始化对象，需要初始化某个对象就很适合用构造函数。</li>
<li>如果构造函数显式返回一个非对象返回值，则会被忽略，由新创建的对象（也就是this）所覆盖。如果显式返回一个对象，则这个对象会覆盖掉新创建的this对象</li>
<li>此外构造函数虽然可以直接调用，但是意义不大，因为这样window会被当作this传入，构造的对象属性全部会被绑定到全局上，容易造成污染。并且严格模式下由于this不再默认指向window，直接调用构造函数会导致this为定义，直接报错</li>
</ol>

<h4 id="toc_35">38. 说一下call，apply，bind的区别</h4>

<p>call、apply、bind三者都是显式绑定this的一种方法</p>

<p>call会执行方法，且带参是独立的一个个参数</p>

<p>apply会执行方法，且带参是一个参数数组</p>

<p>bind只是绑定this，并不会执行</p>

<pre><code class="language-javascript">const A = { name: &#39;Evan&#39; }
const B = { name: &#39;Fiona&#39; }
function showInfo(age) {
  this.age = age
  console.log(this.name, this.age)
}
// this绑定在对象A上，由对象A执行showInfo，带参21
showInfo.call(A, 21) // Evan，21
// this绑定在对象B上，由对象B执行showInfo，带参20
showInfo.call(B, 20) // Fiona，20
// this绑定在对象A上，由对象A执行showInfo，带参22
showInfo.apply(A, [22]) // Evan，22
// this绑定在对象A上，赋值给test，带参23
const test = showInfo.bind(A, 23) // Evan，23
test()
</code></pre>

<h4 id="toc_36">39. 说一下运算符优先级</h4>

<p>括号&gt;算数运算符&gt;大小判断运算符&gt;等号与非&gt;与&gt;或&gt;三元运算&gt;赋值。总结就是算数类&gt;逻辑类，逻辑类&gt;赋值</p>

<h4 id="toc_37">40. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h4>

<p>cookies只有4kb，sessionstorage和localstorage有5m。cookies在设置的时间之前不会过期，localstorange在本地不会过期，sessionstorage在窗口关闭之前不会过期</p>

<h4 id="toc_38">41. 什么是剩余参数数组，有什么用处</h4>

<p>函数接收的参数如果用扩展运算符去展开，将会得到一个数组</p>

<pre><code class="language-javascript">function plus(...arr) {
  let sum = 0
  for (const i in arr) {
    sum += arr[i]
  }
  return sum
}

const a = plus(1, 2, 3, 4, 5)
console.log(a)

</code></pre>

<h4 id="toc_39">42. 什么是类数组结构</h4>

<p>有length，可遍历，但是没有数组相关的方法</p>

<h4 id="toc_40">43. js如何追踪执行环境</h4>

<ol>
<li>如果是创建一个函数环境，那么创建形参及函数参数的默认值。如果是非函数环境，将跳过此步骤。</li>
<li>如果是创建全局或函数环境，就扫描当前代码进行函数声明(不会扫描其他函数的函数体)，但是不会扫描函数表达式或箭头函数。对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若该标识符已经存在，那么该标识符的值将被重写。如果是块级作川域，将跳过此步骤。</li>
<li>扫描当前代码进行变量声明。在函数或全局环境中，找到所有当前函数以及其他函数之外通过var声明的变量，并找到所有在其他函数或代码块之外通过let或const定义的变量。在块级环境中，仅查找当前块中通过let或const定义的变量。对于所査找到的变量，若该标识符不有在，进行注册并将其初始化为undefined。若该标识符已经存在，将保留</li>
</ol>

<h4 id="toc_41">44. 模拟私有变量</h4>

<pre><code class="language-javascript">// 构造函数模拟闭包
function SelfIncreasing() {
  let num = 0
  this.getNum = () =&gt; {
    return num
  }
  this.setNum = () =&gt; {
    num++
  }
}

// IIFE return 函数模拟闭包
const outter = (function() {
  let num = 0
  return function() {
    return {
      a: num,
      b: 1
    }
  }
})()
</code></pre>

<h4 id="toc_42">45. 闭包实现动画效果</h4>

<pre><code class="language-javascript">function animateBox() {
  const box = document.getElementById(&#39;box&#39;)
  var tick = 0
  var timer = setInterval(function() {
    if (tick &lt; 100) {
      box.style.left = box.style.top = tick + &#39;px&#39;
      tick++
    } else {
      clearInterval(timer)
    }
  }, 10)
}
</code></pre>

<h4 id="toc_43">46. 什么是生成器</h4>

<p>生成器通过 <code>function* (){}</code> 声明，在函数体内有 yield 关键字。生成器用于生成一系列返回值。</p>

<h4 id="toc_44">47. 什么是迭代器</h4>

<p>迭代器用来控制生成器的执行，它有一个 next()方法，每次执行这个方法。生成器就开始执行代码，当代码执行到 yield 关键字时，就会生成一个中间结果（生成值序列中的一项），然后返回一个新对象，其中封装了结果值和一个指示完成的指示器。</p>

<h4 id="toc_45">48. 描述一下生成器和迭代器的关系</h4>

<ol>
<li>初次运行生成器的时候并没有执行生成器内的任何代码，而是将生成器挂起并且生成了一个迭代器。</li>
<li>执行迭代器 next 方法的时候，生成器激活，执行代码直到遇到第一个 yield。这时生成器将会返回一个 yield 对象，这个对象包含一个生成的值（value）、下一个返回值的指示器（done，布尔类型），然后生成器挂起。</li>
<li>随后每次调用迭代器的 next，生成器就会重新激活，直到遇到 yield 再挂起，然后再 next 再激活，循环往复。当生成器无值返回时，value 将会返回 undefined，然后指示器 done 为 true，生成器结束。</li>
<li>用 for of 遍历迭代器时，将自动执行迭代器的 next 方法。</li>
</ol>

<h4 id="toc_46">49. 描述一下生成器是如果做到暂停代码的</h4>

<ol>
<li>运行生成器的时候，js 引擎会把生成器执行上下文（本质上生成器也是一个函数）推进执行上下文栈顶。这时候会创建并且返回一个迭代器。这个迭代器其实就是对生成器的引用。返回迭代器后，生成器挂起，其执行上下文从栈顶弹出。但是由于还有迭代器的存在（这玩意是生成器的引用）所以其实生成器没有被完全销毁（有点类似闭包）内存中仍然有生成器的堆空间，迭代器可以看成是他的地址指针。</li>
<li>每次执行迭代器的 next 方法时，迭代器再通过引用找到被保存下来的生成器的上下文，把它推进执行上下文栈顶。生成器开始运作，当遇到 yield 的时候，返回包含 value 和指示器的对象，执行上下文从栈顶弹出，迭代器仍然保存着引用</li>
<li>往后的每一次 next 和 yield，都是如此。这就是生成器与普通函数的不同，普通函数每次调用都是生成一个新的上下文推进栈顶，执行完毕从栈顶移除并销毁；而生成器是把之前的上下文重新找出来，执行完毕弹出栈顶但是保存引用。</li>
</ol>

<h4 id="toc_47">50. 使用生成器生成唯一 id</h4>

<pre><code class="language-javascript">function* IdGenerator() {
  let id = 0
  while (true) {
    yield ++id
  }
}
const idIterator = IdGenerator()
const id = idIterator.next().value
console.log(id)
</code></pre>

<h4 id="toc_48">51. Proxy 和 getter setter 的区别</h4>

<p>Proxy是代理一个对象，他接收两个参数，第一个参数是代理的目标，第二个参数是拦截处理器。</p>

<pre><code class="language-javascript">const handler = {
  get(obj, key) {
    console.log(&#39;getter&#39;, obj[key])
    return obj[key]
  },
  set(obj, key, newV) {
    console.log(&#39;setter&#39;, newV)
    obj[key] = newV
  }
}
const proxy = new Proxy(obj, handler)
</code></pre>

<blockquote>
<p>Proxy的handler可以做很多<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler">操作</a>，除了getter和setter之外，还能拦截属性的读取，设置，甚至拦截new实例化</p>
</blockquote>

<p>getter和setter是Object的一个特性，他允许返回动态计算值的属性，换句话说就是钩子。在获取属性的时候触发get，设置属性的时候触发set。getter和setter还能结合Object.defineProperty来做一些自定义的返回或者拦截</p>

<pre><code class="language-javascript">const obj = {
  log: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
  get latest() {
    if (this.log.length === 0) {
      return undefined;
    }
    return this.log[this.log.length - 1];
  }
};

console.log(obj.latest);
</code></pre>

<h4 id="toc_49">52. 描述一下事件循环</h4>

<p>每一轮事件循环都包含一个宏任务队列和一个微任务队列:</p>

<ol>
<li>每一轮循环只会处理队列中的第一个宏任务</li>
<li>每一轮循环会清空微任务队列，也就是说其实每个微任务队列是对应某一个宏任务的</li>
</ol>

<p>所以每一轮事件循环，只执行对顶的宏任务和其对应的微任务队列，完成后当前事件结束。下一事件再处理新的宏任务和其对应的微任务队列</p>

<blockquote>
<p>浏览器环境和node环境的事件循环有些不同，node事件循环请看 #55 号问题</p>
</blockquote>

<h4 id="toc_50">53. CommonJS 和 ES6 模块化有什么区别</h4>

<ol>
<li>CommonJS 是被加载的时候运行，ES6 模块化是编译的时候确定依赖，也就是说重复引入同一个模块，也只会执行一次代码。tree-sharking原理就是ES6模块依赖是编译时确定的。</li>
<li>CommonJS 输出的是值的浅拷贝，并且写到内存中。ES6 模块化输出值的引用</li>
<li>CommonJS 支持动态导入，也就是 require(${path}/xx.js)</li>
<li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
</ol>

<pre><code class="language-javascript">// CommonJS
// counter.js
let count = 1
function increment() {
  count++
}
module.exports = {
  count,
  increment
}

// main.js
const counter = require(&#39;counter.cjs&#39;)
counter.increment()
// CommonJS 这里输出1，因为 CommonJS 输出的是值的浅拷贝过后的对象
// count++ 修改的是模块内的值，和输出的对象无关
console.log(counter.count)
</code></pre>

<pre><code class="language-javascript">// ES6 模块
// counter.mjs
export let count = 1
export function increment() {
  count++
}

// main.mjs
import { increment, count } from &#39;./counter.mjs&#39;
increment()
// ES6 模块输出2，因为ES6 模块化输出值的引用
console.log(count) // 2
</code></pre>

<h4 id="toc_51">54. 手写call，apply，bind</h4>

<pre><code class="language-javascript">// call
Function.prototype.myCall = function(ctx, ...args) {
  ctx = ctx || window
  ctx.fn = this
  const result = ctx.fn(...args)
  delete ctx.fn
  return result
}

// apply
Function.prototype.myApply = function(ctx, params) {
  ctx = ctx || window
  ctx.fn = this
  const result = params ? ctx.fn(...params) : ctx.fn()
  delete ctx.fn
  return result
}

// bind
Function.prototype.myBind = function(ctx, ...args) {
  // 存一下调用者（需要被绑定）的this
  const _this = this
  // bind 返回的是一个 function，所以这个被返回的东西其实是可以 new 的
  return function F() {
    // 如果 new 了这个玩意，this会被new改变，所以需要手动重新设置this的指向
    return this instanceof F ? new _this(...args, ...arguments) : _this.apply(ctx, args.concat(...arguments))
  }
}
</code></pre>

<h4 id="toc_52">55. 解释一下node的事件循环</h4>

<p>node的事件循环，每个循环都有这几个阶段</p>

<ol>
<li><p>timers</p>
<blockquote>
<p>首先是执行定时器，如果在当前循环种存在setTimeout / setInterval之类的定时器，将在这时候处理</p>
</blockquote></li>
<li><p>pending callbacks</p>
<blockquote>
<p>这个阶段也称为 I/O callbacks 阶段，主要是执行一些从上个循环延迟过来的 I/O 回调</p>
</blockquote></li>
<li><p>idle, prepare</p>
<blockquote>
<p>node 内部机制</p>
</blockquote></li>
<li><p>poll</p>
<blockquote>
<p>轮询，在这里检索新的 I/O 事件;执行与 I/O 相关的回调，其余情况 node 将在适当的时候在此阻塞，直到达到最快的一个计时器阈值为止（比如setTimeout 100ms，那如果这时候没事做，那他就等这个setTimeout 100ms）</p>
</blockquote></li>
<li><p>check</p>
<blockquote>
<p>执行setImmediate的回调</p>
</blockquote></li>
<li><p>close callbacks</p>
<blockquote>
<p>关闭当前循环</p>
</blockquote></li>
</ol>

<p><strong>例子1:</strong></p>

<pre><code class="language-javascript">const fs = require(&#39;fs&#39;)

setTimeout(() =&gt; {
  // do something
}, 1000)

// 假设这个异步操作需要10s
fs.readFile(&#39;./Demo.txt&#39;, (err, data) =&gt; {
  // do something
  // 通过while循环将fs回调强制阻塞5s
  while (endTime - readFileStart &lt; 5000) {
    // do something
  }
})

setImmediate(() =&gt; {
  // do something
})

// 1. 首先进入timers阶段，这时候并没有需要执行的timers回调（1s后才会执行）代码进入异步的I/O操作
// 2. 进入pending callbacks后发现也没有要干的（这里假设异步10s）不讨论idle和prepare内部机制，代码进入poll阶段
// 3. 进入poll轮询，一开始没有什么要干的（队列为空），但是发现一个setImmediate，于是进入check阶段
// 4. 进入check阶段把setImmediate干了，结束当前循环
// 5. 开启新的一轮循环，这时候并没有需要执行的timers回调（可能还剩几百ms后才会执行）代码进入异步的I/O操作
// 6. 进入pending callbacks同理，没啥干的进入poll阶段
// 7. 进入poll轮询，但是也没啥干的，也没有setImmediate了，那就开始等待，然后等到了定时器的阀值到了，分发了一个事件这时候回到timer把定时器干了，然后开启下一轮事件循环
// 8. timer和pending callbacks同理，到了poll之后，fs终于好了，执行I/O的回调，结束循环
</code></pre>

<p><strong>例子2:</strong></p>

<pre><code class="language-javascript">const fs = require(&#39;fs&#39;);

fs.readFile(__filename, () =&gt; {
  setTimeout(() =&gt; {
    console.log(&#39;timeout&#39;);
  }, 0);
  setImmediate(() =&gt; {
    console.log(&#39;immediate&#39;);
  });
});

// 1. 首先进入timer，啥也没，进入I/O读写
// 2. I/O读写也没东西，进入轮询
// 3. 进入poll，这时候开始等待，直到I/O回调到来，回调带来一个setTimeout，写入timer（注意这时候已经在poll阶段了，当前循环的timer期已经过了，要等下一个循环的timer）还有一个setImmediate，到check阶段
// 4. check阶段把setImmediate干了，结束当前循环
// 5. 开启新的一轮循环，timer中有个setTimeout，把它干掉，继续当前循环
</code></pre>

<blockquote>
<p>setTimeout 和 setImmediate的区别在于，setTimeout是到了时间阀值之后执行回掉，而setImmediate是在check阶段执行的回调</p>
</blockquote>

<h4 id="toc_53">56. 手写new操作符</h4>

<pre><code class="language-javascript">// new的原理:
// 1. 生成一个新的对象
// 2. 这个对象拥有构造函数原型上的方法
// 3. this指向这个对象（利用apply绑定this）
// 4. 如果构造函数返回对象，则返回构造函数创建的对象，否则返回new出来的对象
function create(constructor, ...args) {
  let obj = {}
  obj.__proto__ = constructor.prototype
  const result = constructor.apply(obj, args)
  return result instanceof Object ? result : obj
}

// 测试
function Test(name, age) {
  this.name = name
  this.age = age
}
Test.prototype.sayName = function() {
  console.log(this.name)
}
const test = create(Test, &#39;Evan&#39;, 24)
console.log(test.name)
console.log(test.age)
</code></pre>

<h4 id="toc_54">57. 虚拟dom有什么优势</h4>

<p>虚拟dom就是一个js的树结构，模拟了一颗dom树。</p>

<p>虚拟dom的优势:</p>

<ol>
<li>直接操作dom效率是很低的，要重新布局，递归，渲染。但是操作js就很快了。如果是虚拟dom，直接在js层就能把树的更改给确定，然后重新渲染改动的节点就好了。这样就不需要频繁修改dom节点，不用频繁回流重绘。</li>
<li>虚拟dom还可以在一些没有dom环境的地方模拟dom，比如node实现ssr那也要虚拟dom来模拟一颗dom树，直接输出html给前端。</li>
</ol>

<blockquote>
<p>为了提高性能，dom树的更改只会更改变动的部分，这是用的diff算法，（先序遍历深度优先）来确定什么枝叶变动了，也就是对比两个新旧obj不同的地方。</p>
</blockquote>

<p>vue 3.x 的改动:</p>

<ol>
<li>2.x时代虚拟dom会记录所有的节点，无论这个节点是静态的（比如 <code>&lt;h1&gt;Evan&lt;/h1&gt;</code> 这种）还是动态的（<code>&lt;h1&gt;{{name}}&lt;/h1&gt;</code>）这样有个弊端就是，那种完全不会变的节点，每次diff遍历也要查一遍，白白浪费时间。3.x时代给每个dom打上标记，静态的就不遍历了</li>
</ol>

<blockquote>
<p>不单是静态节点，这个标记的种类有很多种，比如是否有key，是否带监听器之类的，每种类型都是一个数字。而且静态节点会被提前提升标记出来（类似变量提升）</p>
</blockquote>

<ol>
<li>3.x多了事件缓存，事件会被写到一个可追踪的cache中，然后绑定事件的dom就变成静态节点了，事件怎么改反正就是一个cache，拿出来用就好了</li>
</ol>

<h4 id="toc_55">58. 用genarator实现async await</h4>

<pre><code class="language-javascript">const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(&#39;data&#39;), 1000))

function asyncToGenerator(genF) {
  return function() {
    return new Promise(function(resolve, reject) {
      const gen = genF()
      const step = nextF =&gt; {
        let { value, done } = nextF()
        if (done) return resolve(value)
        Promise.resolve(value).then(
          res =&gt; step(() =&gt; gen.next(res)),
          err =&gt; step(() =&gt; gen.throw(err))
        )
      }
      step(() =&gt; gen.next())
    })
  }
}

// 实现一个类似 async await 的方法
// async 关键字由 generator 代替
// await 关键字由 yield 代替
const test = asyncToGenerator(function*() {
  console.log(yield &#39;start&#39;)
  console.log(&#39;data: &#39;, yield getData())
  console.log(&#39;data2: &#39;, yield getData())
  return &#39;end&#39;
})

test().then(res =&gt; console.log(res))

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见 Vue 面试题]]></title>
    <link href="https://evanoyam.github.io/16021784313262.html"/>
    <updated>2020-10-09T01:33:51+08:00</updated>
    <id>https://evanoyam.github.io/16021784313262.html</id>
    <content type="html"><![CDATA[
<p>总结了一些常见的 Vue 面试题</p>

<h4 id="toc_0">1. vue组件传值有哪些方式</h4>

<ol>
<li>最简单的 props 和 emit</li>
<li>利用一个新的 vue 实例做监听<br/>
```js<br/>
// bus.js<br/>
import Vue from &#39;vue&#39;<br/>
export default new Vue()</li>
</ol>

<p>// 组件a<br/>
import Bus from ./bus.js<br/>
methods: {<br/>
  emitSth() {<br/>
    Bus.$emit(&#39;fromA&#39;)<br/>
  }<br/>
}</p>

<p>// 组件b<br/>
import Bus from ./bus.js<br/>
mounted() {<br/>
  Bus.$on(&#39;fromA&#39;, () =&gt; {<br/>
    ...<br/>
  })<br/>
}</p>

<pre><code class="language-text">
3. 利用vuex

#### 2. vue router 有哪些钩子，分别是什么作用
1. 全局前置守卫：```router.beforeEach((to,from,next)=&gt;{})```
&gt; - to是去哪个路由，from是来自哪个路由，next()交接钩子状态
&gt; - 路由守卫是一个promise，一定要交接next()，不然不会触发resolve
&gt; - 在next中可以传递一个路由，如next(&#39;/&#39;)去根路径
&gt; - to和from中除了有path，name等基础信息之外，还有个matched数组，存储所有匹配到的路由，在这里可以查看更多的详细信息，包括meta中的自定义信息

2. 全局后置钩子：```router.afterEach((to,from)=&gt;{})```
&gt; - 后置钩子不存在next了，有to和from，与前置钩子类似

3. 全局解析守卫：```roter.beforeResolve```
&gt; - 全局守卫是自定义的一个守卫，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

4. 独享路由前置守卫：```beforeEnter((to,from,next)=&gt;{})```
&gt; - 独享路由守卫就是某个路由专有的守卫，用法与全局路由一致，只不过定义在具体路由内

5. 组件前置路由守卫：```beforeRouteEnter((to,from,next)=&gt;{})```
&gt; - 组件内路由指的是，当触发某个路由后，路由会依次加载路由页面内所需的组件，这些组件都可以在自身组件内定义前置路由。
&gt; - 在路由被comfirm之前，每个组件都会依次调用组件内前置路由。在这个钩子中，是没办法用this（Vue实例）的，因为这个时候DOM还没初始化，还没挂载。
&gt; - 可以在next中将实例传进去next(vm=&gt;{}），next之后已经初始化完成。

6. 组件变更路由守卫：```beforeRouteUpdate((to,from,next)=&gt;{})```
&gt; - 当路由改变，但是组件被复用的时候会调用beforeRouteUpdate，比如一个页面调用了三次相同的button组件，第一次是beforeRouteEnter，后面两次调用beforeRouteUpdate
&gt; - 这个钩子中可以用this，因为DOM以及挂载好了，同时next中已经不能接受vue实例了（没意义）

7. 组件离开路由守卫：```beforeRouteLeave((to,from,next)=&gt;{})```
&gt; - 当导航（路由）离开的时候，路由内的组件开始注销，这个时候每个组件会执行这个路由守卫
&gt; - 同样可以用this，也不能在next中接受vue实例

#### 3. vuex 为什么要用单向数据流，单向数据流指的是什么
单项数据流就是数据流动方向是固定的，不能倒流。在vue中，数据流动方向都是由vue实例发起开始，最后状态池state数据变更后通知vue实例重新渲染：

</code></pre>

<p>sequenceDiagram<br/>
Vue Components-&gt;&gt;Actions: dispatch<br/>
Actions-&gt;&gt;Mutations: commit<br/>
Mutations-&gt;&gt;State: mutate<br/>
State-&gt;&gt;Vue Components: Render</p>

<pre><code class="language-text">
单项数据流是数据驱动视图的一个核心。因为数据的变更会导致视图的重新渲染，所以数据的变更需要是可追踪的。单项数据流的好处是可以追踪所有的数据（在state中）的变更都是单向的，这样保证变更状态可追溯，每次数据的变更都是由Vue实例派发出来的。保证了每个组件都是无副作用的（纯函数，函数式编程）

#### 4. 为什么要通过actions来触发mutations，直接用vue实例触发mutations不可以吗？
首先一个概念就是，mutation必须是同步的，因为mutation会修改state数据，异步的mutation状态是无法追踪的。假如mutation是异步，那action或vue实例commit一个mutation之后（比如请求数据），那不知道什么时候回调会有响应，也就无法得知state啥时候被修改。

因为mutation必须是同步的，所以如果涉及到异步的操作，那么需要一个东西能异步提交mutation，action就是这个东西。vue实例也可以发布commit触发mutation，只不过如果直接commit的mutation就必须是同步的了。

既然commit一个mutation必须是同步的，那就异步操作（dispatch）action，然后让action去commit同步的mutation就好了。dispatch可以是异步的也没关系，啥时候回调回来也没关系，反正最终他会commit，只需要追踪commit一个mutation的时间点的快照就好了，这样数据流仍然是可追踪的。

#### 5. vuex 中如何使用异步
vuex中，actions都是可异步的。并且每一个action都是返回一个promise，配合promise.then或者await/async写异步还是很舒服
```js
// 异步action
actions: {
  incrementAsync ({ commit }) {
    setTimeout(() =&gt; {
      commit(&#39;increment&#39;)
    }, 1000)
  }
}

// await / async
// 假设 getData() 和 getOtherData() 返回的是 Promise
actions: {
  async actionA ({ commit }) {
    commit(&#39;gotData&#39;, await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch(&#39;actionA&#39;) // 等待 actionA 完成
    commit(&#39;gotOtherData&#39;, await getOtherData())
  }
}
</code></pre>

<h4 id="toc_1">6. vuex 中如何使用module</h4>

<p>vuex支持模块化，模块化的时候，各个模块通过state访问自己的状态中心，通过rootState访问根状态中心</p>

<pre><code class="language-javascript">// 定义vuex
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})
store.state.a // -&gt; moduleA 的状态
store.state.b // -&gt; moduleB 的状态

// 使用时用map映射更方便
computed: {
  ...mapState(&#39;some/nested/module&#39;, {
    a: state =&gt; state.a,
    b: state =&gt; state.b
  })
},
methods: {
  ...mapActions(&#39;some/nested/module&#39;, [
    &#39;foo&#39;, // -&gt; this.foo()
    &#39;bar&#39; // -&gt; this.bar()
  ])
}
</code></pre>

<h4 id="toc_2">7. 如何监听第三方组件的声明周期</h4>

<pre><code class="language-markup">&lt;Child @hook:mounted=&quot;childMounted&quot;&gt;&lt;/Child&gt;
</code></pre>

<h4 id="toc_3">8. watch / methods / computed 的区别</h4>

<p><strong>watch：</strong></p>

<ol>
<li>watch 是监听某个数据的变化，是一个watcher，订阅一份数据，当数据改变的时候执行一个回调。如果要监听对象深层次的属性，可以用deep关键字，但是这样会深度遍历所有的属性。也可以用下面的方法针对某个深层次属性做监听</li>
<li>watch和vue响应式的watcher是类似的，只不过响应式是vue实例帮我们收集响应式data中的依赖，而watch是用户手动绑定的响应式</li>
<li>watch的初始化在data初始化之后会立马触发get获取value，此时如果有immediate属性那么立马执行watch对应的回调函数</li>
<li>当data对应的key发生变化时，触发setter，watch感知到后执行回调函数</li>
</ol>

<pre><code class="language-javascript">// 针对某个属性
watch: {
  &#39;queryData.name&#39;: {
    handler: function() {
      // do something
    }
  }
}

// 或者结合computed
computed: {
  getName: function() {
    return this.queryData.name;
  }
},
watch: {
  getName: {
    handler: function() {
      // do something
    }
  }
}
</code></pre>

<p><strong>methods：</strong></p>

<ol>
<li>methods 是方法的集合，每次调用都会执行一次方法</li>
</ol>

<p><strong>computed：</strong></p>

<ol>
<li>computed 是计算属性，他会依赖其他属性计算并且 return 一个值。和methods最大的区别是，computed会缓存，如果参数条件不变，将把缓存结果return出去，如果条件变了再重新计算。当然，也可以利用闭包保证每次执行的独立作用域，这样缓存就失效了，和methods就没差别了</li>
<li>假设 computed c 依赖 data a和b，当data初始化之后，开始初始化computed。这时候触发 c 的getter，c会去读取a和b，触发a和b的getter</li>
<li>在触发c的getter的时候，就可以缓存a和b。当下次再触发c的getter，c的getter同样去读取a和b，比对后如果发现值没有变更，那么c不触发视图更新。如果发现依赖变更，则触发更新</li>
</ol>

<h4 id="toc_4">9. 什么是mvvm</h4>

<p>mvvm是 Model-View-ViewModel 的缩写</p>

<ol>
<li>Model是模型，是数据</li>
<li>View是视图</li>
<li>ViewModel是Model和View的通信层，它不关心View如何处理数据如何渲染（但是他会帮View整理好需要的数据格式），也不关心Model变更，它只管告知双方彼此发生了变更（所谓的双向绑定）</li>
</ol>

<blockquote>
<p>传统的mvc模式是 Model-View-Controller 的缩写，Controller是在View和Model中间并且只能单向连接View和Model。Controller需要去修改Model的状态，同时还要告知View状态变了，你要如何渲染。这就导致Controller过于臃肿和庞大</p>
</blockquote>

<p>一句话总结就是mvvm使得view 和 model之间是双向通信的，而mvc是单向通信的</p>

<h4 id="toc_5">10. 什么是虚拟dom，优势是什么</h4>

<p>虚拟dom就是用js模拟一颗dom树的结构。</p>

<p>虚拟dom的优势:</p>

<ol>
<li>操作js比操作实际的dom性能好得多，避免大量的重绘回流</li>
<li>在没有dom结构的地方（比如ssr）也能用js模拟dom的结构然后解析成html的结构，直接返回给前端</li>
<li>利用diff算法（先序遍历深度优先）还能比对新旧dom树（js树）的不同，定向的修改dom节点</li>
</ol>

<blockquote>
<p>在vue 3.x 中还多了一些静态虚拟dom，事件缓存，dom提升等性能相关的优化</p>
</blockquote>

<h4 id="toc_6">11. 什么是diff算法</h4>

<p>diff是一个先序遍历，深度优先的算法，他主要是对比两个虚拟dom（obj树）的不同，然后只修改不同的树枝</p>

<h4 id="toc_7">12. history和hash模式的异同</h4>

<p>hash模式url后带有#号，通过哈希值的变更来确定路由的变更；history模式更像原生的url</p>

<p>history模式依赖h5的一些新特性，pushState和replaceState等，在不刷新当前页面的基础上修改路由</p>

<h4 id="toc_8">13. vue和react的区别</h4>

<ol>
<li>vue原生支持v-model的双向绑定，修改数据和变更视图都更容易，react有完善的state状态管理，使用jsx，可以完全用js控制整个页面，自由度更高</li>
<li>vue相对来说更简单上手，对新手和小团队快速搭建更友好，react自由度更高，从脚手架到开发到构建都提供了充分的可配自由度</li>
<li>diff和性能的选择有些差异，比如react把虚拟dom细化成一个个链表，在浏览器空闲的时候一个个慢慢diff，而vue则是利用一个Watcher做整体的发布订阅管控，包括3.x中一些静态dom提升等优化</li>
</ol>

<h4 id="toc_9">14. beforeCreated，created，mounted之间的区别</h4>

<ol>
<li>beforeCreated时vue实例还没初始化，this是不可用的，这里只能做一些和vue无关的东西</li>
<li>created的时候vue实例已经初始化完毕了，但是dom还没挂载，这里可以操作this但是不能操作dom</li>
<li>mounted的时候dom已经挂载了，可以用ref操作dom</li>
</ol>

<h4 id="toc_10">15. vue的生命周期有哪些</h4>

<ol>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
<li>beforeUpdate</li>
<li>updated</li>
<li>beforeActivate</li>
<li>activated</li>
<li>beforeDestroy</li>
<li>destroyed</li>
</ol>

<h4 id="toc_11">16. extend的作用</h4>

<p>extend生成一个构造器，能实例化一个vue。一般用来做组件（比如toast）每次实例化一个vue挂载到dom上</p>

<h4 id="toc_12">17. provide/inject的作用</h4>

<p>provide/inject 是为了提供一个全局的，父子组件通信的能力，这一般是常量且不是响应式的</p>

<pre><code class="language-javascript">// 父级组件提供 &#39;foo&#39;
var Provider = {
  provide: {
    foo: &#39;bar&#39;
  },
  // ...
}

// 子组件注入 &#39;foo&#39;
var Child = {
  inject: [&#39;foo&#39;],
  created () {
    console.log(this.foo) // =&gt; &quot;bar&quot;
  }
  // ...
}
</code></pre>

<blockquote>
<ul>
<li>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</li>
<li>但是非常不建议用provide/inject去做响应式的监听变更，因为这样数据流就不是单向流动的，你不知道是哪个组件修改了这个全局状态。</li>
</ul>
</blockquote>

<h4 id="toc_13">18. mixin和mixins的区别</h4>

<p>mixin是全局的混入，每个组件都会受到影响。mixins是单一组件混入。</p>

<p>当组件状态和混入状态冲突的时候，优先使用组件的状态</p>

<h4 id="toc_14">19. watch的对象写法</h4>

<p>watch 有对象写法，能深度监听，immediate立即执行等</p>

<pre><code class="language-javascript">watch: {
  initData: {
    handler(newV) {
      this.initSpuData(newV);
    },
    immediate: true,
    deep: true
  }
}
</code></pre>

<h4 id="toc_15">20. v-show和v-if的区别，分别适用于什么场景</h4>

<p>v-if是vue不渲染这个dom节点，在虚拟dom树中就不存在这个dom节点。</p>

<p>v-show是<code>display: none</code>，dom中是有这个节点的，只是这个节点不渲染</p>

<p>如果一个元素频繁切换状态，就用v-show，因为不需要vue做diff去判断节点是否要挂载到dom树上</p>

<p>如果一个元素很大但不会频繁切换状态，那就用v-if，因为一开始不渲染还能减少diff的时间，而渲染过一次之后也不怎么变动</p>

<h4 id="toc_16">21. 组件中的data为什么是函数，什么时候可以用对象？</h4>

<p>如果一个组件是复用的，那如果data写成对象，那所有组件将共用这个对象的状态，毕竟是引用类型。</p>

<p>所以写成函数，每次返回一个新的对象，就算组件复用，返回的对象也是独享的</p>

<p>如果是 <code>new Vue()</code> 那就可以用对象了，因为new的都是一个Vue的实例，不存在共用data一说</p>

<h4 id="toc_17">22. vue的响应式原理是什么，手写一个</h4>

<p><a href="https://www.cnblogs.com/canfoo/p/6891868.html">双向绑定</a><br/>
<a href="https://juejin.im/post/5adf0085518825673123da9a">双向绑定</a></p>

<pre><code class="language-javascript">// vue 2.x
const observe = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj
  Reflect.ownKeys(obj).forEach(key =&gt; {
    reactiveFn(obj, key, obj[key])
  })
}

const reactiveFn = (obj, key, val) =&gt; {
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      console.log(&#39;get&#39;, val)
      return val
    },
    set(newV) {
      console.log(&#39;set&#39;, newV)
      val = newV
    }
  })
}

let userInfo = {
  name: &#39;Evan&#39;,
  age: 24
}

observe(userInfo)

const name = userInfo.name
userInfo.age = 25
</code></pre>

<pre><code class="language-javascript">// vue 3.x
const proxyGenerator = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj
  const handler = {
    get(obj, key) {
      console.log(&#39;get&#39;, obj[key])
      return proxyGenerator(obj[key])
    },
    set(obj, key, newV) {
      console.log(&#39;set&#39;, newV)
      obj[key] = newV
    }
  }
  return new Proxy(obj, handler)
}

let userInfo = {
  name: &#39;Evan&#39;,
  age: 24
}

let userInfoProxy = proxyGenerator(userInfo)

const name = userInfoProxy.name
userInfoProxy.age = 25
</code></pre>

<h4 id="toc_18">23. nexttick原理</h4>

<p>看一段代码：</p>

<pre><code class="language-javascript">export default {
  data () {
    return {
      msg: 0
    }
  },
  mounted () {
    this.msg = 1
    this.msg = 2
    this.msg = 3
  },
  watch: {
    msg () {
      console.log(this.msg)
    }
  }
}
</code></pre>

<p>对于上面的代码，watch只会执行一次。这是因为vue处理响应式是批量操作而不是每一次都操作的。</p>

<p>vue双向绑定的watcher源码中有这么一句 <code>queueWatcher(this)</code>，而这玩意内又有这么一句 <code>nextTick(flushSchedulerQueue)</code>。这个 flushSchedulerQueue 其实就是更新视图的函数。<a href="https://juejin.im/post/5ae3f0956fb9a07ac90cf43e#heading-1">nextTick的源码参考这里</a></p>

<p><strong>抽象概括一下nextTick的原理：</strong></p>

<ol>
<li><code>nextTick</code> 接收一个回调，返回一个闭包</li>
<li>回调的执行时机 <code>nextTick</code> 闭包中的 <code>timerFunc</code> 控制</li>
</ol>

<blockquote>
<p><code>timerFunc</code> 用以下优先级来处理出队时机。setImmediate -&gt; MessageChannel -&gt; Promise -&gt; setTimeout。优先使用宏任务，如果不支持就使用Promise的微任务，如果还不支持就用setTimeout兼容。虽然setTimeout是宏任务，但是在http声明中setTimeout有4ms的延时，所以只拿来做兼容处理，宏任务交给 <code>setImmediate</code> 和 <code>MessageChannel</code></p>
</blockquote>

<p>也就是说用于更新视图的 <code>nextTick(flushSchedulerQueue)</code> 其实以 <code>setImmediate -&gt; MessageChannel -&gt; Promise -&gt; setTimeout</code> 优先级塞入了 Event loop 中</p>

<p>这样更新的好处是：</p>

<p>假设有个值 <code>test</code> 被while循环执行1000次++操作。每次循环时，都会根据响应式触发 <code>compile -&gt; setter -&gt; Dep -&gt; Watcher -&gt; update -&gt; run</code> 如果没有异步更新，而是每次都更新DOM，那会十分消耗性能。所以Vue实现了一个queue队列，先把所有的watcher塞到队列里。在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行queue中Watcher的run</p>

<p><strong>整个过程如下：</strong></p>

<p><strong>第一阶段：queueWatcher(this) 收集watcher队列</strong></p>

<ol>
<li>响应式触发update，把watcher塞到queue队列，并且根据watcher.id去重</li>
</ol>

<p><strong>第二阶段：nextTick(flushSchedulerQueue) 更新视图</strong></p>

<ol>
<li><code>nextTick</code> 会返回一个闭包，通过 <code>timerFunc</code> 执行 <code>flushSchedulerQueue</code> 回调</li>
<li><code>flushSchedulerQueue</code> 执行watcher的run，更新视图</li>
</ol>

<p>回到第一段代码中，虽然修改了msg三次，但是因为vue更新视图的机制，首先把三次 <code>this.msg</code> 的变动塞到队列里，根据id去重只要了最后一次变更。之后异步执行视图更新，保证在下一个Tick（或者在当前Tick的微任务中）更新视图，也就直接把 msg 从 <code>0 -&gt; 3</code> 而不是 <code>0 -&gt; 1 -&gt; 2 -&gt; 3</code></p>

<h4 id="toc_19">24. Vue 插件的原理是什么</h4>

<p>Vue插件的的使用方法是 <code>Vue.use(xx)</code></p>

<p>所有被 Vue.use 的对象，都必须包含一个 <code>install</code> 的方法，<code>Vue.use</code>的本质就是执行这个方法罢了</p>

<blockquote>
<ul>
<li>如果use的是一个function而不是一个对象，那这个方法会被直接当成install方法来执行。</li>
<li>Vue use必须在vue实例化之前执行</li>
</ul>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue 响应式原理]]></title>
    <link href="https://evanoyam.github.io/16021782785833.html"/>
    <updated>2020-10-09T01:31:18+08:00</updated>
    <id>https://evanoyam.github.io/16021782785833.html</id>
    <content type="html"><![CDATA[
<p>介绍了 Vue 的响应式原理</p>

<h2 id="toc_0">基础概念</h2>

<p>Vue的响应式也叫双向绑定，是MVVM中的核心，也就是视图View和模型Model的双向通信过程。Vue实现双向通信，依赖的基础是<strong>数据劫持 + 发布订阅</strong></p>

<blockquote>
<ul>
<li>Model 的变更决定了 View 的渲染</li>
<li>View 的用户交互反向作用于 Model 的变更</li>
</ul>
</blockquote>

<p>很多人对Vue响应式的理解只停留在数据劫持的阶段。其实要实现一个完整的双向绑定框架，除了对数据的劫持之外，还需要一个可靠的发布订阅机制</p>

<h4 id="toc_1">数据劫持</h4>

<p>所谓数据劫持，就是在<strong>读取 / 写入数据的时候触发一个回调钩子</strong>，在这个钩子中注入自己的逻辑，以达到一些特定的目的</p>

<blockquote>
<ul>
<li>Vue 2.x 用的是 <code>Object.definedProperty</code> 来劫持数据</li>
<li>Vue 3.x 用的是 <code>Proxy</code> 来劫持数据</li>
</ul>
</blockquote>

<pre><code class="language-javascript">// Object.definedProperty 数据劫持
Object.defineProperty(obj, key, {
  enumerable: true,
  configurable: true,
  get() {
    console.log(&quot;getter&quot;) // 读取属性时劫持数据
    return val
  },
  set(newV) {
    console.log(&quot;setter&quot;) // 设置属性时劫持数据
    val = newV
  }
})

// Proxy 劫持数据
new Proxy(obj, {
  get(obj, key) {
    console.log(&#39;getter&#39;)
    return obj[key]
  },
  set(obj, key, newV) {
    console.log(&#39;setter&#39;)
    obj[key] = newV
  }
})
</code></pre>

<h4 id="toc_2">发布订阅</h4>

<p>发布订阅是一种比较常见的设计模式。订阅者向发布者订阅某条消息，当消息发生变更时（或者满足某个条件 / 时机时），发布者向订阅者推送消息。</p>

<pre><code class="language-javascript">class Dep {
  constructor() {
    this.eventQueueMap = new Map()
  }
  on(event, cb) {
    this.eventQueueMap.has(event) ? this.eventQueueMap.get(event).push(cb) : this.eventQueueMap.set(event, [cb])
  }
  emit(event, ...args) {
    const eventQueue = this.eventQueueMap.get(event)
    if (!eventQueue) return false
    eventQueue.forEach(cb =&gt; {
      cb(args)
    })
  }
  off(event) {
    if (this.eventQueueMap.has(event)) this.eventQueueMap.delete(event)
  }
}

const event = new Dep()

// 订阅
event.on(&#39;test&#39;, function(name) {
  console.log(name)
})

// 发布
event.emit(&#39;test&#39;, &#39;二哈&#39;, &#39;波斯猫&#39;)
</code></pre>

<h2 id="toc_3">实现一个响应式框架</h2>

<h4 id="toc_4">先看一下Vue响应式的实现过程</h4>

<p><img src="https://cn.vuejs.org/images/data.png" alt="image"/></p>

<ol>
<li>首先初始化data对象，劫持这堆东西，让他们变得可追踪</li>
<li>初始化Watcher，订阅自己关注的数据</li>
<li>读取数据时触发getter，实现 Model -&gt; View 的渲染</li>
<li>设置数据时触发setter，实现 View -&gt; Model 的变更，同时 Model 变更后 Watcher 重新渲染视图</li>
</ol>

<blockquote>
<p>在整个响应式的过程中其实还涉及到Dep依赖收集和Compile解析器等功能，后面会慢慢讲解</p>
</blockquote>

<h4 id="toc_5">自己做一个</h4>

<p><a href="https://www.cnblogs.com/canfoo/p/6891868.html">要做一个响应式框架</a>，涉及到监听器Observer，依赖收集中心Dep，订阅者Watcher，解析器Compile。</p>

<ol>
<li>监听器Observer，负责劫持数据。</li>
</ol>

<blockquote>
<p>需要递归把数据对象的所有属性都劫持成可追踪的</p>
</blockquote>

<ol>
<li>依赖收集中心Dep，负责管理订阅者，发布消息，是发布订阅中的发布者。</li>
</ol>

<blockquote>
<p>不是所有的数据都是View用得上的，只需要派发有人订阅的数据即可。Dep依赖收集中心就是来负责管理这些订阅者的。</p>
</blockquote>

<ol>
<li>订阅者Watcher，负责订阅自身关注的数据，可以收到属性的变化通知并执行相应的函数，从而更新视图，是发布订阅中的订阅者</li>
</ol>

<blockquote>
<p>在订阅者初始化的时候，触发劫持对象的getter，将自己注入到Dep中，表示需要订阅某个数据</p>
</blockquote>

<ol>
<li>解析器Compile，负责扫描和解析每个节点的相关指令，来识别哪些数据需要订阅，需要双向绑定</li>
</ol>

<blockquote>
<p>解析器就是发布 - 订阅的桥梁，让订阅者和发布者之间产生联系。比如识别到 <code>{{}}</code> 就初始化一个Watcher监听它，并且由Dep管理这个Watcher，篇幅有限，本文就不实现Compile了</p>
</blockquote>

<h4 id="toc_6">监听器Observer</h4>

<pre><code class="language-javascript">class Observer {
  constructor() {
    this.dep = new Dep()
  }
  observe(obj) {
    if (!obj || typeof obj !== &#39;object&#39;) return obj
    Reflect.ownKeys(obj).forEach(key =&gt; {
      // 劫持对象的所有属性
      this.reactiveFn(obj, key, obj[key])
    })
  }
  reactiveFn(obj, key, val) {
    // 递归劫持所有属性的子属性
    this.observe(val)
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: () =&gt; {
        // 只有初始化 Watcher 时触发的 getter，才需要订阅
        if (Dep.target) {
          this.dep.addSub(Dep.target) // 订阅数据
        }
        return val
      },
      set: newV =&gt; {
        // 通知 Watcher
        if (val !== newV) {
          val = newV
          this.dep.notify()
        }
      }
    })
  }
}
</code></pre>

<h4 id="toc_7">依赖收集中心Dep</h4>

<pre><code class="language-javascript">class Dep {
  constructor() {
    this.subs = []
  }
  // 把 watcher 塞入订阅者队列
  addSub(sub) {
    this.subs.push(sub)
  }
  // 通知所有的订阅者数据已变更
  notify() {
    this.subs.forEach(function(sub) {
      sub.update()
    })
  }
}
</code></pre>

<h4 id="toc_8">订阅者Watcher</h4>

<pre><code class="language-javascript">class Watcher {
  constructor(vm, exp, cb) {
    this.vm = vm
    this.exp = exp
    this.cb = cb
    this.value = this.watch() // 将自己添加到订阅器
  }
  update() {
    var value = this.vm.data[this.exp]
    var oldVal = this.value
    if (value !== oldVal) {
      this.value = value
      this.cb.call(this.vm, value, oldVal)
    }
  }
  watch() {
    Dep.target = this // 缓存自己
    var value = this.vm.data[this.exp] // 强制执行监听器里的get函数
    Dep.target = null // 释放自己
    return value
  }
}
</code></pre>

<h4 id="toc_9">测试用例</h4>

<pre><code class="language-javascript">// 这里省去解析器Compile
class MyVue {
  constructor(options) {
    this.data = options.data()
    const observer = new Observer()
    observer.observe(this.data)
    for (let key in this.data) {
      console.log(&#39;初始化模板的值为&#39;, this.data[key])
      new Watcher(this, key, function(value) {
        console.log(&#39;值被修改为&#39;, value)
      })
    }
    return this
  }
}

const vm = new MyVue({
  data() {
    return {
      name: &#39;Evan&#39;,
      age: 24
    }
  }
})
setTimeout(function() {
  vm.data.name = &#39;Fiona&#39;
  vm.data.age = 26
}, 2000)
</code></pre>

]]></content>
  </entry>
  
</feed>
