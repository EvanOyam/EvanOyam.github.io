<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Evan的博客]]></title>
  <link href="https://evanoyam.github.io/atom.xml" rel="self"/>
  <link href="https://evanoyam.github.io/"/>
  <updated>2020-10-11T22:09:15+08:00</updated>
  <id>https://evanoyam.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[前端面经复盘]]></title>
    <link href="https://evanoyam.github.io/16023497016429.html"/>
    <updated>2020-10-11T01:08:21+08:00</updated>
    <id>https://evanoyam.github.io/16023497016429.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">前言</h2>

<p>这次面试总共花了约一个月，8 月中旬开始，到 9 月中旬</p>

<p>期间共面试 5 家公司：<strong>腾讯，字节跳动，百度，富途，转转</strong></p>

<p>面试完之后打算抽空简单写写总结，复盘。这篇面经主要会针对以下几个方面去总结：</p>

<ol>
<li><p>每个厂面试过程的感受</p></li>
<li><p>每个厂的面试风格和难度</p></li>
<li><p>印象深刻或者觉得有价值的真题</p>
<blockquote>
<p>不会写很详细的解答，会提及相关知识点，想了解的还是需要自己查一查资料。要是全部详细写完剖析完，怕是能写一小本子了...</p>
</blockquote></li>
<li><p>最后会聊聊复习策略，选厂看法和未来的路等</p></li>
</ol>

<p><strong>题目较多，建议先把所有面经风格看完，再回过头看感兴趣的真题</strong></p>

<h2 id="toc_1">腾讯面经</h2>

<h4 id="toc_2">面试进度：offer</h4>

<h4 id="toc_3">面试难度：⭐️⭐️⭐️⭐️</h4>

<h4 id="toc_4">面试风格：深挖原理 + 适量算法</h4>

<h4 id="toc_5">过程介绍：</h4>

<p>我面的是 PCG 的部门。腾讯的面试流程很长，前前后后需要大概一个月。一个部门大概是<strong>4 轮技术面，1 轮 hr 面</strong>。可以换部门车轮战，但是真的要等很久很久...</p>

<p>整个面试过程感觉是比较 nice 的，每一轮面试官都很尊重人，hr 谈薪资 offer 之类的也是很和蔼（其实声音很年轻 2333）整体下来感觉面的很舒服，至少我面的部门给人感觉很舒服。</p>

<p><strong>面试风格这一块腾讯比较喜欢深挖原理</strong>，只要写在简历上的，都会把你问个底朝天。建议没有十足把握的（我指的是有自己见解或者看过源码）项目或者技术不要写上，千万不要觉得看过一点甚至只是听过某个框架，就写上去...否则会死的很惨...算法问的不算多，谈不上难，刷过一定题量的同学应该问题不大。</p>

<h4 id="toc_6">面试题：</h4>

<ol>
<li><p>Vue 双向绑定</p>
<blockquote>
<p>常规操作，但是会一直往深处问，除了对象劫持，Proxy 这些常规回答，还需要了解一下整个发布订阅的流程，Watcher，Dep，Observer，Compile 等几个类的源码建议读一下</p>
</blockquote></li>
<li><p>有多少种不同类型的 Watcher</p>
<blockquote>
<p>data，props，computed，watch，以及 vuex 中 state 也是 Watcher</p>
</blockquote></li>
<li><p>Vue 什么时候收集 Watcher 的依赖</p>
<blockquote>
<p>所谓收集依赖意思就是问什么时候注入 Watcher，即绑定观察者和被观察者之间的关系。最好先介绍一下有哪几种 Watcher，再分类讨论不同 Watcher 的注入特性。我面的时候面试官是循序渐进的，看得出是源码大牛，一个个问题环环相扣。</p>
<p>简单介绍一下 Vue 实例化的过程：首先劫持 <code>VNode.prototype</code> 变成可响应，然后有个执行 <code>_init</code> 操作。感兴趣的童鞋可以查一下 <code>initMixin</code> 这个方法。这个过程中会初始化生命周期，事件，渲染方法，然后在处理完 <code>beforeCreated</code> 的钩子之后，会执行 <code>initState</code>，就是在这玩意里面收集 data，props 以及 computed 相关的 Watcher 依赖。<strong>总之就是，在 created 之前，beforeCreated 之后，要处理完所有 vm 实例的依赖收集并且初始化，这也是为什么 created 就能用 this.xx 的原因</strong>。具体细节还是要自己看看源码，当然还有包括 watch 其实也是 Watcher，但是这时候就是开发者主动声明的观察者，而不是 Vue 初始化的时候帮我们分析依赖了。</p>
</blockquote></li>
<li><p>父子组件嵌套的时候，Vue 第一次注入 Watcher 的时候是什么时候，为什么</p>
<blockquote>
<p>这个其实问的是组件初始化的顺序。父 created，子 created，子 mounted，父 mounted。类似 Koa 的洋葱模型，从外到里再到外。原因也比较简单，子组件未确认状态且未渲染的时候，父组件要是抢先确定了自己状态并且渲染，那不就裂开了，它怎么知道它的子组件长啥样。</p>
</blockquote></li>
<li><p>computed 的 Watcher 和 data 的 Watcher 有啥区别</p>
<blockquote>
<p>核心就是缓存，至于如何缓存的这里就不过多赘述了，一搜一大把。还是那句话，记得看源码。</p>
</blockquote></li>
<li><p>Vuex 的设计模式</p>
<blockquote>
<p>单例模式，单项数据流，状态追踪</p>
</blockquote></li>
<li><p>为什么异步操作要写到 actions 里面，而不能异步 mutation</p>
<blockquote>
<p>mutation 会修改 state 数据，异步的 mutation 状态是无法追踪的。假如 mutation 是异步，比如请求数据，那不知道什么时候回调会有响应，也就无法得知 state 啥时候被修改。</p>
<p>既然 commit 一个 mutation 必须是同步的，那就异步 dispatch action 好了，然后让 action 去 commit 同步的 mutation。dispatch 可以是异步的也没关系，啥时候回调回来也没关系，反正最终他会 commit，<strong>只需要追踪 commit 一个 mutation 的时间点的快照就好了</strong>，这样数据流仍然是可追踪的。</p>
</blockquote></li>
<li><p>Vuex 是什么时候注入 Vue 的，怎么注入</p>
<blockquote>
<p>一样的道理，既然能 this.xx 调用，那肯定要在 created 之前注入。其实 Vuex 本质只是一种数据流状态的管理方式，就算脱离了 Vue 也是能使用的。这和 Redux 类似。至于注入的过程，其实就是 mixin。当然这个过程涉及到 Vuex moudle 的组合和构建，Vuex 的源码我没看的很仔细，有时间补一补。</p>
</blockquote></li>
<li><p>Vue 作为 viewModel 层，它是怎么感知 model 层中状态的变更的</p>
<blockquote>
<p>这里我也是猜测。既然要响应式那还是离不开 getter 和 setter 两兄弟。Vuex 初始化完会在 Vue 实例（这里称它为 vmA）上挂载一个 <code>$store</code>，其实里面的数据就是利用一个 new Vue （这里称它为 vmB）来做发布订阅和双向绑定的。也就是说当读取（或设置）某个 state 的属性的时候，其实就是触发 vmB 的 getter setter 两兄弟，再通知 vmA 罢了。类似于自己利用 Vue 写个 <code>$Bus</code> 吧。（大部分自己理解，可能有点出入，不过后来稍微查了下资料大致是这个思路）</p>
</blockquote></li>
<li><p>介绍一下 service worker</p>
<blockquote>
<p>web worker 的是一种，是独立的线程。介绍一下 sw 的生命周期，还有常见应用场景（pwa 和缓存，跨页面通信等。注意这里其实也会深挖，比如如何缓存 response 的，然后怎么控制缓存池的缓存策略，如何更新 sw 版本，兜底方案之类的）</p>
</blockquote></li>
<li><p>service worker 如何做到跨线程通信</p>
<blockquote>
<p><code>messageChannel</code> 或者 <code>postMessage</code> 之类的。除了正常通讯，其实也能做心跳保活，一般用来侦测页面是否崩溃。（页面崩溃的时候，当前页面的 js 线程压根就不会工作，一切通信都无济于事。但是 sw 的独立的线程，他不受影响）比如 tabA 和 tabB 两个客户端，都接入 sw，然后做 <code>messageChannel</code> 或者 <code>postMessage</code> 心跳保活。一旦收不到某一端的心跳消息，就意味着这个 tab 挂了</p>
</blockquote></li>
<li><p>既然是独立线程，那必然不是同步的，怎么保证消息传递的同步性，如何设计</p>
<blockquote>
<p>回调。关于设计，我也是即兴发挥，个人感觉可以参考 promise 状态机的设计理念，resolve 保证同步并且遵循 A+ 规范状态不可逆</p>
</blockquote></li>
<li><p>webpack plugin 有哪些生命周期钩子，可以用来做什么</p>
<blockquote>
<p>记一个大概流程即可：即将开始编译，开始编译，编译完成，准备生成文件，结束并释放资源</p>
<ol>
<li><code>Compile</code> 开始进入编译环境，开始编译</li>
<li><code>Compilation</code> 即将产生第一个版本</li>
<li><code>make</code> 任务开始</li>
<li><code>optimize</code> 作为 <code>Compilation</code> 的回调方法，优化编译，在 <code>Compilation</code> 回调函数中可以为每一个新的编译绑定回调。</li>
<li><code>after-compile</code>编译完成</li>
<li><code>emit</code>准备生成文件，开始释放生成的资源，最后一次添加资源到资源集合的机会</li>
<li><code>after-emit</code>文件生成之后，编译器释放资源</li>
</ol>
<p>可以利用一些钩子扩充 webpack 的能力，比如构建前清空 output 目录，比如移动文件，编译完成后修改某些文件 Buffer 等</p>
</blockquote></li>
<li><p>发布订阅和观察者模式的区别</p>
<blockquote>
<p>观察者没有中间商赚差价...</p>
<p>实现方式，差异，优劣势等谷歌搜一下吧，这里不赘述了</p>
</blockquote></li>
<li><p>WebSocket</p>
<blockquote>
<p>双工通信，不受同源策略限制，二进制传输，由 http upgrade 等</p>
<p>主要介绍一下和长链接有什么不同：</p>
<p>长连接是 http 1.1 的规范。客户端发起一个 http 请求后，服务端保持请求状态而不响应，直到需要推送的时候再响应。因为 http 是一个 req 和 res 相对应的连接，所以每次服务端响应之后，http 断开，这时候客户端再发一个 http 过来，服务端保持请求状态。换句话说如果客户端不发 http 过来，就算是 tcp 连着，服务端推送消息客户端也收不到，因为不知道是客户端是谁</p>
</blockquote></li>
<li><p>http2</p>
<blockquote>
<ol>
<li>传输数据由明文传输改成二进制流传输</li>
<li>数据传输采用多路复用，请求合并在同一 TCP 连接内，解决队头阻塞的问题</li>
<li>支持服务端推送</li>
<li>使用 HPACK 算法来压缩首部内容</li>
</ol>
</blockquote></li>
<li><p>quic</p>
<blockquote>
<p>改用 udp ，彻底干掉队头阻塞的问题。http2 归根结底还是 tcp 的，某个包丢了还是要等待重连。强依赖唯一一个 tcp 的策略，甚至在某些情况还不如 http1.1。比如这个 tcp 就是挂了，好歹 http1.1 还有其他的 tcp 连接数不至于全崩</p>
<p>quic 注意他是通过 Stream Offset 来控制可靠性的，感兴趣的童鞋可以查一下相关资料，这里不多说了</p>
</blockquote></li>
<li><p>手写 call 方法</p>
<blockquote>
<p>手写是一方面，感觉面试官更想了解函数设计思路。比如他提问，你会选择哪种调用方法来执行函数（挂载原型链还是声明独立函数）还有执行过程中一些细节，比如 delete 掉绑定在上下文上的方法再 return；比如上下文中会不会已经有了这个方法名，如何兼容等</p>
</blockquote></li>
<li><p>算法</p></li>
</ol>

<pre><code class="language-javascript">// 题一
// 类似 leetcode 673题
// 给一个字符串，找出最长递增子序列
// 如果有相同长度，返回字典集最小的
//
// 例：
// 输入 &quot;23648179&quot; 返回 &quot;23489&quot;

// 题二
// leetcode 206题
// 翻转链表

// 题三
// leetcode 94题
// 中序遍历一棵树，除了递归还能用什么方法
</code></pre>

<ol>
<li>其他都是和项目相关的，或者个人感觉参考价值不大的，就不过多介绍了</li>
</ol>

<blockquote>
<p>和项目相关的就不说了</p>

<p>然后以下面试题和项目无关，但是感觉参考价值不大，感兴趣可以了解</p>

<p>WebRTC，生成和注入骨架屏，性能优化，Mutation Observer 加权计算首屏时间，NAT 穿越，docker 相关，serverless 相关，JavaScript Bridge 原理，flutter，rn，hybrid 三者原理和性能差距，线程和进程的区别，链表和树的区别</p>
</blockquote>

<h2 id="toc_7">字节面经</h2>

<h4 id="toc_8">面试进度：offer</h4>

<h4 id="toc_9">面试难度：⭐️⭐️⭐️⭐️</h4>

<h4 id="toc_10">面试风格：大量算法</h4>

<h4 id="toc_11">过程介绍：</h4>

<p>字节面的是小程序相关的部门。字节面试效率挺高，基本上 10 天左右能面完。<strong>3 轮技术面，1 轮 hr 面</strong>。面试感觉是雷厉风行的，很尊重面试者，但是也很干练，不会扯无关的东西。很注重效率。字节给的薪资是这次面试中所有厂里给的最高的，甚至超过了我预期不少...</p>

<p><strong>面试风格这一块字节是名副其实的算法大户</strong>，每一轮都有 2-3 题算法，3 轮下来大概 8-9 题这样。难度比例大概是 15% 简单的题，70% 中等难度的题，15% 比较难的题。第三轮是压力面，会不断给你压力做一些比较难（或者边界条件比较多）的应用类算法，而且必须可执行通过提供的几个测试用例，加上时间限制，容易把心态搞崩...</p>

<p>除了刷题之外，<strong>要有意识去锻炼思维</strong>，比如什么时候用动态规划，什么时候尾递归，什么时候回溯剪枝，什么时候用栈等等。字节的算法面试和其他厂不一样，其他厂来来去去就那几十题常见的，字节可能就是从 leetcode 几千号题库里随便抽一道出来...任你刷题刷爆肝，想背题在字节这里是行不通的。</p>

<h4 id="toc_12">面试题：</h4>

<ol>
<li><p>写出输出结果</p>
<pre><code class="language-javascript">var a = function () {
 this.b = 3<br/>
}<br/>
var c = new a()<br/>
a.prototype.b = 9<br/>
var b = 7<br/>
a()<br/>
console.log(b) // 7<br/>
console.log(c.b) // 3
</code></pre></li>
<li><p>实现批量请求函数</p>
<pre><code class="language-javascript">// 实现一个可以批量 fetch 的函数，接收 urls 数组，max 最大并发量，cb 回调三个参数
// 当所有请求结束之后，需要执行cb<br/>
// 始终保持最大并发量执行，即一个 fetch 结束，另一个 fetch 立即补上，直到请求完所有的 url<br/>
/**<br/>
* 批量请求函数，每个人写法不同，这里就不写了<br/>
* @param {Array} urls api数组<br/>
* @param {Number} max 最大并发量<br/>
* @param {Function} callback 回调函数<br/>
*/<br/>
const sendRequest = (urls, max, callback) =&gt; {<br/>
 // ...<br/>
}
</code></pre></li>
<li><p>实现函数连续调用</p>
<pre><code class="language-javascript">// 实现一个求和方法，支持以下调用方式
// 1. sum(1)(2)(3)<br/>
// 2. sum(1, 2)(3)<br/>
// 3. sum(1, 2, 3)<br/>
/**<br/>
* 思路是柯里化函数<br/>
*/<br/>
function sum() {<br/>
 let args = [].slice.call(arguments)<br/>
 let fn = function () {<br/>
   let fn_args = [].slice.call(arguments)<br/>
   return sum.apply(null, args.concat(fn_args))<br/>
 }<br/>
 fn.toString = function () {<br/>
   return args.reduce((a, b) =&gt; a + b)<br/>
 }<br/>
 return fn<br/>
}<br/>
const t1 = sum(1)(2)(3)<br/>
const t2 = sum(1, 2)(3)<br/>
const t3 = sum(1, 2, 3)<br/>
console.log(t1.toString()) // 6<br/>
console.log(t2.toString()) // 6<br/>
console.log(t3.toString()) // 6
</code></pre></li>
<li><p>用尾递归实现一个阶乘方法</p>
<pre><code class="language-javascript">// 简单粗暴的阶乘其实很简单，但是要考虑性能就涉尾递归
// 然后面试官还问了尾递归是为了解决什么问题<br/>
// 然后为什么 node 里现在反而又取消了尾递归的支持<br/>
//<br/>
// 尾递归是防止爆栈，原理是 js 运行时函数执行栈追踪环境相关的问题<br/>
// 尾递归虽然防爆栈，但是函数执行环境的追踪也丢失了<br/>
// 感兴趣可以查一下相关资料，这里要说又能说半天...<br/>
/**<br/>
* 暴力版阶乘<br/>
* @param {Number} n 阶乘数<br/>
*/<br/>
function fn(n) {<br/>
 if (n === 1) return 1<br/>
 return n * fn(n - 1)<br/>
}<br/>
/**<br/>
* 尾递归阶乘<br/>
* @param {Number} n 阶乘数<br/>
* @param {Number} x 上一轮执行结果，初始值 1<br/>
*/<br/>
function fn(n, x = 1) {<br/>
 if (n === 1) return x<br/>
 return fn(n - 1, n * x)<br/>
}
</code></pre></li>
<li><p>二叉树路径求和</p>
<pre><code class="language-javascript">// 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径
// 这条路径上所有节点值相加等于目标和。<br/>
// leetcode 112题<br/>
/**<br/>
* 二叉树路径求和<br/>
* @param {Node} root 根节点<br/>
* @param {Number} sum 和<br/>
*/<br/>
const hasPathSum = function (root, sum) {<br/>
 if (!root) return false<br/>
 if (root.left === null &amp;&amp; root.right === null) return root.val === sum<br/>
 sum = sum - root.val<br/>
 return hasPathSum(root.left, sum) || hasPathSum(root.right, sum)<br/>
}
</code></pre></li>
<li><p>大数相加</p>
<pre><code class="language-javascript">// 相加还是相乘我忘了，面试过程中还有些题不太记得
// 反正相加也好相乘也好，都是模拟小学学运算的时候逐位运算<br/>
//<br/>
// 这题我觉得比较有应用意义，一些大数的运算用 Number 型会溢出，需要用字符串模拟运算<br/>
// 再加上网上搜到的结果五花八门，这里代码就详细写一下<br/>
/**<br/>
* 大数相加<br/>
* @param {String} a 数字字符<br/>
* @param {String} b 数字字符<br/>
*/<br/>
function plus(a, b) {<br/>
 let maxLength = Math.max(a.length, b.length)<br/>
 a = a.padStart(maxLength, 0) // 补0<br/>
 b = b.padStart(maxLength, 0) // 补0<br/>
 let x = 0 // 位数相加的结果<br/>
 let y = 0 // 进位<br/>
 let sum = &#39;&#39; // 最终字符串<br/>
 for (let i = maxLength - 1; i &gt;= 0; i--) {<br/>
   x = Number(a[i]) + Number(b[i]) + y // 位数相加，并且加上进位<br/>
   y = Math.floor(x / 10) // 进位<br/>
   sum = `${x % 10}${sum}` // 位数相加结果取余，拼接上已有结果<br/>
 }<br/>
 return y === 1 ? `1${sum}` : sum // 有多余的进位记得加上<br/>
}
</code></pre></li>
<li><p>三数之和</p>
<pre><code class="language-javascript">// leetcode 15题
// 判断数组 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0<br/>
/**<br/>
* 三数求和<br/>
* @param {Array} nums 数组<br/>
*/<br/>
const threeSum = function (nums) {<br/>
 nums.sort((a, b) =&gt; a - b)<br/>
 let res = []<br/>
 for (let i = 0; i &lt; nums.length; i++) {<br/>
   if (nums[i] * nums[nums.length - 1] &gt; 0) return res<br/>
   if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue<br/>
   let lp = i + 1<br/>
   let rp = nums.length - 1<br/>
   while (lp &lt; rp) {<br/>
     const sum = nums[i] + nums[lp] + nums[rp]<br/>
     if (sum === 0) {<br/>
       res.push([nums[i], nums[lp], nums[rp]])<br/>
       lp++<br/>
       rp--<br/>
       while (lp &lt; rp &amp;&amp; nums[lp] === nums[lp - 1]) lp++<br/>
       while (lp &lt; rp &amp;&amp; nums[rp] === nums[rp + 1]) rp--<br/>
     }<br/>
     if (sum &gt; 0) rp--<br/>
     if (sum &lt; 0) lp++<br/>
   }<br/>
 }<br/>
 return res<br/>
}
</code></pre></li>
<li><p>实现一个计算器</p>
<pre><code class="language-javascript">// leetcode 772题（224题 + 227题的结合体）
// 这题真要搞起来是无敌蛋疼<br/>
// 因为要考虑的元素很多，比如：<br/>
// 输入的字符串是不是有效的运算式，多层级括号用栈处理优先级，4则运算的优先级等等<br/>
// 这里我是懒得写了...网上也有答案
</code></pre></li>
<li><p>Vue 和 React 你觉得哪个好，你做项目如何选型</p>
<blockquote>
<p>Vue 集成度更高，上手快且方便</p>
<p>React 灵活性更强，方便根据团队和业务特性深度定制，比如 react 定制脚手架和 webpack 更方便，对整个 vm 层控制权更大，all in js。其他就 diff 上有些差异。选择的话优先考虑团队技术栈，二是对 build 包轻重量的考虑，三是考虑更偏向于通用形还是需要深度定制</p>
</blockquote></li>
<li><p>介绍一下箭头函数的，以及它 this 的指向</p>
<blockquote>
<p>箭头函数没有上下文，<code>this</code> 继承于定义时的外层词法环境，如果没有则跟着作用域链一路查找直到最外层（浏览器是 <code>window</code> 对象，<code>node</code> 环境是 <code>exports</code> 对象）</p>
<p>注意在 node 环境执行箭头函数 <code>this</code> 会指向 <code>exports</code> 对象而不是 <code>global</code>，因为 node 是模块化的，node 执行每个文件会给一个单独的作用域（模块），这是一个闭包环境。在一个模块（文件）中，声明的变量都是在这个闭包环境内的，不会污染 <code>global</code> ，而 <code>this</code> 指向的是 <code>module.exports</code> ，而不是 <code>global</code></p>
<p>如果直接调用一个正常定义的函数，那么这个就是由 <code>global</code> 对象调用的，<code>this</code> 会绑定在 <code>global</code> 上。如果调用一个箭头函数，this 是向上级词法环境查找的，如果上级没有作用域，就跟着作用域链一路找到定义时的最外层对象上（exports）</p>
</blockquote></li>
<li><p>简单请求和复杂请求有什么区别，怎样算是复杂请求</p>
<blockquote>
<p>简单请求和复杂请求都是对于跨域而言的。满足以下条件是简单请求，其他都是复杂请求</p>
<ol>
<li>是 <code>get/post/head</code> 其中一种请求</li>
<li>请求头只包含 <code>accept</code>，<code>accept-language</code>，<code>content-language</code>，<code>content-type</code></li>
<li>并且 <code>content-type</code> 是表单，<code>formdata</code> 或者文本中的一种</li>
</ol>
<p>对于简单请求，浏览器会在请求头加一个 origin 字段，用来告诉服务端是否可以跨域。对于复杂请求，浏览器会发起一个 options 的预检信息，预检通过之后才会发正式请求，也是用 origin 判断</p>
</blockquote></li>
<li><p>有哪些跨域的方法</p>
<blockquote>
<ol>
<li>jsonp</li>
<li>ng 配置 <code>Access-Control-Allow-Origin</code>， <code>Access-Control-Allow-Methods</code>， <code>Access-Control-Allow-Headers</code> 相关属性</li>
<li>后端服务器也可以设置允许跨域，自己设也行，或者用一些第三方封装好的包。比如 node 可以用 koa-cors 之类的包</li>
</ol>
</blockquote></li>
<li><p>如何检测内存泄漏</p>
<blockquote>
<p>内存快照</p>
</blockquote></li>
<li><p>V8 垃圾回收策略是怎样的</p>
<blockquote>
<p>新生代算法和老生代算法。大多都可查，这里讲讲新生代的 to 和 from 为啥要这么设计。</p>
<p>新生代管理短时间占用内存空间的引用，默认情况下，32 位系统新生代内存大小为 16MB，64 位系统下，新生代内存大小为 32MB。</p>
<p>因为新生代管理的是不稳定的引用，大部分是很快就销毁的引用（只用几次的变量或者阅后即焚类型的）也就是说<strong>新生代只需要复制还活着的内存引用，其余的三下五除二全部清空掉</strong>。这样的好处就是对于新生代管理的内存而言，大部分都是不稳定的，只有少部分稳定。它只需要关心少部分稳定的即可，其他大部分的一股脑全干了，效率会比较高。</p>
</blockquote></li>
<li><p>监控性能数据你是如何选定指标的</p>
<blockquote>
<p>从 performance API 去分析，针对不同阶段大致分成网络阶段，资源下载阶段，DOM 解析阶段三部分。具体细节可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance">MDN 的文档</a></p>
<p>对于路由按需加载的 SPA 应用来说，这样分析也是不准确的。当路由切换的时候再去请求的时候，实际上请求的不是 html 而是 js 文件。这样会让 <code>domContentLoadedEventEnd</code> 监测不到了相关的数据。<a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics?hl=zh-cn">可以参考谷歌用户体验追踪的文档</a>，有个 FSP 的概念</p>
<p>除了 FSP 还有更硬核的解决方案，就是利用 <code>Mutation Observer</code> 来监控整个 DOM 树的变化，并且每个节点会给他赋权，比如图片感觉比较重要，那就图片权重为 10，文字权重 5，title 权重 15 等。最后再计算一个值，来得出当前屏幕主要元素绘制完毕时候的时间节点</p>
</blockquote></li>
<li><p>其他很多不记得了，字节面完有一段时间了，大概记得的是这些</p>
<blockquote>
<p>有些和鹅厂重复，可以参考鹅厂攻略</p>
<p>Vue 双向绑定原理，实现简单版的 Vue 包括 Watcher 发布订阅等，service worker 介绍，http2 等</p>
</blockquote></li>
</ol>

<h2 id="toc_13">百度面经</h2>

<h4 id="toc_14">面试进度：offer</h4>

<h4 id="toc_15">面试难度：⭐️⭐️</h4>

<h4 id="toc_16">面试风格：常规问题 + 简单算法</h4>

<h4 id="toc_17">过程介绍：</h4>

<p>百度是我把简历挂出去之后，hr 联系我，问我要不要面的。是一个 QA 部门。<strong>3 轮技术面，1 轮产品面，1 轮 hr 面</strong>。面试官都很年轻，有个好像是和我同届（19 年毕业）的。面试过程感觉还不错，就是约面的 hr 感觉有点怪怪的，可能也是实习生或者工作不久，沟通和执行效率都比  较低。但是最后 hr 面试时那个 hrbp 给人感觉就很舒服，和鹅厂的 hr 给人感觉差不多</p>

<p><strong>这次面试百度说实话感觉偏简单，但是会有一轮产品面试</strong>。也可能是面试官经验不怎么丰富。一二面的面试题都实在太浅，三面应该是 leader，但是是后端的，会问一些简单的算法。</p>

<h4 id="toc_18">面试题：</h4>

<ol>
<li><p>Vue 生命周期介绍</p></li>
<li><p>Vue computed 和 methods 有什么区别</p></li>
<li><p>Vue $router 和 $route 的区别</p></li>
<li><p>Vue 2.x 和 3.x 怎么劫持对象</p>
<blockquote>
<p><code>Object.defineProperty()</code>，<code>Proxy</code></p>
</blockquote></li>
<li><p>SPA 想做 SEO 有什么解决方案</p>
<blockquote>
<p>除了 SSR 和预渲染等方案，面试官还提到 noscript 标签也可以做 SEO</p>
</blockquote></li>
<li><p>301 状态码和 302 状态码对 SEO 有什么影响</p>
<blockquote>
<p>301 是永久重定向，搜索引擎会把旧资源的 SEO 权重全部重新分配。302 是临时重定向，只是暂时修改了资源地址，权重还是在之前的资源上</p>
</blockquote></li>
<li><p>常见 http 状态码</p>
<blockquote>
<p>说完后追问了下 401 和 403 的区别。区别就是一个还没鉴权，一个是鉴权完没权限</p>
</blockquote></li>
<li><p>介绍了解的排序</p></li>
<li><p>说说快排如何实现</p>
<pre><code class="language-javascript">Array.prototype.quickSort = function () {
 if (!this.length) return []<br/>
 let leftArr = []<br/>
 let rightArr = []<br/>
 for (let i = 1; i &lt; this.length; i++) {<br/>
   if (this[i] &gt;= this[0]) rightArr.push(this[i])<br/>
   if (this[i] &lt; this[0]) leftArr.push(this[i])<br/>
 }<br/>
 return [...leftArr.quickSort(), this[0], ...rightArr.quickSort()]<br/>
}
</code></pre></li>
<li><p>描述一下多层级的分类目录，如何组装数据结构</p></li>
<li><p>描述一下大数相乘</p>
<pre><code class="language-javascript">// 没有让写，电话面试的让我描述一下
// 大数相加相乘还是比较有意义的，这里我写一下吧<br/>
/**<br/>
 * 大数相乘<br/>
 * @param {String} a 数字字符<br/>
 * @param {String} b 数字字符<br/>
 */<br/>
const pow = (a, b) =&gt; {<br/>
  if (a === &#39;0&#39; || b === &#39;0&#39;) return &#39;0&#39;<br/>
  // a和b相乘的结果c，c的位数 &lt;= a和b位数的和<br/>
  // 初始化一个数组能装下最大的 a * b 的结果<br/>
  let res = new Array(a.length + b.length).fill(0)<br/>
  // 模拟末尾开始相乘<br/>
  for (let i = a.length - 1; i &gt;= 0; i--) {<br/>
    for (let j = b.length - 1; j &gt;= 0; j--) {<br/>
      const sum = parseInt(a[i]) * parseInt(b[j]) + res[i + j + 1]<br/>
      res[i + j + 1] = sum % 10<br/>
      res[i + j] += Math.floor(sum / 10)<br/>
    }<br/>
  }<br/>
  // 注意初始化的数组，第一位有可能是用不上的<br/>
  return res[0] === 0 ? res.slice(1, res.length).join(&#39;&#39;) : res.join(&#39;&#39;)<br/>
}
</code></pre></li>
<li><p>其他不太记得了，总体来说比较基础</p>
<blockquote>
<p>没有问原理和源码相关的东西，算法也不难，不需要手写，讲思路即可</p>
</blockquote></li>
</ol>

<h2 id="toc_19">富途面经</h2>

<h4 id="toc_20">面试进度：3 面，不太喜欢就拒了后面的邀约</h4>

<h4 id="toc_21">面试难度：⭐️⭐️⭐️</h4>

<h4 id="toc_22">面试风格：少量项目 + 部分算法 + 部分逻辑题</h4>

<h4 id="toc_23">过程介绍：</h4>

<p>富途是猎头还是什么平台帮我自动投递的，是一个做内部支撑的部门。<strong>3 轮技术面，1 轮 hr 面</strong>。我不知道是不是因为猎头推的原因，约面非常敷衍，联系方式也不留，也就一个座机号，没接到电话打回去也找不到人。然后隔了一周多，才第二次联系。而且必须是现场面试，必须是工作日，必须是白天。一面面试官还是挺友好的，但二面面试官有点高冷和不耐烦。</p>

<p><strong>面试风格比较独特，喜欢考逻辑题和智力题</strong>，也会问一些应用题和场景设计。一面前要做个笔试，网上的题目，原题一摸一样那种。如果某题有多种解法，面试官会不断问新的解题思路以及一直引导你，直到答到他自己想听的那个答案。整个过程很慢，基本上一个半小时以上。</p>

<h4 id="toc_24">面试题：</h4>

<ol>
<li><p>CSS 实现左右布局，左边定宽，右边自适应</p>
<blockquote>
<p><code>flexbox</code></p>
</blockquote></li>
<li><p>斐波那契数列求第 n 个数，要做优化版的</p>
<pre><code class="language-javascript">// 动态规划，对象缓存，闭包缓存都行，这里写个动态规划吧
/**<br/>
* 动态规划斐波那契，其实和 leetcode 70题爬楼梯是一样的<br/>
* @param {Number} n 要求的数<br/>
*/<br/>
const fib = function (n) {<br/>
 let dp = [1, 1]<br/>
 for (let i = 2; i &lt; n + 1; i++) {<br/>
   dp[i] = dp[i - 1] + dp[i - 2]<br/>
 }<br/>
 return dp[n]<br/>
}
</code></pre></li>
<li><p>括号匹配</p>
<pre><code class="language-javascript">// leetcode 20题，用栈，比较简单
/**<br/>
* 括号匹配<br/>
* @param {String} s 输入的字符串<br/>
*/<br/>
const isValid = (s) =&gt; {<br/>
 let map = {<br/>
   &#39;(&#39;: 1,<br/>
   &#39;)&#39;: -1,<br/>
   &#39;{&#39;: 2,<br/>
   &#39;}&#39;: -2,<br/>
   &#39;[&#39;: 3,<br/>
   &#39;]&#39;: -3,<br/>
 }<br/>
 let stack = []<br/>
 for (let i in s) {<br/>
   if (map[s[i]] &gt; 0) {<br/>
     stack.push(s[i])<br/>
   } else {<br/>
     const target = stack.pop()<br/>
     if (map[target] + map[s[i]] !== 0) return false<br/>
   }<br/>
 }<br/>
 if (stack.length &gt; 0) return false<br/>
 return true<br/>
}
</code></pre></li>
<li><p>加载页面有哪些性能优化的方案</p>
<blockquote>
<p>这问题和 “输入 url 发生了什么” 这问题类似，简单介绍 5 分钟能讲完，要扯皮的讲半天也可以讲...</p>
<p>常规的：图片懒加载，预加载，雪碧图，路由按需加载，gzip ......</p>
<p>网络的：http2，强缓存，协商缓存，合并请求资源（http2 就不用合了）......</p>
<p>其他：service worker ......</p>
</blockquote></li>
<li><p>一个无序数组，找出比他左边都大，比他右边都小的元素，要求时间复杂度 On</p>
<blockquote>
<p>没让我写，让我说说思路</p>
<p>时间复杂度 On 的话，不嵌套循环就好了</p>
<ol>
<li>第一遍遍历从头开始，用一个新数组 max 存每一个遍历元素它左边的最大值</li>
<li>第二遍遍历从尾开始，用一个新数组 min 存每一个遍历元素它右边的最小值</li>
<li>第三遍遍历，当前元素和 max，min 两个数组对应下标的值比较，找到满足条件的</li>
</ol>
<p>例：当前元素下标 3，值是 5。<code>max[3]</code> 是 4，<code>min[3]</code>是 8，那当前元素就符合条件（ <code>5 &gt; 4 &amp;&amp; 5 &lt; 8</code> ）</p>
<p>这样时间复杂度是 3 * On，舍弃常数也就是 On</p>
</blockquote></li>
<li><p>逻辑题，称重</p>
<blockquote>
<p>10 瓶药，每瓶 100 片，其中 9 瓶是 10g/片，1 瓶 9g/片，问只称重一次，怎么找出轻的那瓶药</p>
<p>讲道理这题我想了好一会...最不喜欢面试做这类题</p>
<p>第一瓶拿 1 片，第二瓶拿 2 片，以此类推</p>
<p>如果都是 10g，那么一共是 <code>(1 + ... + 10) * 10 = 55</code> 克。但是实际上会少几克，因为有一瓶每片药是 9g 的。如果称的是 53g，那么意味着有 2 片药是 9g 的，那就是第二瓶药是有问题的（因为第二瓶药我们拿出了两片）同理如果 52g，那就是 3 片药有问题，那瓶药是第三瓶药</p>
<p>面试官后面还追加了一问，如果是两瓶有问题的，又该如何称重，上面的方法可行吗？答案是不可行，原因留给大家想吧，tips 就是上面是等差取药片，需要改成等比取</p>
</blockquote></li>
<li><p>设计一个抽奖程序</p>
<blockquote>
<p>开放题没啥好说的，就问了一下接口如何设计，然后有什么注意的事项。还有描述抽奖函数的实现</p>
</blockquote></li>
<li><p>其他</p>
<blockquote>
<p>这两题网上是有原题的，面完还搜了一下。然后还有些不记得了</p>
<ol>
<li><p>读 C++ 代码写结果，计算个人所得税的函数</p></li>
<li><p>Room 和 User 两个类，现在有个关门的方法，放到哪个类中</p></li>
</ol>
</blockquote></li>
</ol>

<h2 id="toc_25">转转面经</h2>

<h4 id="toc_26">面试进度：offer</h4>

<h4 id="toc_27">面试难度：⭐️⭐️</h4>

<h4 id="toc_28">面试风格：常规问题 + 一点算法</h4>

<h4 id="toc_29">过程介绍：</h4>

<p>转转面的深圳这边的团队，<strong>3 轮技术面，1 轮 hr 面</strong>。面试效率很高，基本上一天一面，一周完事。</p>

<p><strong>问的大多是常规问题，问的不深，但是涉及的基础面比较广</strong>。面试是北京那边的前端团队远程视频面。会涉及到一些计算机网络，数据结构等计算机基础，但是问的都比较浅。印象比较深刻的是 3 面的前端 leader，思维很广，看问题的角度明显就不太一样。后来了解到之前好像是百度文库的负责人。整个转转很多是百度出来的人。</p>

<h4 id="toc_30">面试题：</h4>

<ol>
<li><p>Vue 双向绑定原理</p>
<blockquote>
<p>基本是必问的，Vue 相关问题参考鹅厂面经吧，鹅厂挖的很深了</p>
</blockquote></li>
<li><p>Vue 生命周期</p></li>
<li><p>Vue nexttick 原理</p>
<blockquote>
<p>Vue 双向绑定的 Watcher 源码中有这么一句 <code>queueWatcher(this)</code>，而这玩意内又有这么一句 <code>nextTick(flushSchedulerQueue)</code>。这个 flushSchedulerQueue 其实就是更新视图的函数。</p>
<p>抽象概括一下 nextTick 的原理：</p>
<ol>
<li><p><code>nextTick</code> 接收一个回调，返回一个闭包</p></li>
<li><p>回调的执行时机 <code>nextTick</code> 闭包中的 <code>timerFunc</code> 控制</p>
<pre><code class="language-text">timerFunc 用以下优先级来处理出队时机
setImmediate -&gt; MessageChannel -&gt; Promise -&gt; setTimeout<br/>
优先使用宏任务，如果不支持就使用 Promise 的微任务，如果还不支持就用 setTimeout 兼容。虽然setTimeout 是宏任务，但是在 http 声明中 setTimeout 有 4ms 的延时，所以只拿来做兼容处理，宏任务交给 setImmediate 和 MessageChannel
</code></pre></li>
</ol>
<p>也就是说用于更新视图的 <code>nextTick(flushSchedulerQueue)</code> 其实以 <code>setImmediate -&gt; MessageChannel -&gt; Promise -&gt; setTimeout</code> 优先级塞入了 Event loop 中</p>
<p>这样更新的好处是：</p>
<p>假设有个值 <code>test</code> 被 while 循环执行 1000 次++操作。每次循环时，都会根据响应式触发 <code>compile -&gt; setter -&gt; Dep -&gt; Watcher -&gt; update -&gt; run</code> 如果没有异步更新，而是每次都更新 DOM，那会十分消耗性能。所以 Vue 实现了一个 <code>queue</code> 队列，先把所有的 <code>Watcher</code> 塞到队列里。在下一个 tick（或者是当前 tick 的微任务阶段）的时候会统一执行 <code>queue</code> 中 Watcher 的 <code>run()</code>，<strong>也就是这 1000 次++操作，其实 Vue 只处理了 0 -&gt; 1000 这一次操作</strong></p>
<p>总结：</p>
<p><strong>第一阶段：queueWatcher(this) 收集 watcher 队列</strong></p>
<ol>
<li>响应式触发 update，把 watcher 塞到 queue 队列，并且根据 watcher.id 去重</li>
</ol>
<p><strong>第二阶段：nextTick(flushSchedulerQueue) 更新视图</strong></p>
<ol>
<li><code>nextTick</code> 会返回一个闭包，通过 <code>timerFunc</code> 执行 <code>flushSchedulerQueue</code> 回调</li>
<li><code>flushSchedulerQueue</code> 执行 watcher 的 run，更新视图</li>
</ol>
</blockquote></li>
<li><p>基础数据类型和引用数据类型差别</p></li>
<li><p>堆和栈的差别</p></li>
<li><p>深拷贝和浅拷贝有什么不同，怎么实现深拷贝</p>
<blockquote>
<p>深拷贝就是递归的浅拷贝</p>
</blockquote></li>
<li><p>什么是 options 请求</p>
<blockquote>
<p>参考字节面经 No.11</p>
</blockquote></li>
<li><p>H5 适配原理，px2rem 是怎么适配的</p>
<blockquote>
<p>rem 就是 html 标签上 <code>font-zise</code> 的值，只要让这个值跟随屏幕自适应就好了。那自然是和 vw 挂钩啦。然后还有配置 <code>meta</code> 标签，还有换算系数和几个视窗概念等，感兴趣的可以查一下，这里不废话了</p>
</blockquote></li>
<li><p>什么是 BFC</p>
<blockquote>
<p>MDN 走起</p>
</blockquote></li>
<li><p>commonjs 和 esmodule 有什么区别</p>
<blockquote>
<ol>
<li>CommonJS 是被加载的时候运行，ES6 模块化是编译的时候确定依赖，也就是说重复引入同一个模块，也只会执行一次代码。<code>tree sharking</code> 原理就是 ES6 模块依赖是编译时确定的。</li>
<li>CommonJS 输出的是值的浅拷贝，并且写到内存中。ES6 模块化输出值的引用</li>
<li>CommonJS 支持动态导入，也就是 require(${path}/xx.js)</li>
<li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
</ol>
</blockquote></li>
<li><p>webpack 构建后的输出，是基于什么模块协议的</p>
<blockquote>
<p>目前浏览器端 js 模块化大概两类，一类是 CMD 就近依赖，一类是 AMD 提前依赖</p>
<p>所谓就近依赖就是，用到的时候再声明加载依赖。提前依赖就是事先声明好依赖关系</p>
<pre><code class="language-javascript">/** AMD写法 **/
define([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;], function (a, b, c, d, e, f) {<br/>
  // 等于在最前面声明并初始化了要用到的所有模块<br/>
  a.doSomething()<br/>
  if (false) {<br/>
    // 即便没用到某个模块 b，但 b 还是提前执行了<br/>
    b.doSomething()<br/>
  }<br/>
})<br/>
/** CMD写法 **/<br/>
define(function (require, exports, module) {<br/>
  var a = require(&#39;./a&#39;) //在需要时申明<br/>
  a.doSomething()<br/>
  if (false) {<br/>
    var b = require(&#39;./b&#39;)<br/>
    b.doSomething()<br/>
  }<br/>
})
</code></pre>
<p>而 webpack 打包后会变成 key，value 的形式的键值对，key 是路径，value 是模块的闭包函数。没仔细看构建源码，猜测是基于 CMD 协议的，也就是就近依赖。因为这才比较符合按需加载的逻辑</p>
</blockquote></li>
<li><p>介绍浏览器事件循环和 node 事件循环</p>
<blockquote>
<p>关于事件循环，作为前端开发者肯定都了解过。但是真的往深了去问又会发现很多人其实理解的模模糊糊，不太确定的样子。我简单说说我的理解。</p>
<p>浏览器端：</p>
<p><strong>浏览器端事件循环两个关键就是宏任务和微任务两个老哥</strong>。每一轮事件循环只会在宏任务队列里出队一个宏任务并且执行，然后清空整个微任务队列。都完事后就结束这轮的事件循环，再搞一个宏任务出来并且清空微任务队列，循环往复。</p>
<pre><code class="language-text">常见的宏任务有，同步的代码，setTimeout，setInterval，requestAnimationFrame，以及 node 中的 setImmediate 等
常见的微任务有，promise，await async 等。node 中有个 process.nextTick 比较特殊，后面说
</code></pre>
<p>node 端：</p>
<p><strong>node 端每一轮循环都有下面几个阶段</strong></p>
<ol>
<li><p><code>timers</code> ，首先是执行定时器，如果在当前循环种存在 setTimeout / setInterval 之类的定时器，将在这时候处理</p></li>
<li><p><code>pending callbacks</code>，这个阶段也称为 I/O callbacks 阶段，主要是执行一些从上个循环延迟过来的 I/O 回调</p></li>
<li><p><code>idle</code>，<code>prepare</code>，node 内部机制</p></li>
<li><p><code>poll</code>，轮询，在这里检索新的 I/O 事件;执行与 I/O 相关的回调，其余情况 node 将在适当的时候在此阻塞，直到达到最快的一个计时器阈值为止（比如 setTimeout 100ms，那如果这时候没事做，那他就等这个 setTimeout 100ms）</p></li>
<li><p><code>check</code>，执行 setImmediate 的回调</p></li>
<li><p><code>close callbacks</code>，关闭当前循环</p></li>
</ol>
<p>另外还有个 <code>process.nextTick</code> 这玩意，它并不属于宏任务也不属于微任务，他是进入当前循环阶段的时候，最优先执行的那个。并且 node 循环的每个阶段这老哥都能执行。建议网上找些实际的例子看看，光看描述其实理解起来比较抽象</p>
<p>最后补充：</p>
<p><strong>其实 js 的异步并不是它自己玩的</strong>。拿浏览器来说，一个 tab 渲染进程包含了好几个线程：</p>
<ol>
<li>渲染线程，与 js 线程互斥</li>
<li>js 线程，与渲染线程互斥</li>
<li>事件处理线程，收集异步回调，触发时塞到 js 线程的处理队列</li>
<li>定时器线程，类似事件处理线程，触发时将定时器塞到 js 线程的处理队列</li>
<li>异步 http 线程，当 ajax 状态发生改变时，就把回调塞到 js 线程的处理队列</li>
</ol>
<p>也就是说所谓异步事件，<code>setTImeout</code> 也好 <code>promise</code> 也好，其实不是 js 的主线程自己搞的，他只是遇到这些操作的时候交给对应的异步处理线程，他们搞定了再回过头推进宏任务 / 微任务队列。<strong>而 js 线程的主要工作只是不断事件循环，检查任务队列</strong>，有东西执行他就执行。node 中也是类似的，只不过服务端可调度的线程资源池就交给了 C++ 大哥的 libuv 库。有时间我再写一篇关于 js 主线相关的东西，讲讲浏览器那几个线程以及异步怎么处理，还有 node 关于线程池的分配等。了解一些底层的原理，被问到 js 单线程之类的就不虚了</p>
</blockquote></li>
<li><p>什么是强缓存，什么是协商缓存</p>
<blockquote>
<p>缓存也是被问到烂的问题了，所谓强缓存就是本地缓存，状态码是 200。协商缓存就是到服务器协商过后看要不要用缓存结果，状态码是 304。</p>
<pre><code class="language-text">强缓存有 exprie 和 cache-control 两种缓存形式
前者是绝对时间缓存，受客户端时间影响；后者是相对时间<br/>
协商缓存有 If-None-Match 和 If-Modified-Since 两种形式<br/>
前者是 Etag 判断资源 hash 是否变更，后者是时间维度的对比<br/>
细节可以查查资料，这里不过多介绍
</code></pre>
<p>顺便补充一下常见缓存的优先级</p>
<ol>
<li>强缓存</li>
<li>sw 缓存的 App Cache</li>
<li>协商缓存</li>
<li>http2 的 server push</li>
</ol>
</blockquote></li>
<li><p>async / await 和 promise 有什么区别</p>
<blockquote>
<p>是不是想答 <code>async / await 是同步的写法实现异步的能力，代码更简洁易读</code></p>
<p>那要是面试官追问实现方式甚至问性能优势呢？</p>
<p>关于 async / await 我再补充点吧</p>
<p>首先是总所周知系列：</p>
<ol>
<li><p>async / await 是同步的写法</p></li>
<li><p>try...catch... 捕获异常</p></li>
<li><p>是 <code>generator</code> 的语法糖</p></li>
</ol>
<p>关于性能，我主要想说说第三点。</p>
<p>关于 <code>generator</code> 和 <code>iterator</code> 的关系我就不多说了，我主要说说这玩意是怎么实现<strong>暂停代码</strong>的效果的。首先要明确一点就是 <code>generator</code> 本质上也是一个函数，当他执行的时候，一样会被 js 引擎推到函数执行栈中。但是他和正常函数有一个不同：</p>
<p><strong>正常函数执行完，就从栈顶弹出然后就销毁。但是 <code>generator</code> 不一样，这玩意执行完之后返回了一个 <code>iterator</code> 迭代器，这个迭代器保存着 <code>generator</code> 的引用</strong></p>
<p>这是关键，大家想想闭包和内存泄漏，不就是因为某个地方还保存着变量的引用么？是的，这迭代器的存在导致这个生成器函数并不会被销毁，哪怕它被执行栈弹出了。<strong>当再执行迭代器 <code>iterator</code> 的时候，又回通过指针找到这个生成器 <code>generator</code>，把它推进栈顶并且执行直到遇到 <code>yield</code>，然后再弹出生成器，并且返回一个包含 <code>value</code> 和 <code>next</code> 指针的对象。</strong></p>
<p>言归正传，async / await 既然是语法糖，那它背后原理就如上所述。那和性能有毛线关系呢？大家再想想 <code>promise</code>，<code>promise</code> 是需要在 <code>then</code> 的时候收集依赖并且 <code>push</code> 到 <code>_resolveQueue</code> 和 <code>_rejectQueue</code> 两个队列中存起来的，然后当 <code>resolve</code> 或者 <code>reject</code> 的时候去遍历对应的执行队列，执行回调。<strong>也就是说 <code>promise</code> 是需要保存和维护函数执行依赖的</strong>，对于 <code>promise</code> 链式调用来说，所有的 <code>then</code> 依赖关系都要保存。而基于迭代器的 async / await 就不需要保存一堆依赖</p>
</blockquote></li>
<li><p>for in 和 for of 有什么区别，可以 for of 对象吗</p>
<blockquote>
<ol>
<li><p>foreach 是遍历数组的，但是它不可中断，return 不了</p></li>
<li><p>for in 是遍历对象的，但是也可以遍历数组（毕竟也是 object）。但是 for in 遍历数组的时候 index 会当成 key 来处理，此时 index 是 string 类型而不是 number 类型。另外会把数组的属性给遍历出来。比如 <code>arr.name</code></p></li>
<li><p>for of 是遍历可迭代对象的，比如数组，迭代器等。它没有下标，数组的话直接把元素遍历出来，但是不包括数组上的方法。</p></li>
<li><p>一般对象并没有可迭代的属性 <code>iterator</code>，正常情况下是不能 for of 对象的。不过可以手动给对象绑上迭代属性，就可以 for of 对象了</p></li>
</ol>
<pre><code class="language-javascript">const iteratorObj = (obj) =&gt; {
  obj[Symbol.iterator] = function* () {<br/>
    // 关键在于需要返回一个迭代器，就是 yield 返回的那个中间对象 { done, value }<br/>
    // generator 就是拿来生成迭代器的，所以直接用 genFn<br/>
    let keys = Object.keys(this)<br/>
    for (let i = 0; i &lt; keys.length; i++) {<br/>
      yield this[keys[i]]<br/>
    }<br/>
  }<br/>
}
</code></pre>
</blockquote></li>
<li><p>webpack 的 loader 和 plugin 有什么区别</p>
<blockquote>
<p>loader 可以理解成翻译器，遇到不同类型的文件，翻译成 js 能理解的语言。比如遇到 css 就用 <code>css-loader</code> 翻译器，比如遇到图片就用 <code>file-loader</code> 翻译器等。</p>
<p>plugin 是在 webpack 不同生命周期中做一些特定的事情，来扩充 webpack 能力的。比如构建之前清空 output 目录，比如构建完成后移动文件等。</p>
</blockquote></li>
<li><p>无重复最长子串</p>
<pre><code class="language-javascript">// leetcode 3题
// 思路是用 map 做移动窗口的匹配<br/>
/**<br/>
 * 找出无重复字符的最长子串<br/>
 * @param {string} s 字符串<br/>
 */<br/>
const lengthOfLongestSubstring = (s) =&gt; {<br/>
  let map = new Map()<br/>
  let startIndex = -1<br/>
  let max = 0<br/>
  for (let i in s) {<br/>
    if (map.has(s[i])) startIndex = Math.max(map.get(s[i]), startIndex)<br/>
    max = Math.max(max, i - startIndex)<br/>
    map.set(s[i], i)<br/>
  }<br/>
  return max<br/>
}
</code></pre></li>
<li><p>括号匹配</p>
<blockquote>
<p>参考富途面经 No.3</p>
</blockquote></li>
</ol>

<h2 id="toc_31">总结</h2>

<h4 id="toc_32">复习策略：</h4>

<ol>
<li><p><strong>系统复习前端基础。</strong>如果你的方向不侧重于样式重构，<code>html</code> 和 <code>css</code> 大致了解有个概念即可。至于 <code>js</code> 则需要重点复习。另外平时也建议找一本权威的书好好啃一下，比如红皮书，js 精粹，js 忍者秘籍，函数式编程等等，有空读读书也是挺好的。</p>
<blockquote>
<p>事实上工作过程中 html 和 css 的积累已经足够应付面试了。而 js 因为是整个前端编译语言的基础，加之这玩意诞生之初到发展到今天，作为一个弱类型的语言其实有很多性能上或者奇奇怪怪的问题，这些问题如果不深入系统复习，其实是很难去理解和解释它的。比如 this 是啥，箭头函数是啥，数组又有哪些高阶用法，异步又是什么原理，闭包又是个啥玩意等等...</p>
</blockquote></li>
<li><p><strong>深入了解某一个前端框架的源码。</strong>现在前端面试者这么多，在业务层和应用层多多少少都会用一些框架。那大厂要筛更好的人怎么筛？那就只能深挖一些原理去考核。所以大厂面试源码基本是必问的。但是这些东西一般是触类旁通，无非是要熟知框架的设计理念，核心方法，表层 API 背后的原理等。</p>
<blockquote>
<p>如果觉得啃源码太累，也能找找别人整理好的资料，甚至买些源码解读的视频也可以</p>
</blockquote></li>
<li><p><strong>算法</strong>。如果你看完了这些面经，我想你也发现了基本所有厂都有问算法。这次面试下来各种各样的面试风格都遇到过，但无论哪一种风格的面试都好，算法可以说是必考的。算法的复习是急不来的，肯定是日积月累的。我的建议是每天有空刷一下题，给自己定一个目标。</p>
<blockquote>
<p>如果要学习算法。最好是积累性质的复习，可以找找大牛总结的常见的算法类型或者买本书，先归类再系统学习。比如针对数据结构的算法，或者针对递归的，针对动态规划的等等。但是如果是要突击复习的话，<strong>最有效的方法还是刷 leetcode</strong>，因为基本上所有算法面试题都是上面找的。</p>
</blockquote></li>
<li><p><strong>牢记计算机基础</strong>。计算机网络，数据结构的基础知识我个人认为是必须熟练掌握的。其中重中之重我认为是计算机网络。作为一个前端，前后端交互是绝对少不了的。那怎么交互？大部分情况还是网络上的交互。所以整个网络模型，从应用层的 <code>http1,2,3</code>，<code>websocket</code> 开始，到传输和应用夹层的 <code>TLS</code> 安全，到传输层的 <code>TCP</code> 和 <code>UDP</code>，都是很重要的知识点。数据结构的数组，队列，栈，链表，树，字典，图等也是必须掌握。</p>
<blockquote>
<p>操作系统看个人方向，前端涉及到的不多，如果想做底层架构或者 IOT 之类路线的可以重视一下</p>
</blockquote></li>
<li><p><strong>找面经和真题</strong>。针对面试而言，临时抱佛脚其实还是很有用的。因为在同一时间段内大部分公司其实面试题都八九不离十。遇到原题或者同类型题的概率还是很大的。但是大厂就不一定了，大厂部门多，面试官多，题库资源雄厚，想靠背真题去通关几乎是不现实的。</p></li>
</ol>

<h4 id="toc_33">个人规划：</h4>

<p>职业规划其实因人而异了，但是在个人能力提升上我是这么看的：<strong>无论做什么事情，没有目标，没有合理的规划，其实是很难成长的。</strong>有目标才能督促自己去做点什么。那从技术规划上，可以考虑全栈的发展，或者专注前端领域跨平台的发展，亦或者对 SDK 或框架设计能力的提升等等。</p>

<blockquote>
<p><strong>需要有扩展性视野</strong>。也就是多了解上下游的技术栈以及前沿技术信息。平时多看多关注优质社区文章和开源项目，去慢慢积累与巩固自己的知识面。</p>

<p>技术深度上比如大前端，node，v8，ts，或者某个感兴趣的领域的深入研究。</p>

<p>技术广度上比如 CI / CD，Docker，Flutter / Electron 等混合开发，微前端，serverless 的应用场景等。</p>
</blockquote>

<p>从软实力上更多是培养自己的一些好习惯，比如习惯性的读书，周期性的发表文章，甚至极客一点的搞搞乱七八糟的服务器部署些有实质意义的应用，或者开源一些个人框架等等。</p>

<p><strong>最后就是一定要保持学习的态度。</strong></p>

<p>By <a href="">@Evan</a><br/>
2020.09.18</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大前端相关面试题]]></title>
    <link href="https://evanoyam.github.io/16023387735398.html"/>
    <updated>2020-10-10T22:06:13+08:00</updated>
    <id>https://evanoyam.github.io/16023387735398.html</id>
    <content type="html"><![CDATA[
<p>其他类型的常见面试题：</p>

<ul>
<li><a href="16023387379097.html">常见 HTML 和 CSS 面试题</a></li>
<li><a href="16021877148099.html">常见 JS 面试题</a></li>
<li><a href="16021784313262.html">常见 Vue 面试题</a></li>
<li><a href="16023383568771.html">常见性能相关面试题</a></li>
<li><a href="16023387735398.html">常见大前端相关面试题</a></li>
</ul>

<p>近两年大前端相关的话题越来越多。所谓大前端，我的理解是<strong>对前端工程师知识体系中广度的考核</strong>。尤其是 node 诞生之后，JS 能干的东西越来越多，简单的如写个页面，复杂的甚至有 <code>NodeOS</code> 这种操作系统的玩意。</p>

<p>如果你想进大厂或者一些比较好的独角兽公司，只会敲一个页面是远远不够的。</p>

<ul>
<li>你可能需要掌握 Node 的知识，不一定是写后端，也有可能需要 ssr 同构，或者自定义打包工具，亦或者是写个 BFF</li>
<li>你可能需要掌握一些运维的知识，比如会一些 Linux 的命令和一些如 Docker 等部署的知识</li>
<li>你可能需要掌握一些数据结构和面向对象的编程习惯，或许你需要封装一些库或者 SDK</li>
<li>你可能需要对整个前端体系有一定的了解，以便在性能和工程化上能有一些操作</li>
<li>你可能需要......</li>
</ul>

<h4 id="toc_0">1. 什么是MVC</h4>

<p>MVC是 <code>Model-View-Controller</code> 的简称</p>

<ol>
<li>Model 是模型，是数据</li>
<li>View 是视图</li>
<li>Controller 是控制器</li>
</ol>

<p>Controller 承接 View 和 Model，MVC 模型中通信是单向的，Controller 需要处理 Model 的业务变更，然后通知 View 你要如何去更新视图，Controller 容易变得过于庞大和臃肿</p>

<h4 id="toc_1">2. 什么是MVVM</h4>

<p>MVVM是 <code>Model-View-ViewModel</code> 的简称</p>

<ol>
<li>Model 是模型，是数据</li>
<li>View 是视图</li>
<li>ViewModel 代替了 Controller，最大的特点就是双向通信，不像 Controller 需要通知 View 和 Model 并且做业务逻辑。ViewModel 只需要通知 View 和 Model 彼此发生更改就行了</li>
</ol>

<blockquote>
<p>比如 Vue 中，View 就是 <code>template</code>，Model 就是 <code>Vuex</code>，而 ViewModel 就是 <code>Vue</code>实例。当 View 接收到不同的用户交互的时候，Vue 实例告知 Vuex 如何修改 state；当Vuex 中的 state 变了的时候，Vue 实例修改虚拟 dom 然后让 template 发生变更更改视图</p>
</blockquote>

<h4 id="toc_2">3. webpack tree shaking原理，是靠什么才能实现</h4>

<p>tree shaking就是在打包过程中，把一些引入的依赖中又没用到的函数给去除掉，以减少打包的体积</p>

<p>tree shaking的消除原理是依赖于ES6的模块特性。</p>

<p>ES6 module有几个特性: </p>

<ol>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量</li>
<li>import binding 是 immutable的</li>
</ol>

<p>和CommonJS不同，ES6是在解释阶段就确定依赖关系的，和运行时的状态无关，所以可以进行可靠的静态分析</p>

<p>分析过后就能精简代码，删掉如下代码：</p>

<ol>
<li>代码不会被执行，不可到达</li>
<li>代码执行的结果不会被用到</li>
<li>代码只会影响死变量（只写不读）</li>
</ol>

<h4 id="toc_3">4. webpack的构建原理，webpack的loader和plugin的区别</h4>

<p>webpack构建主要有以下几步</p>

<ol>
<li>webpack.config.js结合命令行的参数，解析entry的入口文件</li>
<li>得到entry的ast树之后，遍历ast树，确定依赖</li>
<li>将ast解析成es5，并且递归解析所有依赖</li>
</ol>

<p>Webpack是一种打包工具，它能将各种文件，按分类、逻辑打包，整合进一个或多个bundle.js之中。</p>

<p>loader简单来说就是翻译器，讲特定的文件按照特定的解释方式加载，打包</p>

<p>plugin简单来说就是在webpack打包的过程中，特定的时间节点做一些事情，已达到扩展webpack能力的目的。比如在打包前，把文件统一放到某个目录，或者打包后做一些什么操作之类的</p>

<h4 id="toc_4">5. 什么是进程，什么是线程</h4>

<p>进程是资源分配的最小单位，线程是CPU调度的最小单位，进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同</p>

<p>进程能独立拥有分配给自己的资源，而线程是进程的基础上的一次程序运行的单位</p>

<ol>
<li>一个程序可以开启多个进程，比如浏览器一个tab就是一个进程，同时还有主进程，GPU进程等</li>
<li>一个进程可以有多个线程，比如一个tab有UI线程，有JS线程</li>
<li>所谓的单线程就是一个任务只能有一个线程在跑，多线程就是一个任务可以细分多个部分同时跑</li>
</ol>

<h4 id="toc_5">6. 什么是并发，什么是并行</h4>

<ol>
<li><p>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</p></li>
<li><p>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</p></li>
</ol>

<h4 id="toc_6">7. Performance API和常见的性能监控数据</h4>

<p>浏览器提供一个 <code>window.performance.timing</code> 的api，用来提供一些特殊时间点的时间戳，用来追踪性能，包括dns，tcp/ip，首包响应时间，dom解析时间等</p>

<h4 id="toc_7">8. 谈下对serverless架构的理解</h4>

<p>顾名思义，serverless架构即无服务架构。它的核心思想是FaaS，函数即服务。意思是服务器资源是根据函数访问量来重新分配再收费的。</p>

<blockquote>
<p>比如有一个500pv的博客项目，如果部署在一台服务器上，可能大多数时间是没人访问的，资源就白白浪费了。而serverless就是当有人访问的时候启动服务，开始计费。没人访问就停掉服务。</p>
</blockquote>

<p>传统的云服务的部署流程是这样的：</p>

<blockquote>
<ol>
<li>本地开发，构建包或者docker</li>
<li>推送到云服务器，服务器部署</li>
</ol>
</blockquote>

<p>serverless就不需要，直接推送到服务器，有人访问就访问最新代码，没人访问就停用服务。</p>

<p>serverless有优点也有缺点。优点是部署方便，按需分配资源，而且一般的服务商也会提供服务器的配套服务，比如各类数据库，想用什么就用什么，按需付费即可</p>

<p>缺点是serverless有一定的冷启动时间。因为它是FaaS的，没人用就停用，那有人访问的时候就需要一个启动时间。AWS提供的serverless宣称的时间能在50ms内，不过实际情况要考虑到网络波动等等，有一定的性能损耗。而且这是node作为服务的情况下，如果是java这种依赖虚拟机的就更蛋疼了。此外serverless几乎是和厂商绑定的，你用了谁家的serverless服务，也就依赖了谁家的底层数据，配套设施服务（毕竟都是同一台机器，或者说同一个厂商的集群）当要迁移的时候就会有麻烦。对于试水小应用，博客，或者初创企业来说，serverless很方便，但是对一个大型应用和完善的服务而言，serverless也有可能让扩容迁移变得麻烦。</p>

<h4 id="toc_8"><a href="https://juejin.im/post/5ad3f1156fb9a028b86e78be">9. 谈谈v8的垃圾回收机制</a></h4>

<p>v8引擎根据内存占用时间，将垃圾回收有两种：新生代回收和老生代回收</p>

<blockquote>
<ul>
<li>新生代管理短时间占用内存空间的引用，老生代管理长时间占用内存空间的引用</li>
<li>默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。</li>
</ul>
</blockquote>

<p>新生代的垃圾回收有两个空间，第一个是FROM空间（被使用），第二个是TO空间（空闲）。当垃圾回收机制进来看什么内存空间没有引用的时候，把没有引用的空间打上标记，然后把其他引用移动到空闲的TO空间中，然后清空FROM空间。这时候FROM空间和TO空间互换。当下一轮垃圾回收进来，也是如此，然后互换空间</p>

<p>老生代只有一个空间，每次垃圾回收进来就标记上已经没引用的内存空间，然后删掉。但是这样有个问题就是被删掉的空间可能是碎片状的，会存在浪费。于是多了一个步骤，先把还有用的内存空间移动到一边，然后把剩余的全部干掉。</p>

<p>也就是说，新生代只复制活着的对象，而老生代只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p>

<h4 id="toc_9">10. 说说rollup和webpack的异同和优缺点</h4>

<p>rollup的特点</p>

<ol>
<li>更适合构建 lib</li>
<li>默认采用 esm</li>
<li>打包的体积更小</li>
</ol>

<p>一般打包库用rollup，因为他简单易用，打包体积小。打包应用用webpack，因为webpack功能齐全，调试方便，社区生态健全</p>

<h4 id="toc_10">11. webpack 的 import 打包后变成什么，基于什么协议，如何加载</h4>

<p>打包后会变成key value的形式，key是路径，value是模块的闭包函数</p>

<p>基于CMD协议的，也就是就近依赖</p>

<blockquote>
<p>cmd是就近依赖，amd是提前依赖</p>
</blockquote>

<h4 id="toc_11">12. v8的排序算法是怎么实现的</h4>

<p>旧版本的v8引擎的sort是采用插入和快排的。</p>

<blockquote>
<ul>
<li>对于长度小于 10 的数组采用插入排序</li>
<li>长度大于 10 的数组采用快排</li>
</ul>
</blockquote>

<p>新版本之后采用了一种混合排序</p>

<blockquote>
<ul>
<li>首先根据当前的数组总大小，计算出一个最小子数组长度minArrLen</li>
<li>然后在数组中找到一个已经排好序的子序列，如1,17,36,8那子序列为 <code>[1,17,36]</code></li>
<li>然后对子序列执行插入排序，填充到minArrLen的长度</li>
<li>重复执行找出子序列的操作，整个数组变成若干个已经排序好的子序列</li>
<li>对这堆子序列执行归并排序</li>
</ul>
</blockquote>

<h4 id="toc_12">13. webpack中hash，chunk hash，content hash有什么区别</h4>

<p>无论是什么hash，只要开启了hash，通过webpack构建之后，生成对应文件名自动带上对应的MD5值</p>

<ol>
<li>hash</li>
</ol>

<p>hash的维度是整个webpack构建过程。在同一次构建中，所有的文件用的都是同一个hash。</p>

<blockquote>
<p>只要有文件发生变更，那么这次构建的hash值就发生变更，然后所有打包出来的文件都用这个 hash。无论其自身是否有变更。这无疑是不利于缓存的，没变更的文件也被替换了hash</p>
</blockquote>

<ol>
<li>chunk hash</li>
</ol>

<p>webpack构建的过程中，会根据entry的依赖关系来确定不同的chunk</p>

<pre><code class="language-javascript">// 在这个例子中，mysdk会当成一个独立的chunk打包
module.exports = {
  mode: &quot;production&quot;,
  entry: {
    index: &quot;./src/index.js&quot;,
    vender: &quot;./mysdk.js&quot;
  },
  output: {
    filename: &quot;[name].[chunkhash].js&quot; // hash =&gt; chunkhash
  }
}
</code></pre>

<p>chunk hash的维度是根据chunk来定义的。对上面的例子而言，vender会被打进一个chunk，index被打进一个chunk。其中一个chunk发生了变更，其chunk hash会随之变更，但是不影响其他chunk</p>

<blockquote>
<p>这样的好处就是利于缓存。比如index是业务代码，某次发版之后内容变更，chunk hash跟着变更。但是mysdk是比较稳定的sdk内容，不随着业务变更，那它的chunk hash还是保留了上次的结果</p>
</blockquote>

<ol>
<li>content hash</li>
</ol>

<p>content hash其实是一些插件自带的hash类型，比如 MiniCssExtractPlugin 就有content hash。它的纬度是文件内容本身，大部分时候指的是css。</p>

<p>比如一个js 引入了某个css。我们先看看chunk hash的情况</p>

<blockquote>
<ul>
<li>假设js内容变更，css内容不变更</li>
<li>js内容变更了，那chunk hash自然变更</li>
<li>因为这个js和css是同一个chunk，所以css的chunk hash也是变更的</li>
</ul>
</blockquote>

<p>如果用的是content hash</p>

<blockquote>
<ul>
<li>检测到css内容没有发生变更，那么js的hash变更，css的hash不变更</li>
</ul>
</blockquote>

<h4 id="toc_13">14. 什么是webpack 的 scope hoisting</h4>

<p>webpack作用域提升，指的是构建完的文件由多个函数合并到一个函数中。实现这个能力需要依靠ES6 Module的静态导入能力确定依赖关系</p>

<pre><code class="language-javascript">// 类似这样两个fn
function fn1() {
    // ...
}

function fn2() {
    // ...
}

// 合并成
function fn() {
    // run fn1 code
    // run fn2 code
}
</code></pre>

<h4 id="toc_14">15. webpack的source map 原理是什么</h4>

<p>source map是个很复杂的过程，他的作用是定位源码压缩前的位置。原理是利用VLQ编码</p>

<h4 id="toc_15">16. node 为什么适合高并发</h4>

<p>一般来说IO操作都是阻塞线程的，比如读写数据库，网络IO，读写文件等。大部分语言采用的策略是多线程处理。</p>

<p>但是对node来说，js是单线程的。node的解决方案是事件队列，也就是所谓的事件驱动。当遇到IO处理时，主线程将在线程池中请求一个线程资源，然后将相关的处理交给异步线程去做。当异步线程处理完后，线程归还线程池，事件回调推入事件队列</p>

<p>当主线程代码执行完毕之后，会进入一个 EventLoop 的阶段，处理timer，io cb，轮询结果，check等几个阶段。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见 HTML 面试题]]></title>
    <link href="https://evanoyam.github.io/16023387379097.html"/>
    <updated>2020-10-10T22:05:37+08:00</updated>
    <id>https://evanoyam.github.io/16023387379097.html</id>
    <content type="html"><![CDATA[
<p>其他类型的常见面试题：</p>

<ul>
<li><a href="16023387379097.html">常见 HTML 和 CSS 面试题</a></li>
<li><a href="16021877148099.html">常见 JS 面试题</a></li>
<li><a href="16021784313262.html">常见 Vue 面试题</a></li>
<li><a href="16023383568771.html">常见性能相关面试题</a></li>
<li><a href="16023387735398.html">常见大前端相关面试题</a></li>
</ul>

<h4 id="toc_0">1. 行内元素有哪些？块级元素有那些？行级块元素有哪些？</h4>

<p>行内元素：span，a，input，select 等表单相关，button</p>

<p>块级元素：div，p，ul，li，h1-h6</p>

<p>行级块元素：img</p>

<h4 id="toc_1">2. 行内元素和块级元素有什么区别？</h4>

<p>块元素一个块占一行</p>

<p>行内元素不能设置宽高，纵向的 padding，margin 等也失效</p>

<h4 id="toc_2">3. 页面导入样式时，使用 link 和@import 有什么区别？</h4>

<p>link 是 html 的标签，除了可以加载 css，还能定义 rel 等加载别的东西。link 在解析 html 的时候就并行加载了。</p>

<p>@import 是 css 的语法，他并不能在解析 html 的时候并行加载，是在 css 拉下来后执行 css 的时候由 css 去请求。古董浏览器还有些兼容问题</p>

<h4 id="toc_3">4. 介绍一下你对浏览器内核的理解？常见的浏览器内核有哪些？</h4>

<ol>
<li>chrome 的 webkit（现在是 blink）</li>
<li>firefox 的 gecko</li>
<li>ie 的 trident</li>
<li>safari 的 webkit（blink）</li>
</ol>

<h4 id="toc_4">5. iframe 有那些缺点？</h4>

<ol>
<li>阻塞页面解析</li>
<li>安全上可能有问题，iframe 能发起请求</li>
</ol>

<h4 id="toc_5">6. 页面可见性（Page Visibility API）可以有哪些用途？</h4>

<p>比如页面不可见的时候，暂停视频，音乐等</p>

<h4 id="toc_6">7. display: none; 与 visibility: hidden; 的区别</h4>

<p>display: none 会把节点从渲染树上移除</p>

<p>visibility: hidden 仅仅是让元素不可见，宽高布局还是在的</p>

<h4 id="toc_7">8. 什么是外边距重叠（margin-collapse）？ 重叠的结果是什么？</h4>

<p>在同一个 BFC（块级格式上下文）中的元素叠在一起时，两个元素的上下边距会合并，取消 BFC 就能解决这个问题:</p>

<ol>
<li>float</li>
<li>overflow 的值不为 visible</li>
<li>display: inline-block</li>
<li>position 的值为 absolute 或 fixed</li>
</ol>

<h4 id="toc_8">9. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h4>

<p>CSS 标准的盒模型是 W3C 的盒模型，元素的宽度和高度只由内容本身决定，不包括 margin，padding，border 的宽度</p>

<p>IE 盒模型也称为怪异盒模型，元素的宽度和高度有内容本身 + padding + border 的综合宽度决定</p>

<p>IE 盒模型在响应式页面（比如 h5）开发中特别好用，因为 width/height 直接决定了内容本身 + padding + border 的宽高，这本来就是自适应的</p>

<blockquote>
<p>通过 box-sizing: border-box 来启用 IE 盒模型</p>
</blockquote>

<h4 id="toc_9">10. CSS 哪些属性可以继承？</h4>

<ol>
<li>字体样式相关的属性，如 font-size，font-width，color 等</li>
<li>opacity 透明度可继承</li>
<li>文本相关属性，如 line-height，text-align，word-spacing 等</li>
</ol>

<h4 id="toc_10">11. CSS 优先级算法如何计算？</h4>

<p>每个匹配符都有他自己的权重，CSS 的优先级按权重相加来排序</p>

<table>
<thead>
<tr>
<th>匹配符</th>
<th>优先级权重</th>
</tr>
</thead>

<tbody>
<tr>
<td>*</td>
<td>1</td>
</tr>
<tr>
<td>.</td>
<td>10</td>
</tr>
<tr>
<td>#</td>
<td>100</td>
</tr>
<tr>
<td>!important</td>
<td>最高</td>
</tr>
</tbody>
</table>

<h4 id="toc_11">12. 用纯 CSS 创建一个三角形的原理是什么？</h4>

<p>利用 border，三边无色，一边有色</p>

<h4 id="toc_12">13. li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h4>

<p>inline-block 元素没有写在同一行，就会导致有间隙。可以让 inline-block 的元素写在同一行，或者让 font-size 为 0 解决这个问题</p>

<h4 id="toc_13">14. 什么是 bfc，怎样产生 bfc</h4>

<p>BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;</p>

<p>简单来说 BFC 就是一个独立的布局空间，空间内的元素与空间外的元素互不相干。常说的的“脱离文档流”其实就是创建了一个 BFC 空间</p>

<p>产生 BFC 的条件：</p>

<ol>
<li>float</li>
<li>display 为 inline-block</li>
<li>position 为 position 或者 fixed</li>
<li>overflow 为非 visible 的值</li>
</ol>

<blockquote>
<p>不同 BFC 的 margin 不会重叠，可以利用这个特性防止外边距重叠</p>
</blockquote>

<h4 id="toc_14">15. display:inline-block 什么时候会显示间隙？</h4>

<p>当 inline-block 元素不在同一行的时候，就会有间隙。可以用<code>font-size: 0</code>或者写在同一行来解决这个问题</p>

<h4 id="toc_15">16. rgba() 和 opacity 的透明效果有什么不同？</h4>

<p>rgba 不能继承，opacity 会继承给子元素</p>

<h4 id="toc_16">17. 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</h4>

<p>flexbox 就是自适应布局，常用来做移动端或者需要自适应的布局</p>

<p>父元素 display: flex 将开启 flexbox，可以选择横向定位也可以选择纵向定位，可以选择等分布局，居中等</p>

<h4 id="toc_17">18. 如何实现等高布局</h4>

<p>flexbox，纵轴拉伸即可<code>align-item: stretch</code></p>

<h4 id="toc_18">19. px，em，rem，vw 有什么区别？</h4>

<ol>
<li>px 是物理像素，1 像素就是 1px</li>
<li>em 是当前元素相对长度单位。它相对于当前元素 font-size 的大小</li>
</ol>

<blockquote>
<p>举例来说，如果当前元素的字体是 20px，那么当前元素中的 1em 就等于 20px。</p>
</blockquote>

<ol>
<li>rem 是根元素相对长度单位。它相对于根元素（html）的 font-size 大小</li>
</ol>

<blockquote>
<p>举例来说，如果 html 的字体是 20px，那么文档中元素的 1rem 就等于 20px。</p>
</blockquote>

<ol>
<li>vw 是屏幕宽度的相对长度单位。1vw = 1/100 screenWidth<br/>
&gt; 举例来说，如果屏幕宽度是 1000px，那么 1vw 就是 10px，这是根据屏幕物理宽度定位的</li>
</ol>

<h4 id="toc_19">20. 列举 2 种清除浮动的方式</h4>

<p>浮动就是让元素脱离当前文档流（和兄弟元素分离），直到碰到父元素或者碰到其他浮动元素为止</p>

<p>在 inline-block 出来之前，float 经常拿来实现行内块元素的效果</p>

<p>但是 float 会让父级元素高度坍塌，需要清除浮动恢复父级元素的高度：</p>

<ol>
<li>给父元素的伪元素加上<code>clear: both</code>和<code>display: block</code></li>
<li>给父元素设置<code>overflow: hidden</code>使其父元素开启 BFC</li>
</ol>

<h4 id="toc_20">21. 列出 3 个 CSS 优化、提高性能的方法</h4>

<ol>
<li>不要用内联样式，分离出样式表</li>
<li>合并样式表，避免发起多个 http 请求</li>
<li>合并 css 类，嵌套层级不要太深</li>
</ol>

<h4 id="toc_21">22. 浏览器是怎样解析 CSS 选择器的？</h4>

<ol>
<li>根据优先级覆盖，展示权重最大的样式</li>
<li>同优先级，则根据 css 表中代码顺序展示，后面的样式覆盖前面的样式</li>
</ol>

<h4 id="toc_22">23. 元素竖向的百分比设定是相对于容器的高度吗？</h4>

<p>相对于父元素高度</p>

<h4 id="toc_23">24. a 标签上四个伪类的执行顺序是怎么样的？</h4>

<p>lvha:<br/><br/>
link -&gt; visited -&gt; hover -&gt; active</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[手撕 Promise]]></title>
    <link href="https://evanoyam.github.io/16023386965383.html"/>
    <updated>2020-10-10T22:04:56+08:00</updated>
    <id>https://evanoyam.github.io/16023386965383.html</id>
    <content type="html"><![CDATA[
<p>手写 Promise 可谓是 17-19 年间常问的面试题了。虽然这两年问这种题的面试已经不多了，但是熟悉 Promise 的底层原理对自己的 JS 认知有很大的帮助。这篇文章会带大家写一个符合 promise A+ 规范的小型 Promise</p>

<h2 id="toc_0">简单版 Promise</h2>

<p><strong>Promise 的流程:</strong></p>

<ol>
<li>Promise 的构造方法接收一个 executor()，在 new Promise()时就立刻执行这个 executor 回调，executor()内部的异步任务被放入宏/微任务队列，等待执行</li>
<li>then()被执行，收集成功/失败回调，放入成功/失败队列</li>
<li>executor()的异步任务被执行，触发 resolve/reject，从成功/失败队列中取出回调依次执行</li>
</ol>

<blockquote>
<ul>
<li>本质上 Promise 就是一个观察者模式: 收集依赖 -&gt; 触发通知 -&gt; 取出依赖</li>
<li>简单版的 Promise 不符合 Promise A+ 单向状态流通的规范</li>
</ul>
</blockquote>

<pre><code class="language-javascript">class MyPromise {
  // 构造方法接收一个回调
  constructor(executor) {
    this._resolveQueue = [] // then 收集的执行成功的回调队列
    this._rejectQueue = [] // then 收集的执行失败的回调队列

    // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue
    let _resolve = (val) =&gt; {
      // 从成功队列里取出回调依次执行
      while (this._resolveQueue.length) {
        const callback = this._resolveQueue.shift()
        callback(val)
      }
    }
    // 实现同resolve
    let _reject = (val) =&gt; {
      while (this._rejectQueue.length) {
        const callback = this._rejectQueue.shift()
        callback(val)
      }
    }
    // new Promise()时立即执行executor,并传入resolve和reject
    executor(_resolve, _reject)
  }

  // then 方法,接收一个成功的回调和一个失败的回调，并 push 进对应队列
  then(resolveFn, rejectFn) {
    this._resolveQueue.push(resolveFn)
    this._rejectQueue.push(rejectFn)
  }
}

// 来看看发生了什么:
// 1. MyPromise 构造函数生成一个实例，这时候传入的函数(也就是 executor)就立马执行了，这里是一个 setTimeout 的异步，推入了下一轮宏任务
// 2. 紧接着调用了构造函数的 then 方法，传入了 resolveFn，这时候把这个 resolveFn 的回调塞进成功队列里面
// 3. 代码跑完，开始下一轮的宏任务(也就是刚刚 new MyPromise 实例的时候的那个 setTimeout)
// 4. 这个 setTimeout 执行了一句 resolve(&#39;result&#39;)，这时候触发了读取成功队列的操作，读出刚刚存好的 resolveFn 并且执行
const p1 = new MyPromise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&#39;result&#39;)
  }, 1000)
})
p1.then((res) =&gt; console.log(res))
</code></pre>

<h2 id="toc_1">符合 Promise A+ 规范的版本</h2>

<ol>
<li>Promise A+ 规范指出: Promise 本质是一个状态机，且状态只能为以下三种：Pending（等待态）、Fulfilled（执行态）、Rejected（拒绝态），状态的变更是单向的，只能从 Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li>
<li>then 方法接收两个可选参数，分别对应状态改变时触发的回调。then 方法返回一个 Promise。then 方法可以被同一个 Promise 调用多次(链式调用)。</li>
</ol>

<blockquote>
<ul>
<li>除了要符合 Promise A+ 规范之外，还要透传同步代码</li>
<li>then 如果不是函数，还要封装成函数保证链式调用不被异常终端</li>
<li>then 返回的是 Promise 支持链式调用</li>
</ul>
</blockquote>

<pre><code class="language-javascript">//Promise/A+规定的三种状态
const PENDING = &#39;pending&#39;
const FULFILLED = &#39;fulfilled&#39;
const REJECTED = &#39;rejected&#39;

class MyPromise {
  // 构造方法接收一个回调
  constructor(executor) {
    this._status = PENDING // Promise状态
    this._value = undefined // 储存then回调return的值
    this._resolveQueue = [] // 成功队列, resolve时触发
    this._rejectQueue = [] // 失败队列, reject时触发

    // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue
    let _resolve = (val) =&gt; {
      //把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况
      const run = () =&gt; {
        if (this._status !== PENDING) return // 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;
        this._status = FULFILLED // 变更状态
        this._value = val // 储存当前value

        // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;
        // 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift()
          callback(val)
        }
      }
      setTimeout(run)
    }
    // 实现同resolve
    let _reject = (val) =&gt; {
      const run = () =&gt; {
        if (this._status !== PENDING) return // 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;
        this._status = REJECTED // 变更状态
        this._value = val // 储存当前value
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift()
          callback(val)
        }
      }
      setTimeout(run)
    }
    // new Promise()时立即执行executor,并传入resolve和reject
    executor(_resolve, _reject)
  }

  // then方法,接收一个成功的回调和一个失败的回调
  then(resolveFn, rejectFn) {
    // 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行
    typeof resolveFn !== &#39;function&#39; ? (resolveFn = (value) =&gt; value) : null
    typeof rejectFn !== &#39;function&#39;
      ? (rejectFn = (reason) =&gt; {
          throw new Error(reason instanceof Error ? reason.message : reason)
        })
      : null

    // return一个新的promise
    return new MyPromise((resolve, reject) =&gt; {
      // 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论
      const fulfilledFn = (value) =&gt; {
        try {
          // 执行第一个(当前的)Promise的成功回调,并获取返回值
          let x = resolveFn(value)
          // 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }

      // reject同理
      const rejectedFn = (error) =&gt; {
        try {
          let x = rejectFn(error)
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }

      switch (this._status) {
        // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行
        case PENDING:
          this._resolveQueue.push(fulfilledFn)
          this._rejectQueue.push(rejectedFn)
          break
        // 当状态已经变为resolve/reject时,直接执行then回调
        case FULFILLED:
          fulfilledFn(this._value) // this._value是上一个then回调return的值(见完整版代码)
          break
        case REJECTED:
          rejectedFn(this._value)
          break
      }
    })
  }
}
</code></pre>

<h2 id="toc_2">完整版</h2>

<pre><code class="language-javascript">//Promise/A+规定的三种状态
const PENDING = &#39;pending&#39;
const FULFILLED = &#39;fulfilled&#39;
const REJECTED = &#39;rejected&#39;

class MyPromise {
  // 构造方法接收一个回调
  constructor(executor) {
    this._status = PENDING // Promise状态
    this._value = undefined // 储存then回调return的值
    this._resolveQueue = [] // 成功队列, resolve时触发
    this._rejectQueue = [] // 失败队列, reject时触发

    // 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue
    let _resolve = (val) =&gt; {
      //把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况
      const run = () =&gt; {
        if (this._status !== PENDING) return // 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;
        this._status = FULFILLED // 变更状态
        this._value = val // 储存当前value

        // 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;
        // 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调
        while (this._resolveQueue.length) {
          const callback = this._resolveQueue.shift()
          callback(val)
        }
      }
      setTimeout(run)
    }
    // 实现同resolve
    let _reject = (val) =&gt; {
      const run = () =&gt; {
        if (this._status !== PENDING) return // 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;
        this._status = REJECTED // 变更状态
        this._value = val // 储存当前value
        while (this._rejectQueue.length) {
          const callback = this._rejectQueue.shift()
          callback(val)
        }
      }
      setTimeout(run)
    }
    // new Promise()时立即执行executor,并传入resolve和reject
    executor(_resolve, _reject)
  }

  // then方法,接收一个成功的回调和一个失败的回调
  then(resolveFn, rejectFn) {
    // 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行
    typeof resolveFn !== &#39;function&#39; ? (resolveFn = (value) =&gt; value) : null
    typeof rejectFn !== &#39;function&#39;
      ? (rejectFn = (reason) =&gt; {
          throw new Error(reason instanceof Error ? reason.message : reason)
        })
      : null

    // return一个新的promise
    return new MyPromise((resolve, reject) =&gt; {
      // 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论
      const fulfilledFn = (value) =&gt; {
        try {
          // 执行第一个(当前的)Promise的成功回调,并获取返回值
          let x = resolveFn(value)
          // 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }

      // reject同理
      const rejectedFn = (error) =&gt; {
        try {
          let x = rejectFn(error)
          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      }

      switch (this._status) {
        // 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行
        case PENDING:
          this._resolveQueue.push(fulfilledFn)
          this._rejectQueue.push(rejectedFn)
          break
        // 当状态已经变为resolve/reject时,直接执行then回调
        case FULFILLED:
          fulfilledFn(this._value) // this._value是上一个then回调return的值(见完整版代码)
          break
        case REJECTED:
          rejectedFn(this._value)
          break
      }
    })
  }

  //catch方法其实就是执行一下then的第二个回调
  catch(rejectFn) {
    return this.then(undefined, rejectFn)
  }

  //finally方法
  finally(callback) {
    return this.then(
      (value) =&gt; MyPromise.resolve(callback()).then(() =&gt; value), //执行回调,并returnvalue传递给后面的then
      (reason) =&gt;
        MyPromise.resolve(callback()).then(() =&gt; {
          throw reason
        }) //reject同理
    )
  }

  //静态的resolve方法
  static resolve(value) {
    if (value instanceof MyPromise) return value //根据规范, 如果参数是Promise实例, 直接return这个实例
    return new MyPromise((resolve) =&gt; resolve(value))
  }

  //静态的reject方法
  static reject(reason) {
    return new MyPromise((resolve, reject) =&gt; reject(reason))
  }

  //静态的all方法
  static all(promiseArr) {
    let index = 0
    let result = []
    return new MyPromise((resolve, reject) =&gt; {
      promiseArr.forEach((p, i) =&gt; {
        //Promise.resolve(p)用于处理传入值不为Promise的情况
        MyPromise.resolve(p).then(
          (val) =&gt; {
            index++
            result[i] = val
            if (index === promiseArr.length) {
              resolve(result)
            }
          },
          (err) =&gt; {
            reject(err)
          }
        )
      })
    })
  }

  //静态的race方法
  static race(promiseArr) {
    return new MyPromise((resolve, reject) =&gt; {
      //同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态
      for (let p of promiseArr) {
        MyPromise.resolve(p).then(
          //Promise.resolve(p)用于处理传入值不为Promise的情况
          (value) =&gt; {
            resolve(value) //注意这个resolve是上边new MyPromise的
          },
          (err) =&gt; {
            reject(err)
          }
        )
      }
    })
  }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用设计模式]]></title>
    <link href="https://evanoyam.github.io/16023385653734.html"/>
    <updated>2020-10-10T22:02:45+08:00</updated>
    <id>https://evanoyam.github.io/16023385653734.html</id>
    <content type="html"><![CDATA[
<p>这篇文章主要汇总一些在前端中常见的设计模式，不会每一个都展开讲，遇到觉得有必要深入记录的设计模式就会展开细说。</p>

<ol>
<li>使用单体模式来实现弹窗的基本原理</li>
<li><strong>使用虚拟代理实现图片的预加载、懒加载</strong></li>
<li>虚拟代理合并 http 请求的理解</li>
<li><strong>Vue 观察者模式实现双向绑定</strong></li>
<li>模块模式封装代码块</li>
<li>代理模式实现事件委托</li>
<li>工厂模式实现游戏职业选择（或者自动贩卖机，计算器等）</li>
<li>策略模式实现表单校验</li>
<li>外观模式实现浏览器兼容</li>
<li>备忘录模式实现分页控件</li>
<li>状态模式实现下载</li>
<li><strong>适配器适配前后端数据格式</strong></li>
<li><strong>单例模式弹窗</strong></li>
<li>工厂模式 new Vue</li>
<li><strong>代理模式实现拦截器</strong></li>
</ol>

<h4 id="toc_0">观察者模式</h4>

<pre><code class="language-javascript">class Subject {
  constructor() {
    this.observers = []
  }

  add(observer) {
    this.observers.push(observer)
  }

  notify(...args) {
    this.observers.forEach((observer) =&gt; observer.update(...args))
  }
}

class Observer {
  constructor(cb) {
    this.cb = cb
  }
  update(...args) {
    this.cb(...args)
  }
}

const observer1 = new Observer(function (name) {
  console.log(&#39;name1: &#39;, name)
})

const observer2 = new Observer(function (name) {
  console.log(&#39;name2: &#39;, name)
})

const subject1 = new Subject()
subject1.add(observer1)
subject1.add(observer2)

subject1.notify(&#39;evan&#39;)
</code></pre>

<h4 id="toc_1">发布订阅模式</h4>

<p>观察者模式和发布订阅模式最大的区别，就是发布订阅有事件中心，发布者和订阅者之间不直接互通，由事件中心来控制消息的传递。而观察者模式中观察者和被观察者（事件）之间是彼此感知的，相互耦合的。</p>

<p>举个例子，观察者模式就像是面试官直接监考面试者做题，前端面试官监考前端面试者，后端面试官监考后端面试者。面试者做完了将告诉自己的面试官（观察者）</p>

<p>而发布订阅模式，则是 hr 监考面试者做题，这里可能有前端面试者，有后端面试者，运维面试者等等。某个考生做完题，告诉 hr，然后 hr 去通知对应的面试官</p>

<p>换句话说，<strong>观察者模式没有中间商赚差价</strong></p>

<blockquote>
<ul>
<li>这两者之间是各有优劣的。</li>
<li>发布订阅模式的优点是解耦，发布者和订阅者独立管理，开发使用的时候只需要关注消息中心即可，由消息中心收集 / 推送。缺点就是随着管理的消息越来越多，消息中心需要管理的队列就越来越庞大，而且多了一个中间层，性能也稍微差一些。就像上面的例子，当面试者很多的时候，hr 就会很忙了，处理并且通知各类面试官。除了忙之外效率也没有面试者和面试官直接沟通来的高</li>
<li>观察者模式的优点是足够直接，最直接的响应式。当被观察者状态变更的时候，观察者马上就能知道。缺点是彼此耦合，不利于独立维护和管理，开发者需要同时维护观察者和被观察者两个实例。不够灵活自由。此外没有消息队列，意味着每一种观察类型都要构建其观察者和事件的实例。在前端中 addEventListener 其实就是一种观察者的应用</li>
</ul>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[强缓存与协商缓存]]></title>
    <link href="https://evanoyam.github.io/16023385181073.html"/>
    <updated>2020-10-10T22:01:58+08:00</updated>
    <id>https://evanoyam.github.io/16023385181073.html</id>
    <content type="html"><![CDATA[
<p>这篇文章介绍了强缓存与协商缓存，即本地缓存与 HTTP 缓存的异同。</p>

<h2 id="toc_0">强缓存</h2>

<ol>
<li><code>Expires</code>：携带的是资源失效时间，是一个日期的绝对时间。在这个失效之前的请求，都是强缓存，客户端发起的请求不会到达服务端</li>
<li><code>cache-control</code>：携带的是缓存控制项，常见的有 max-age 属性，控制资源失效时间，是一个以秒为单位的相对时间；以及 <code>no-cache</code> 不使用强缓存。当与 <code>expries</code> 同时出现时，<code>cache-control</code> 为准。</li>
</ol>

<blockquote>
<ul>
<li><code>expires</code> 是一个时间戳，首次访问时服务器会告诉客户端一个过期的时间点。此后的每次请求，客户端都会比对这个时间，如果还未到这个时间节点，就不发起请求而是直接读取缓存</li>
<li>由于 <code>expires</code> 依赖客户端时间，所以缓存不稳定，比如改动了本地的时间就能让缓存失效，因此在 http1.1 加入了 <code>cache-control</code>。<code>cache-control</code> 是一个过期的相对时间戳，比如 6 分钟，这样就不依赖本地时间了</li>
<li><code>no-cache</code> 是不使用强缓存，走协商缓存；<code>no-store</code> 是不使用所有 http 缓存策略（强缓存和协商缓存都不使用）</li>
</ul>
</blockquote>

<h2 id="toc_1">协商缓存</h2>

<ol>
<li><code>If-None-Match</code>：携带的是服务器返回的 <code>Etag</code> 校验码，校验码能保证每个资源都是唯一的。服务器通过判断 <code>Etag</code> 是否一致，来判断资源是否有变化</li>
<li><code>If-Modified-Since</code>：携带的是服务器返回的 <code>Last-Modify</code>，利用这个时间和服务器最新资源的修改时间做对比，判断资源是否一致</li>
</ol>

<h2 id="toc_2">浏览器发起请求</h2>

<p><strong>首次请求:</strong></p>

<p><img src="https://img.bluepay.asia/upload/manual/20200426/16124266.png" alt="image"/></p>

<p><strong>再次请求:</strong></p>

<p><img src="https://img.bluepay.asia/upload/manual/20200426/16132983.png" alt="image"/></p>

<blockquote>
<ul>
<li>命中强缓存返回 200，不解析服务器数据，直接使用缓存，显示 <code>from disk cache</code></li>
<li>协商缓存客户端仍然会和服务器通信，命中缓存后返回的是 304</li>
<li>普通刷新会忽略强缓存，启用协商缓存。只有当地址栏输入地址，链接引用资源等情况下，才会启用强缓存。普通刷新流程是先判断强缓存，再判断协商缓存。强缓存中优先级是 <code>cache-control</code> &gt; <code>expries</code>，协商缓存中优先级是 <code>If-None-Match</code> &gt; <code>If-Modified-Since
</code></li>
</ul>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试常见性能问题]]></title>
    <link href="https://evanoyam.github.io/16023383568771.html"/>
    <updated>2020-10-10T21:59:16+08:00</updated>
    <id>https://evanoyam.github.io/16023383568771.html</id>
    <content type="html"><![CDATA[
<p>总结了一些常见的性能相关的面试题，分享给大家，也供自己复习的时候看。</p>

<p>其他类型的常见面试题：</p>

<ul>
<li><a href="16023387379097.html">常见 HTML 和 CSS 面试题</a></li>
<li><a href="16021877148099.html">常见 JS 面试题</a></li>
<li><a href="16021784313262.html">常见 Vue 面试题</a></li>
<li><a href="16023383568771.html">常见性能相关面试题</a></li>
<li><a href="16023387735398.html">常见大前端相关面试题</a></li>
</ul>

<h4 id="toc_0">1. 浏览器的渲染过程</h4>

<p>这里不讨论网络请求，只讨论拿到 html 之后</p>

<ul>
<li>首先并行请求 css 和 js</li>
</ul>

<blockquote>
<p>js 会阻塞 dom 解析，因为 js 能操作 dom，所以在请求 js 的时候 dom 是停止解析的，因为浏览器不知道这个未知的 js 会对 dom 干啥</p>
</blockquote>

<ul>
<li>dom 树解析完毕，结合 css 树生成渲染树</li>
<li>在页面上绘制，如果涉及到动画或者需要 GPU 引擎的，还会开启 GPU 加速</li>
<li>最后再检查有没有不断触发渲染的元素（比如 video，动画等）有的话就扔进复合层（合成层）中单独处理</li>
</ul>

<h4 id="toc_1">2. DOM 树 和 渲染树 的区别</h4>

<p>DOM 树就是 html 节点构成的一颗树，渲染树是 DOM 树加上 CSS 树的样式属性，最终合并的一颗带有样式属性的节点树</p>

<h4 id="toc_2">3. 重绘和回流的区别和关系</h4>

<p><img src="https://qiniu.evanweb.cn/1591067102313.jpg" alt="image"/><br/>
浏览器渲染的过程是，js 先控制 dom 的属性，如果 dom 的布局发生改变，则触发回流（重排）如果是非布局相关的样式变动，则触发重绘，然后开始在页面上绘制相关的元素，最后如果某个元素频繁刷新（如 video 和动画元素）就会把它扔进合成层，独立一个新的层来让他处理</p>

<ol>
<li>只要是布局相关的属性被访问，或者布局被修改，就会产生回流</li>
<li>颜色和其他非布局样式相关的属性被修改则只是重绘</li>
<li>如果有频繁渲染的元素就会被扔进合成层独立出来</li>
<li>重绘不一定会回流，回流一定会重绘</li>
</ol>

<h4 id="toc_3">4. 如何最小化重绘 (repaint) 和回流(reflow)</h4>

<ol>
<li>让元素脱离文档流再操作（display:none），操作完再重新塞到 dom 树中</li>
<li>减少操作 dom，读取布局相关属性的时候先缓存一个值，在 js 层面操作而不要频繁读取</li>
<li>利用动画属性开启 GPU 硬件加速</li>
</ol>

<h4 id="toc_4">5. script 的位置是否会影响首屏显示时间？</h4>

<p>script 标签如果不加 defer/async 属性，是会阻塞 dom 生成的，如果 script 在 dom 节点之前，那在脚本下载且执行完之前，html 是不会继续解析的，这样会影响首屏</p>

<h4 id="toc_5">6. 事件的三个阶段以及事件的执行顺序和事件的执行次数？</h4>

<p>事件有捕获，目标，冒泡三个阶段，先是捕获阶段，到目标阶段，再到冒泡阶段</p>

<p>addEventListener 的第三个参数就是用来控制捕获还是冒泡阶段执行回调，true 是捕获，false 是冒泡，默认 false</p>

<h4 id="toc_6">7. 什么是事件代理（委托）</h4>

<p>由于事件都有冒泡机制，所以可以把触发的回调绑定到目标元素的父元素上，利用事件冒泡来触发回调，再通过 target 来确定实际触发的元素是哪个</p>

<pre><code class="language-javascript">function colorChange(e) {
  var e = e || window.event // 兼容性的处理
  if (e.target.nodeName.toLowerCase() === &#39;li&#39;) {
    box.innerHTML = &#39;该颜色为&#39; + e.target.innerHTML
  }
}
color_list.addEventListener(&#39;click&#39;, colorChange, false)
</code></pre>

<blockquote>
<p><code>e.target</code> 和 <code>e.currentTarget</code> 是不同的，前者是指事件的发出者（目标元素），后者是指事件的监听者。如上述代码，target 就是点击的元素（li），currentTarge 就是事件监听绑定的元素（ul）</p>
</blockquote>

<h4 id="toc_7">8. W3C 事件的 target 与 currentTarget 的区别？</h4>

<p><code>e.target</code> 是指事件的发出者（目标元素），<code>e.currentTarget</code> 是指事件的监听者。</p>

<h4 id="toc_8">9. pageX,clientX,screenX,offsetX 的区别是什么？</h4>

<p>这些都是事件中目标元素的位置属性</p>

<ul>
<li>pageX 是距离 document 顶点的 x 轴距离，相对的是整个文档流</li>
</ul>

<blockquote>
<p>IE 下无效</p>
</blockquote>

<ul>
<li>clientX 是距离可视视窗（浏览器）顶点的 x 轴距离</li>
<li>screenX 是距离屏幕定点 x 轴的距离，与浏览器窗口大小无关</li>
<li>offsetX 是距离当前元素顶点的 x 周距离</li>
</ul>

<blockquote>
<p>Firefox 无效，用 layerX</p>
</blockquote>

<h4 id="toc_9">10. script 标签中的 defer 和 async 有什么作用</h4>

<p>首先需要明确一点的是，js 执行过程中 dom 渲染是必须暂停的。因为并行渲染 dom 和执行 js 的结果是不可预估的，天知道 js 里干了什么</p>

<p>defer 也好 async 也好，他们只是异步加载 js 并不是执行 js。他两都是在 dom 渲染的时候同时去加载 js</p>

<p>但区别在于 defer 是等 dom 渲染完再执行 js，而 async 是 js 下载完了就停止 dom 解析，执行完 js 再继续解析 dom</p>

<p><img src="https://qiniu.evanweb.cn/WechatIMG1.png" alt="image"/></p>

<blockquote>
<ul>
<li>defer 是在 dom 解析完，<code>DOMContentLoaded</code> 事件触发之前完成，执行的顺序按加载的顺序</li>
<li>async 是完全乱序的，反正什么时候下载完脚本，他紧跟着就执行。实际上 async 用处并不大甚至用不好可能还会有些负面影响</li>
</ul>
</blockquote>

<h4 id="toc_10">11. 页面编码和被请求的资源编码如果不一致（乱码）如何处理？</h4>

<p>请求和响应头加上 UTF-8</p>

<h4 id="toc_11">12. 事件绑定有哪些不同方法，有什么不同，哪种好</h4>

<ol>
<li>内联绑定</li>
<li>script 绑定</li>
<li>addEventListener</li>
</ol>

<p>最好用 addEventListener，它不但代码上解耦方便复用，而且它能控制捕获还是冒泡执行。另外它是可以多次绑定同一个回调的</p>

<h4 id="toc_12">13. 如何阻止默认和冒泡事件</h4>

<ol>
<li>阻止默认事件</li>
</ol>

<p>w3c 标准： <code>e.preventDefault()</code>，IE 标准： <code>e.returnValue = false</code></p>

<ol>
<li>阻止冒泡</li>
</ol>

<p>w3c 标准： <code>e.stopPopagation()</code>，IE 标准： <code>e.cancelBubble = true</code></p>

<ol>
<li>vue 可以用 <code>.prevent</code> 事件修饰符来禁止默认事件，用 <code>.stop</code> 来阻止冒泡</li>
</ol>

<h4 id="toc_13">14. 介绍一下 websocket，和长轮询有什么不同</h4>

<p><strong>长连接</strong></p>

<p>长连接是相对短连接而言的，短连接就是每一个 http 请求都只用一个 tcp/ip，请求结束 tcp/ip 就挥手结束</p>

<p>而长连接是请求结束后，保持当前 tcp/ip 继续连接，这样就能在一个 tcp/ip 中持续发送数据包（需要注意 http 是断开的，tcp 连接和 http 连接没有必然联系，一个在应用层，一个在传输层）</p>

<p><strong>轮询</strong></p>

<p>轮询就是客户端不断发送请求给服务端，服务端不断响应一个个请求已达到类似保活的能力。其中又分为短轮询和长轮询</p>

<p>短轮询就是客户端每次发送请求给服务端，服务端都立马响应</p>

<p>长轮询就是客户端发送请求给服务端之后，服务端等待业务处理，有消息的时候再响应。如果一直没有消息，就达到设置好的超时时间后响应</p>

<p><strong>websocket</strong></p>

<p>websocket 是一种双工通信的协议，是对 tcp/ip 的抽象，封装了一层 api 提供给上层应用，也就是说他是应用层的协议。websocket 是一种双向通信的方案</p>

<ol>
<li>websocket 建立在 tcp 之上，并且握手阶段采用 http 协议</li>
<li>没有同源限制，客户端可以与任意服务端通信</li>
<li>有 ws 和 wss 两种连接方式，类似与 http 与 https 的关系，wss 就是在 tcp/ip 和 ws 之间加了 TLS 证书认证</li>
<li>数据传输阶段使用 frame（数据帧）进行通信，frame 可以选择文本数据或二进制数据传输</li>
</ol>

<p>出于安全考虑和避免网络截获，客户端发送的数据帧必须进行掩码处理后才能发送到服务器，不论是否是在 TLS 安全协议上都要进行掩码处理</p>

<blockquote>
<p>上述三者都能实现服务端主动推送，客户端服务端保活，但区别就在于：</p>

<ol>
<li>轮询是客户端主导的，服务端被动响应，只不过响应的频率高就能简单理解成“服务端主动推送了”</li>
<li>长连接能实现真正的服务端推送，但是他是建立在应用层的 http 上的</li>
<li>websocket 是 tcp/ip 的上层抽象，他的服务端推送和保活都是基于 tcp/ip 封装的结果</li>
</ol>
</blockquote>

<p><strong>注意：长连接和 websocket 都能服务端主动推送，但是本质上是有区别的</strong></p>

<blockquote>
<ul>
<li>长连接是客户端发起一个 http 请求后，服务端保持请求状态而不响应，直到需要推送的时候再响应。因为 http 是一个 req 和 res 相对应的连接，所以每次服务端响应之后，http 断开，这时候客户端再发一个 http 过来，服务端保持请求状态。换句话说如果客户端不发 http 过来，就算是 tcp 连着，服务端推送消息客户端也收不到，因为不知道是客户端是谁</li>
<li>而 websocket 不是 http 协议，他是基于传输层 tcp/ip 的上层封装，从传输层实现的连接保持，服务端能推送且客户端能接收</li>
</ul>
</blockquote>

<h4 id="toc_14">15. 浏览器有哪些进程，这些进程又有哪些线程</h4>

<p>对操作系统来说，大多数任务都是一个进程，但是浏览器是个例外，这是个多进程应用</p>

<p>以 Chrome 举例，有如下进程:</p>

<ol>
<li><p>主进程 Browser Process</p>
<blockquote>
<p>负责浏览器界面的显示与交互。各个页面的管理, 创建和销毁其他进程。网络的资源管理、下载等。</p>
</blockquote></li>
<li><p>插件进程 Plugin Process</p>
<blockquote>
<p>Chrome 插件所用的进程</p>
</blockquote></li>
<li><p>GPU 进程 GPU Process</p>
<blockquote>
<p>GPU 绘制的进程</p>
</blockquote></li>
<li><p>渲染进程 Renderer Process</p>
<blockquote>
<p>前端最应该关注的进程，包括 5 个线程:</p>
<ul>
<li>渲染线程，与 js 线程互斥</li>
<li>js 线程，与渲染线程互斥</li>
<li>事件处理线程，收集异步回调，触发时塞到 js 线程的处理队列</li>
<li>定时器线程，类似事件处理线程，触发时将定时器塞到 js 线程的处理队列</li>
<li>异步 http 线程，当 ajax 状态发生改变时，就把回调塞到 js 线程的处理队列</li>
</ul>
</blockquote></li>
</ol>

<p>其中 js 线程和渲染线程是互斥的，因为 js 线程能修改 dom 节点，如果同时渲染和修改节点就会出问题</p>

<h4 id="toc_15">16. 为什么 JavaScript 引擎是单线程，JavaScript 可以多线程吗</h4>

<p>js 最初的设计是为了 web 动态交互的，之所以设计成单线程，是因为如果是多线程，js 操作 dom 的时候还要考虑有没有其他线程在处理，这就涉及到上锁的操作</p>

<p>在浏览器环境中，w3c 提出了新的规范 web worker，他是一个独立的线程，但是他又不可以操作 dom（原因和 js 为什么是单线程类似）他可以做一些比如埋点等非 dom 操作的事情</p>

<p>但是在 node 环境中，因为是个服务端环境，也不涉及什么 dom，所以 node 的多线程就显得有点用了，虽然 node 有 libuv 这种非阻塞的库</p>

<p>但是如果是 cpu 密集操作，高强度运算（比如机器学习之类的）需要等待较长的同步时间，单线程就蛋疼了，他会阻塞掉后续的代码。所以 node 提出了多线程 worker_threads</p>

<h4 id="toc_16">17. JWT 和 session 有什么不同，JWT 解决了什么问题</h4>

<p>JWT 是 json web token 的缩写，它包含三部分，头部 header，负载 payload，签名 signature。</p>

<p>传统 session 是服务器开启一个会话，保存用户信息或其他相关信息，然后把 session id 返回给前端，前端写入 cookies 中。每次请求携带 session id 来判断用户身份</p>

<p>JWT 是服务器不保存任何状态（无状态），服务器签发一个包含过期时间的，加密的 json 给前端，前端每次请求在请求头的 Authorization 中加上 token，服务器判断是否过期即可</p>

<p>JWT 最大的优势就是解决了集群的问题，如果是 session，分流后不同机器还要保证能读到同一份 session，比如 session 持久化写到某个地方。JWT 就不需要了，反正服务器是无状态的，利于扩展。并且合理利用 JWT 可以减少服务器对数据库的读写</p>

<p>JWT 也有缺点，一旦签发之后，是不能中断 token 的有效期的，因为过期时间是在 token 内的。JWT 虽然有 signature 签名保证数据不被串改，token 本质上也是对外暴露的。所以生成 token 之后最好还是加密一下</p>

<h4 id="toc_17">18. 什么是 XSS 攻击，如何防护</h4>

<p>XSS 就是跨站脚本攻击，常见的有三种：反射型，持久型，dom 型</p>

<p>三种类型：</p>

<ol>
<li>反射型就是恶意脚本不写入数据库，仅仅是到后端业务逻辑，返回前端</li>
<li>持久型是写入数据库的，每次查询接口读库都会触发这段恶意代码</li>
<li>dom 型简单来说就是前端代码不严谨导致的，把不可信的字符当作 js 脚本来解析了。比如 innerHTML，vue 中的 v-html，都会有被 xss 的风险</li>
</ol>

<p>防范：</p>

<ol>
<li>防范 xss 最关键就是不要把不可信的文本当作 js 去执行，所以转译是最有效的一种办法。转译需要前后端都做配合，后端写库或者收到响应的时候把敏感字符转码，前端也要避免执行到恶意脚本<br/>
&gt; 这里不建议自己去做 xss，要选择市面上成熟的 xss 预防方案，因为自己做 xss 很有可能某个细节疏忽导致出现漏洞，比如 css 请求一个图片能被 xss，网址 url 拼接参数也能被 xss，事件中也可能被注入等等...</li>
<li>cookies 采用 http-only 的头，不允许 js 读取</li>
<li>控制内容长度，脚本一般较长，控制内容长度也能起到一定的效果</li>
<li>开启 CSP 等</li>
</ol>

<h4 id="toc_18">19. 什么是 CSRF 攻击，如何防护</h4>

<p>CSRF 是跨站伪造请求:</p>

<p>现在有正规网站 A，恶意网站 B，正常用户 C</p>

<ol>
<li>正常用户 C 访问正常网站 A，登陆</li>
<li>A 产生 C 的 cookies，并且 A 的服务器写入 session</li>
<li>C 被诱导去恶意网站 B（比如迁入 a 的广告等）</li>
<li>此时 B 拿到 C 的 cookies，伪造一个请求（比如通过好友申请，付款，修改个人信息等，反正就是伪造一个请求）以 C 的身份发起请求</li>
<li>服务端认证 cookies 通过，恶意请求成功</li>
</ol>

<p>如何防护？</p>

<ol>
<li>验证 Referer<br/>
&gt; 在请求头中有个 Referer 字段，表示请求者的来源地址。可以验证这个字段，如果不是自己的网站，就拒绝请求</li>
<li>表单提交的时候需要验证码<br/>
&gt; 这样就算伪造了请求，也不知道验证码是什么（不在原网页上了，看不到验证码）也就无法请求成功</li>
<li>用户的验证信息不在 cookies 中，而是在请求头或者携带 token 参数去请求</li>
</ol>

<h4 id="toc_19">20. 网页验证码是干嘛的，是为了解决什么安全问题</h4>

<ol>
<li>防止机器人刷脚本</li>
<li>起到一些防止 CSRF 攻击的效果</li>
<li>降低高并发请求频率</li>
</ol>

<h4 id="toc_20">21. 什么是强缓存，什么是协商缓存</h4>

<p><strong>强缓存:</strong></p>

<p>强缓存是是请求未到达服务器的缓存，一般来自硬盘，内存等，http 状态码是 200</p>

<p>强缓存有两种类型，一种响应头为 expired，另一种响应头带有 cache-control</p>

<p>expired 是一个绝对日期，指的是资源生效的最后日期。但是会收客户端影响，比如客户端把本地时间改了，就能让缓存失效</p>

<p>cache-control 是一种新的强缓存控制策略，是一个相对时间，指的是缓存生效的期限（比如 30 天）这样缓存就不受客户端因素的影响。此外 cache-control 还能设置成 no-store（不缓存）no-cache（不强缓存，走协商缓存）</p>

<p><strong>协商缓存:</strong></p>

<p>协商缓存是发起了 http 请求，和服务器最新资源比对之后，如果资源未更新就返回缓存资源，http 状态码是 304。与强缓存不一样的是协商缓存需要发起请求和服务器比对资源状态</p>

<p>协商缓存也有两种，一种是通过时间来比对，响应头是 Last-motify-since，指的是文件最新更改的时间。如果请求头所带的时间和服务器最新资源的时间匹配则返回缓存，不匹配则返回新的资源</p>

<p>另一种是通过 Etag 在判断资源是否更新，这种精度更大，因为时间比对如果是毫秒级的更新那么缓存可能存在误差，而且不知道新旧文件本质内容是不是一样的。Etag 是判断两个文件的 hash 是否一样，如果 hash 一样就意味着文件没有变更，返回缓存，如果 hash 不同，则返回最新资源</p>

<h4 id="toc_21">22. 什么是 ajax，ajax 的作用是什么</h4>

<p>ajax 就是发起网络请求，动态刷新页面</p>

<h4 id="toc_22">23. 如何创建一个 Ajax</h4>

<pre><code class="language-javascript">const sendAjax = (method, url) =&gt; {return new Promise((resolve, reject) =&gt; {const mAjax = new XMLHttpRequest()
    mAjax.open(method, url, true)
    mAjax.setRequestHeader(&#39;Content-type&#39;, &#39;text/html&#39;)
    mAjax.send()mAjax.onreadystatechange = function() {if (readyState == 4 &amp;&amp; (status == 200 || status == 304)) {resolve()
      } else {reject()
      }
    }
  })
}
</code></pre>

<h4 id="toc_23">24. json，jsonp，xml 的区别</h4>

<p>json 是一种文件传输格式，轻量级，高效，也常做配置文件</p>

<p>jsonp 简单来说就是一个脚本（script 标签），回调回来是一个 json。常用来跨域，因为 script 标签不受同源策略影响</p>

<p>xml 使用描述文件，更繁琐也更全面</p>

<h4 id="toc_24">25. 什么情况下会造成跨域</h4>

<ol>
<li>不同协议，如 http 和 https</li>
<li>不同域名，子域名和主域名不同都会跨域</li>
<li>不同端口</li>
</ol>

<h4 id="toc_25">26. 跨域请求解决方案有什么</h4>

<ol>
<li>jsonp。利用 script 标签不受同源策略控制的特点，script 请求一个脚本，这个脚本回调返回 json 数据即可</li>
<li>响应头允许跨域，比如 koa2 的 koa2-cors 包，ng 允许跨域</li>
</ol>

<h4 id="toc_26">27. http 常见的状态码有哪些</h4>

<p><strong>1xx:</strong></p>

<ol>
<li>101 升级请求，如升级成 websocket</li>
</ol>

<p><strong>2xx:</strong></p>

<ol>
<li>200 请求成功</li>
<li>204 请求成功，服务器不需要返回内容</li>
</ol>

<p><strong>3xx:</strong></p>

<ol>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>303 重定向且 post 自动改成 get</li>
<li>304 资源未变更</li>
<li>307 重定向但是 post 不会改成 get</li>
</ol>

<p><strong>4xx:</strong></p>

<ol>
<li>400 客户端错误请求，服务端不能或无法响应。如参数错误等</li>
<li>401 身份未认证</li>
<li>403 禁止访问</li>
<li>404 找不到资源</li>
</ol>

<p><strong>5xx:</strong></p>

<ol>
<li>500 服务器错误</li>
<li>503 服务器超载</li>
</ol>

<h4 id="toc_27">28. http 和 https 有什么区别，哪个更安全，为什么</h4>

<p>https 是在应用层（http）和传输层（tcp）之间加多了 TLS/SSL 认证，加密传输保证数据安全性，更安全。具体看 <code>问题 48</code></p>

<h4 id="toc_28">29. 发起 http 请求之后，经历了什么</h4>

<ol>
<li>解析 dns</li>
<li>三次握手建立 TCP/IP 连接</li>
<li>如果有 tls/ssl，再建立 tls 连接</li>
<li>如果有 websocket，再升级协议</li>
<li>查看是否有缓存，返回 200 或 304</li>
<li>请求 css，js，图片等静态资源</li>
<li>渲染树</li>
<li>合成层</li>
</ol>

<h4 id="toc_29">30. 防抖和节流有什么差别</h4>

<p>防抖顾名思义防止抖动，也是说在一定时间内多次触发就会被认为是“抖动导致的误触”，防抖的解决方案是取消这个事件，不去执行，直到两个事件之间间隔大于约定的时间间隔，才认为这不是“抖动”误触</p>

<p>节流是指频繁触发的时候也不会取消掉你的动作，只是减缓触发的频率，比如规定两个事件之间最小执行间隔是多少 ms</p>

<p>以频繁点击一个按钮为例，时间单位都是 100ms，用户疯狂点击 1s。防抖的策略就是，如果两次点击的时间间隔小于 100ms，那就取消掉事件，用户疯狂点击 1s 其实只会触发一次事件（都被取消了）。截流的策略是每间 100ms 才执行一次事件，不管用户点的多疯狂</p>

<h4 id="toc_30">31. 手写防抖</h4>

<pre><code class="language-javascript">const debounce = (func, wait, immediate, ...args) =&gt; {
  let timeout = null
  return function() {
    const ctx = this
    if (timeout) clearTimeout(timeout)
    if (immediate) {
      const callNow = !timeout
      timeout = setTimeout(() =&gt; {timeout = null}, wait)if (callNow) func.apply(ctx, args)
    } else {timeout = setTimeout(() =&gt; {func.apply(ctx, args)
      }, wait)}}
}
</code></pre>

<h4 id="toc_31">32. 手写节流</h4>

<pre><code class="language-javascript">const throttle = (func, wait, immediate, ...args) =&gt; {
  if (immediate) {
    let pre = 0
    return function () {
      const now = +new Date()
      if (now - pre &gt; wait) {
        func.apply(this, args)
        pre = now
      }
    }
  } else {
    let timeout = null
    return function () {
      const ctx = this
      if (!timeout) {
        timeout = setTimeout(() =&gt; {
          func.apply(ctx, args)
          timeout = null
        }, wait)
      }
    }
  }
}
</code></pre>

<h4 id="toc_32">33. 解释一下 CDN 原理</h4>

<p>现在的传输模型大多都是 TCP/IP 四层模型，这个模型在实际应用中会有一些限制，导致客户端和服务端之间的数据传输会有延迟。</p>

<p>比如物理层上，光速是有限的，传输再快也会受到实际距离位置的影响，而且信道是有限，也不可能无限超大带宽传输。协议上也会有握手过程，网络波动，甚至 http 的丢包、拥塞等。</p>

<p>所以就有了 CDN 的概念，在多个不同地区分布多个节点，客户端访问的是距离自己最近的 CDN 节点，而不是访问实际服务器，因为服务器可能里客户端很远。</p>

<p>然后 CDN 和客户端之间建立一套回源机制，CDN 缓存客户端的资源，如果命中缓存就从 CDN 返回，没有命中缓存（实际服务端资源更新）就回源刷新最新资源。此外 CDN 内部还会有 TCP 的优化，静态资源优化等。</p>

<p>CDN 的原理就是接管 DNS 的解析，CDN 负载均衡的服务器判断用户距离哪里近，DNS 就解析到哪个 CDN 服务上。</p>

<h4 id="toc_33">34. 常见的浏览器缓存及其优先级</h4>

<ol>
<li>Memory Cache / Dist Cache</li>
<li>Service Worker Cache</li>
<li>HTTP Cache</li>
<li>Push Cache<br/>
&gt; Push Cache 是 http2 中 Server Push 的能力。服务器在接到客户端请求时，http2 中允许主动推送下一个需要的资源给客户端，即 Serbver Push。但是有的时候可能 Push 过一次了，没必要浪费流量继续 Push 一样的东西给客户端，这时候 Push Cache 就生效了，如果存在 Push Cache，那就不会重复 Server Push</li>
</ol>

<h4 id="toc_34">35. 什么是中间人攻击，https 可以完全抵御中间人攻击吗</h4>

<p>中间人攻击就是中间服务器在客户端和服务端之间与双方各自建立连接，以达到劫持数据包甚至篡改数据包的目的。<a href="https://www.cnblogs.com/lulianqi/p/10558719.html">https 并不能完全抵御中间人攻击，</a>这取决于客户端和服务端有没有严格遵循 TLS 证书校验规范。</p>

<p>假设我们有：</p>

<ol>
<li>一台 ng 服务器</li>
<li>一个域名 a</li>
<li>和域名 a 匹配的 TLS 证书</li>
</ol>

<p>这时候我们就可以发起攻击了：</p>

<ol>
<li>首先搭好 ng 服务器，配置好域名和相关 TLS 证书</li>
<li>利用 Fiddler 做代理，公开一个 wifi，并且将所有的 TLS 握手申请转发到我们的 ng 服务器</li>
<li>这时候客户端连接公开的 wifi，并且访问域名 b，尝试与域名 b 建立 TLS/SSL 通道</li>
<li>Fiddler 将申请转发到我们的 ng，如果客户端没有遵循证书校验，那么将和我们的服务器握手成功</li>
<li>这时候我们的 ng 就已经是一个中间人了，他可以监听所有的数据包，监听所有的流量。如果什么都不做直接将请求转发到服务器 b，那就仅仅监控数据包。也可以篡改数据，达到主动攻击的目的</li>
</ol>

<blockquote>
<p>像 Chrome 这样的客户端一般都是严格遵循证书校验的，首先检查颁发证书的机构是否合法，然后检查证书吊销凭证列表，检查证书是否过期，检查证书的域名和目标域名是否一致。如果严格遵循证书校验，会发现证书域名 a 和目标域名 b 不匹配，中间人攻击是不会生效的</p>
</blockquote>

<h4 id="toc_35">36. 什么是 http2，为什么要用 http2</h4>

<p>http2 有几个改动:</p>

<ol>
<li>传输数据由明文传输改成二进制流传输</li>
<li>数据传输采用多路复用，请求合并在同一 TCP 连接内，解决队头阻塞的问题</li>
<li>支持服务端推送</li>
<li>使用 HPACK 算法来压缩首部内容</li>
</ol>

<p>优势：</p>

<ol>
<li><p>因为改成二进制用流来传输，那就可以只需要开启一个 tcp 连接，然后把 http1.1 的每个 tcp / ip 连接当成一个流，在一个 tcp 连接中就能传输多路数据，而不需要开启额外的 tcp 连接</p>
<blockquote>
<p>开启 tcp 连接需要 dns 解析，握手等，每开启一个连接都很耗时。再加上大多数浏览器限制并行的 tcp 连接数为 6 个，导致过多的 tcp 会被阻塞掉。http2 就不用担心，大胆分散资源，也不用什么雪碧图，合并 js 了</p>
</blockquote></li>
<li><p>对于 http1.1 来说，每个请求都是一个 tcp 连接，如果要断开连接，就要在传输层断开 tcp / ip 连接，再连接回来就又要握手，也是比较耗时。http2 每个请求都是一个流，只在一个 tcp 连接中，要断开某个连接只要把这个请求流干掉就行了</p></li>
<li><p>服务端推送也能让服务端不再被动，能主动 push 一些必要资源。首部压缩也能节省流量提高请求速度</p></li>
</ol>

<h4 id="toc_36">37. 从输入 url 到渲染完成发生了什么</h4>

<ol>
<li>首先查询 dns，找到目标主机<br/>
&gt; 先查询本地的 dns，再找路由的 dns，如果还是没有，则去 dns 解析服务商一个个递归找</li>
<li>找到服务端 ip 之后，开始尝试与目标机建立 TCP 连接，这时候发起 3 次握手</li>
<li>如果是 https，这时候会尝试 TLS 握手</li>
<li>握手成功之后建立连接，客户端发送请求。如果命中强缓存，返回缓存；如果命中 service worker，返回缓存，否则发送 http request。服务端接收请求后判断是否命中协商缓存，如果命中就返回缓存，没命中就返回最新资源</li>
<li>接着客户端拿到 html，开始解析 html 并且请求 link 和 script。在解析 html 的过程中，如果遇到不带 defer 或 async 的 script 时，会停止解析 dom，等待 js 请求（如果没请求完）和执行，然后渲染一次 dom</li>
<li>读完 html 生成 dom，读完 css 和 link 生成 cssom，结合生成渲染树，然后绘制。如果有动画或者视频等频繁刷新帧率的元素，就会把他们分别独立到一个合成层中</li>
<li>html 解析并且渲染完毕，触发 DOMContentLoad 事件，也就是 performance 中的 domContentLoadedEventEnd 时间点</li>
<li>然后继续执行脚本中的 ajax，图片请求等，全部加载完后触发 onload 事件，也就是 performance 中的 domComplete 时间点</li>
</ol>

<h4 id="toc_37">38. load 和 DOMContentLoaded 的区别</h4>

<p>load 是浏览器所有资源请求完成（包括 ajax 和异步图片）并且 js 执行完成的时候的时间节点，即准备触发 onload 事件的事件节点。对应的是 performance api 中的 domComplete 时间点。</p>

<blockquote>
<p>load 之后紧接着是开始执行 onload 事件的回调，onload 回调执行完之后对应的是 performance loadEventEnd 时间点</p>
</blockquote>

<p>DOMContentLoaded 是浏览器解析完 html 文档，并且 html 文档中嵌入的 link 和 script 标签都加载并执行完毕之后的时间点。对应的是 performance api 中的 domContentLoadedEventEnd 时间点，这也是 domReady 的时间点</p>

<blockquote>
<p>这时候不包括 js 发起的 ajax 请求，也不包括 js 中请求的静态资源如图片等</p>
</blockquote>

<h4 id="toc_38">39. CSS 会阻塞 DOM 解析吗</h4>

<p>CSS 不会阻塞 DOM 解析。但是如果 CSS 后紧跟着 script 标签，那么会产生“阻塞”的效果。因为 js 会阻塞 DOM 的解析，而 CSS 后跟着 JS，JS 会等待 CSSOM 构建完成再执行（如果 CSSOM 构建 js 又同时执行会出现问题，js 拥有修改 DOM 的能力）</p>

<h4 id="toc_39">40. udp 和 tcp 有什么区别，他们位于网络模型中的哪一层</h4>

<p>tcp 和 udp 都是传输层的协议，区别是 tcp 是有连接的，udp 是无连接的。</p>

<ol>
<li>tcp 是可靠连接，连接时要握手相互确认，保证数据正确性和传输顺序。</li>
<li>udp 是无连接的协议，它只管一股脑把数据包扔出去，丢没丢包他不管。</li>
</ol>

<blockquote>
<p>ping 一个主机的时候其实就是往这个主机发 udp 包，像一些直播，游戏等实时性要求高的应用场景，基本都是 udp，tcp 如果丢包会等待重新发包，实时性应用等不起</p>
</blockquote>

<h4 id="toc_40">41. dns 是 udp 还是 tcp，为什么</h4>

<p>dns 是 udp，因为确定 dns 不需要有序也不需要可靠，这和 ping 的原理类似，反正一股脑把数据包甩出去，谁响应了谁就是 dns 的 ip</p>

<h4 id="toc_41">42. udp 的优劣势和常用的情形</h4>

<p>直播，游戏，dns 解析等，都是 udp</p>

<h4 id="toc_42">43. 描述一下三次握手和四次挥手</h4>

<p><strong>三次握手:</strong></p>

<ol>
<li>客户端发送 SYN（建立联机）包，SYN 位码为 1，并且携带随机数 i 发送至目标服务器，目标服务器通过 SYN 位码 1 知道客户端请求建立联机。这时客户端进入 SYN-SENT 状态</li>
<li>服务器发送 SYN + ACK（确认）包，SYN 携带生成的随机数 j，ACK 位码为 1，且携带由客户端来的随机数 i+1 的数据。客户端收到 SYN + ACK 包，检查 ack 包数据是否正确（也就是和自己发出的 i，再加一的值是否匹配）然后检查 ACK 位码是否为 1，1 表示服务器请求建立链接。服务器进入 SYN_RECV 状态。</li>
<li>客户端发送 ACK 包，携带由服务器来的随机数 j+1 的数据，然后服务器收到 ACK 包后确认携带的数据是不是 j+1 确认无误客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</li>
</ol>

<p><strong>四次挥手:</strong></p>

<ol>
<li>客户端认为数据发送已完成，就发一个 FIN 包给服务端，携带随机数 i，进入 FIN_WAIT 第一阶段</li>
<li>服务端接收到 FIN 包，就发送一个 ACK 包确认收到，携带随机数 i+1。此时客户端 -&gt; 服务端的连接释放，但是 TCP 是双向的，此时服务端还是可以发送数据给客户端的（服务端可能还有响应没处理完，暂时不能断开服务端到客户端的连接）客户端收到 ACK 后进入 FIN_WAIT 第二阶段</li>
<li>服务端确认响应已经发送完毕，发送 FIN 包，携带随机数 j，关闭服务端 -&gt; 客户端的数据通道</li>
<li>客户端收到 FIN 包且认证后，发送 ACK 包，确认关闭，自身进入 CLOSE 阶段，服务端收到 ACK 后也进入 CLOSE 阶段</li>
</ol>

<h4 id="toc_43">44. 什么是 SYN 攻击</h4>

<p>SYN 攻击也叫做洪水攻击</p>

<p>在 TCP 连接的过程中，服务端是需要等待客户端的 ACK 确认包的。如果客户端收到服务端的 SYN 包但是又不回 ACK 包，服务端就会等待这个连接。SYN 攻击就是利用这一点，不断向服务端请求连接却又不发送 ACK 包确认，导致服务端等待多个 ACK 包的确认，从而服务器压力增大，导致崩溃</p>

<p>要防止 SYN 可以减少每个 TCP 连接的等待时常，在达到多个 TCP 连接上限后，又有新的请求连接进来，就主动放弃掉那些超时的连接</p>

<h4 id="toc_44">45. get 和 post 的区别</h4>

<ol>
<li>post 相对 get 来说稍微安全一点点，参数不会暴露在 url 中，但是对于抓包来说都是一样的</li>
<li>get 最重要是能够被缓存，如 sw 能缓存整个 get 响应，而 post 请求就不可以缓存</li>
</ol>

<h4 id="toc_45">46. 什么是 TLS，SSL 和 TLS 的差别</h4>

<p>TLS 和 SSL 一样都是一种数据加密协议。SSL 因为有一些安全漏洞，所以被 TLS 给代替了。需要注意的是我们常说的 TLS 和 SSL 认证证书其实和协议本身没关系，证书只是证明使用协议的两端的安全性，并没有说必须对应什么加密协议</p>

<h4 id="toc_46">47. 什么是非对称加密</h4>

<p>非对称加密有公钥和密钥之分。公钥可以分发给所有用户，私钥只有分发者手上才有。大家都可以用公钥加密数据，但是要解密只能用私钥</p>

<h4 id="toc_47">48. SSL/TLS 握手过程</h4>

<ol>
<li>客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息（也就是告诉服务端，客户端支持的加密方式和加密协议）</li>
<li>服务端确认客户端所需的加密方式，自己生成一个随机数 Random2 回给客户端，并且下发证书告诉客户端，证书中带有公钥</li>
<li>客户端收到证书后，先从 CA 验证证书的安全性，然后生成一个随机数 Random3，然后从证书中取出公钥，加密这个随机数并发送给服务端（如果服务端要求客户端也要证书，那这里还会带上客户端的证书）</li>
<li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值（Random1，2，3），可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li>
</ol>

<p><strong>因为非对称加密解密的消耗比较大，所以只在 TLS 握手的时候用非对称加密密钥传输，之后的正文传输都用密钥来对称加密传输</strong></p>

<h4 id="toc_48">49. 开启 CSS 硬件加速和独立复合层</h4>

<p>可以利用一些动画效果来开启 CSS 硬件加速，也就是 GPU 加速，利用浏览器的 GPU 进程启用硬件层面的加速。加速之后的元素会被扔进独立的复合层（合成层）进行渲染，这是一个独立的层级，不受文档流重绘回流的影响，进而提升性能。</p>

<p>CSS3 中的 will-change 就是来开启硬件加速的</p>

<blockquote>
<p>但是要注意不要随便开 GPU 加速，因为如果大量的元素都硬件加速，各自开启各自的合成层，最终会导致页面上有大量的独立合成层，反而会降低性能</p>
</blockquote>

<h4 id="toc_49">50. 什么是预渲染，什么是 ssr</h4>

<p>ssr 即服务端渲染，预渲染和服务端渲染最本质的区别就是：前者是浏览器访问前，服务端就渲染好静态的 html。后者是浏览器访问时，服务器动态输出 html（一般是由 js 虚拟 dom 完成的）</p>

<ol>
<li>预渲染是在构建阶段都确定了输出的 html，其实就是打包完之后开一个无界面浏览器（比如 phantomjs）然后用爬虫爬一遍，生成静态的 html。客户端访问的时候其实已经有 html 结构了，直接返回</li>
<li>ssr 是在用户访问的时候利用虚拟 dom 之类的方案动态生成 html，然后把带有内容节点的 html 返回给前端，不用前端再去请求一大堆框架和渲染相关的 js</li>
<li>如果是有频繁交互的（比如电商）就需要 ssr，如果仅仅是为了 SEO 或者做个静态首页，预渲染更合适</li>
</ol>

<blockquote>
<p>预渲染插件: prerender-spa-plugin</p>
</blockquote>

<h4 id="toc_50">51. 如何实现一个骨架屏</h4>

<p>生成骨架屏有很多种方案，可以为每个页面手写一份骨架屏样式，也可以用 ssr 在请求的时候注入骨架屏，或者在构建的时候利用预渲染等能力塞一份骨架屏</p>

<p>比较好的方式是最后一种，思路大致是:</p>

<ol>
<li>build 之前，先打开自己的开发页面，爬虫抓下页面结构，生成对应的骨架屏，然后生成对应的 dom 结构存起来</li>
<li>开始 build，webpack 打包，在打包结束的时候，把存起来的 dom 塞到 html 里面</li>
</ol>

<blockquote>
<p>相关插件: vue-skeleton-webpack-plugin</p>
</blockquote>

<h4 id="toc_51">52. 既然 TCP 有长连接，为什么还要在应用层的 http 上做心跳保活？</h4>

<p>在 http1.1 中，TCP 的确有 keep-alive 的机制，也就是长连接。</p>

<p>但是 TCP 是传输层的有连接的协议，一旦建立起连接之后，如果某一断不主动断开连接（四次挥手）那么 TCP 将是一直连着的（即使网络挂了，双方在发送包也是不知道彼此挂了的）</p>

<blockquote>
<p>TCP 长连接会每 7200s 发起一次探针来检测对方是否还有响应。如果响应超时，会再发探针，累计 10 次超时则终端连接。假设一个场景，网络非常不好，早就断连了，但是 TCP 还没到 7200s 的间隔，还没去发探针，那么通信双方其实都不知道对方挂了</p>
</blockquote>

<p>此外一些高负载的情况下，如果服务器无响应或者挂起假死了，本应该告诉客户断连接中断了，但是 TCP 还没达到发探针的时机，那也会造成客户端的误判。所以需要在应用层主动发心跳测试保活</p>

<h4 id="toc_52">53. 如何定位内存泄漏</h4>

<p>JS 引用类型会在内存开辟堆空间，这个空间在没有引用的时候（指针为空或者离开作用域导致函数执行栈弹出，被销毁）会被垃圾回收机制给回收销毁</p>

<p>内存泄漏就是指某个内存堆空间的引用类型已经没有用了，但是因为各种原因垃圾回收机制没有去销毁它</p>

<p>比如：</p>

<ol>
<li>闭包导致的保存了封闭环境内的变量，导致内存泄漏</li>
<li>没有用声明关键字，变量被直接挂载到 window 或者 global 上</li>
<li>定时器没有消除</li>
<li>事件绑定没有消除</li>
</ol>

<p><a href="https://juejin.im/post/5b2fd09ee51d45588576f429">Vue 内存泄漏排查</a></p>

<p><a href="https://zhuanlan.zhihu.com/p/25736931">Node 内存泄漏排查</a></p>

<p><a href="https://cnodejs.org/topic/58eb5d378cda07442731569f">Node 内存泄漏排查</a></p>

<h4 id="toc_53">54. <a href="https://zhuanlan.zhihu.com/p/32553477">什么是 http3</a></h4>

<p>http2 虽然采用了流多路复用的方式传输，但说到底还是 tcp，tcp 本质上还是有序的。而且在网络不好的时候 http2 甚至不如 http1.1，因为全部依赖一个 tcp，这个 tcp 挂了就全挂了。</p>

<p>http3 前身是 quic，采用了 udp 的传输而不是 tcp 的传输，从根本上解决了多路复用的问题。而且 http3 有缓存会话，丢包容错的功能</p>

<ol>
<li>减少了 TCP 三次握手及 TLS 握手时间。</li>
<li>改进的拥塞控制。</li>
<li>避免队头阻塞的多路复用。</li>
<li>连接迁移。</li>
<li>前向冗余纠错。</li>
</ol>

<blockquote>
<p>http3 每个数据包都包含其他包的一部分，当某个包丢包了，能从其他包中找到丢失的部分拼凑起来</p>
</blockquote>

<h4 id="toc_54">55. webpack 的预加载，懒加载，prefetch，preload</h4>

<p>prefetch 指的是当浏览器空闲时预先加载</p>

<p>preload 指的是关键资源提前加载</p>

<p>webpack 可以通过 prefetch 魔法注释声明预加载，通过 import 动态引入的方式实现懒加载。</p>

<h4 id="toc_55">56. dns 递归查询和迭代查询有什么区别</h4>

<p>主机向本地 dns 服务器查询是递归查询。当向本地 dns 服务器查询时，如果查不到 IP，本地 dns 服务器就会以客户端的身份代替主机向根服务器查询，这种方式叫做递归查询</p>

<p>本地 dns 服务器向根服务器的查询是迭代查询。当本地 dns 服务器向根服务器查询查不到结果时，根服务器会告知本地 dns 服务器继续去某个根服务器查询，这种查询方式叫做迭代查询</p>

<h4 id="toc_56">57. 127.0.0.1 和 0.0.0.0 和 localhost 的差别</h4>

<p>127.0.0.1 是回环地址，指的是本地的虚拟端口，不属于任何一个有类别地址类，指的是本地电脑本身</p>

<p>0.0.0.0 指的是本机上的所有 IPV4 地址，如果一个主机有两个 IP 地址，192.168.1.1 和 10.1.2.1，那这两个地址都能访问 0.0.0.0 端口的服务</p>

<p>loaclhost 是域名，指向 127.0.0.1</p>

<h4 id="toc_57">58. 301，302，303，307 有什么区别</h4>

<p>301 永久重定向，302 临时重定向。对于 post 等非幂等的方法来说，是不能重定向的。所以 301 和 302 会把 post 转成 get 请求</p>

<p>后来规范了 303，就是默认允许重定向将 post 转成 get</p>

<p>然后更新了 307，就是不会默认转化，会经过客户端的同意</p>

<h4 id="toc_58">59. 什么是简单请求，什么是复杂请求，什么是 options 请求</h4>

<p>简单请求和复杂请求都是对于跨域而言的。如果一个请求是 <code>get/post/head</code> 请求之一并且头信息不复杂（只包含 accept，accept-language，content-language，content-type 也是表单，formdata 或者文本）就是简单请求。其他的情况就是复杂请求</p>

<p>对于简单请求，浏览器会在请求头加一个 origin 字段，用来告诉服务端是否可以跨域。对于复杂请求，浏览器会发起一个 options 的预检信息，预检通过之后才会发正式请求，也是用 origin 判断</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构之图]]></title>
    <link href="https://evanoyam.github.io/16023383038322.html"/>
    <updated>2020-10-10T21:58:23+08:00</updated>
    <id>https://evanoyam.github.io/16023383038322.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="16023382883992.html">数据结构之数组</a></li>
<li><a href="16023382325000.html">数据结构之队列</a></li>
<li><a href="16023382564461.html">数据结构之栈</a></li>
<li><a href="16023381818411.html">数据结构之链表</a></li>
<li><a href="16023382142420.html">数据结构之树</a></li>
<li><p><a href="16023383038322.html">数据结构之图</a></p></li>
</ul>

<ol>
<li>G=(V,E)，G是图，V是一组顶点，E是一组边</li>
<li>相邻顶点指的是由一条边连接的两个顶点</li>
<li>度是相邻顶点的数量</li>
<li>如果不存在环，称之为无环图；如果每两个点都连通，称之为连通图</li>
<li>图有有向图和无向图之分，也可以加权</li>
</ol>

<p>可以用矩阵来表示图的两个点是否连通，用数组存储每个顶点:<br/>
 <img src="https://img.bluepay.asia/upload/manual/20200426/15593945.png" alt="image"/></p>

<p>图还可以用邻接表表示:<br/>
 <img src="https://img.bluepay.asia/upload/manual/20200426/16003282.png" alt="image"/></p>

<p>图的遍历主要有深度优先和广度优先两种方法：</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>数据结构</th>
<th>特性</th>
</tr>
</thead>

<tbody>
<tr>
<td>深度优先搜索</td>
<td>栈</td>
<td>不保留全部节点，有入栈出栈的操作，效率低，占用空间小</td>
</tr>
<tr>
<td>广度优先搜索</td>
<td>队列</td>
<td>保留全部节点，效率高，占用空间大</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构之数组]]></title>
    <link href="https://evanoyam.github.io/16023382883992.html"/>
    <updated>2020-10-10T21:58:08+08:00</updated>
    <id>https://evanoyam.github.io/16023382883992.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="16023382883992.html">数据结构之数组</a></li>
<li><a href="16023382325000.html">数据结构之队列</a></li>
<li><a href="16023382564461.html">数据结构之栈</a></li>
<li><a href="16023381818411.html">数据结构之链表</a></li>
<li><a href="16023382142420.html">数据结构之树</a></li>
<li><a href="16023383038322.html">数据结构之图</a></li>
</ul>

<h2 id="toc_0">一维数组</h2>

<p>数组是最简单的内存数据结构，一般来说存储同种数据类型，不过 js 允许数组存储不同的数据类型</p>

<p>插入元素原理:</p>

<ol>
<li>插入到头部，需要所有元素向后移动一位，然后把新元素赋值给第一个位置</li>
<li>插入到尾部，直接赋值给尾部最后一个元素（在 C 或者 Java 中，因为要定义数组大小，所以添加元素的时候要新建数组，不能扩展原来的数组）</li>
<li>从头部删除，将所有元素向前移动一位，覆盖掉第一个元素，同时让数组长度减一（在 C 或者 Java 这类语言中，如果直接循环，由于最后一个元素是 undefined，无法赋值给倒数第二个元素，会报错）</li>
<li>从尾部删除，直接让数组长度减一，删掉最后一个元素</li>
<li>在任意位置添加或者删除，js 中提供了 splice 方法，原理是定位到需要插入 / 删除的位置，让后续的元素依次后移 / 或者前移覆盖</li>
<li>迭代一维数组，可以用 for…in 迭代器，也可以用 arr.forEach 方法（事实上尽量不要在数组使用 for…of 或者 for…in，虽然可以遍历，但是它们是用于遍历迭代器的，虽然数组自动生成了 arr.values() 迭代器，但是在某些时候并不能自动生成，如二维数组，for…of 二维数组是失效的）</li>
</ol>

<h2 id="toc_1">二维数组</h2>

<p>二维数组实际上就是矩阵，行代表一种属性，列代表一种属性。</p>

<blockquote>
<p>但是在 js 中并不支持二维数组（矩阵），不过可以利用数组的嵌套达到相同的效果，如 <code>arr = [[1, 2, 3], [4, 5, 6]]</code>，那么 <code>arr[0]</code> 代表的就是 <code>[1, 2, 3]</code> 这个数组，<code>arr[0][0]</code> 代表的就是 <code>1</code> 这个数值，实际上相当于矩阵:</p>
</blockquote>

<table>
<thead>
<tr>
<th>行 / 列</th>
<th>0</th>
<th>1</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>6</td>
</tr>
</tbody>
</table>

<blockquote>
<p>迭代二维数组，可以用两个 for…in（注意这里用 for…of 是失效的），也可以用两个 arr.forEach 方法</p>
</blockquote>

<h2 id="toc_2">多维数组</h2>

<p>利用嵌套可以创建多维数组，比如创建一个 3x3x3 的三维矩阵，就是数组三维数组。在数据结构的数组中，不管多少维度，都可以利用循环遍历拿到对应位置的元素。</p>

<h2 id="toc_3">数组排序：</h2>

<p>js 数组自身有 sort 方法，不过 sort 是将元素转换成字符串排序的。为了避免一些错误，一般 sort 传入一个比较函数，如</p>

<pre><code class="language-javascript">arr.sort(function(a,b) {return a-b})
</code></pre>

<h2 id="toc_4">数组搜索</h2>

<ol>
<li>indexOf() 返回匹配元素的下标，如果找不到则返回 -1</li>
<li>findIndex()与 indexOf() 类似，也是返回匹配元素的下标，不过接受的参数是一个回调函数。</li>
<li>find()与 findIndex() 类似，也是接受一个回调函数，不过它返回的不是下标，而是元素本身。相对而言，findIndex()和 find() 用处更广，除了可以返回基础元素组成的数组，也可以返回引用元素组成的数组（如 [{id:1}, {id:2} ]）</li>
</ol>

<h2 id="toc_5">应用与算法</h2>

<ol>
<li>求斐波那契数列第 n 个数以及前 n 个数之和</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构之栈]]></title>
    <link href="https://evanoyam.github.io/16023382564461.html"/>
    <updated>2020-10-10T21:57:36+08:00</updated>
    <id>https://evanoyam.github.io/16023382564461.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="16023382883992.html">数据结构之数组</a></li>
<li><a href="16023382325000.html">数据结构之队列</a></li>
<li><a href="16023382564461.html">数据结构之栈</a></li>
<li><a href="16023381818411.html">数据结构之链表</a></li>
<li><a href="16023382142420.html">数据结构之树</a></li>
<li><a href="16023383038322.html">数据结构之图</a></li>
</ul>

<p>栈是一种后进先出（LIFO）的有序的数据结构，新元素在栈顶，旧元素在栈底。可以利用数组来创建栈。</p>

<blockquote>
<p>栈需要 push（插入栈顶）、pop（移除栈顶）、peek（返回栈顶）、isEmpty（查看栈是否为空）、clear（移除栈所有元素）、size（返回栈元素个数）、print（输出栈所有元素）等方法。</p>
</blockquote>

<pre><code class="language-javascript">function Stack() {let items = []
  this.push = function(elem) {items.push(elem)
  }
  this.pop = function() {return items.pop()
  }
  this.peek = function() {return items[items.length - 1]
  }
  this.isEmpty = function() {return items.length === 0}
  this.clear = function() {items = []
  }
  this.size = function() {return items.length}
  this.print = function() {console.log(items.toString())
  }
}

let stack = new Stack()
</code></pre>

<p>这个 Stack 类声明了一个 items 私有变量，保证外界不能访问到 items（只能由 Stack 函数本身访问，所有实例都不能访问，因为 items 实际上是数组，如果外界能不通过我们定义的方法，直接拿到 items，那么实际上就破坏了栈，能用数组的方法操作 items。类的方法会给每个实例添加 items 副本，如果要创建多个 Stack 实例，无疑是不利于性能的。</p>

<p>利用 ES6 可以创造类，ES6 的类基于原型，虽然比基于函数更节省内存，也更适合创建多个实例，但是所有属性都是声明在类中的 constructor 中，且不能声明私有属性，那无疑对栈的结构产生巨大威胁，外界可以直接读出本质上是数组的 items。</p>

<p>可以利用 WeakMap 结构，结合 ES6 以及闭包，创建既适合创建多个实例，也足够安全（外界无法访问 items 私有变量）的栈：</p>

<pre><code class="language-javascript">let Stack = (function() {
  // 利用闭包，外界无法访问 items
  const items = new WeakMap() //items 是一个 WeakMap 数据结构，不再是数组
  class Stack {constructor() {items.set(this, []) // 将 this（Stack 类本身）映射成一个数组
    }
    push(elem) {let s = items.get(this) // 利用 WeakMap 的 get，拿到映射的值（数组）
      s.push(elem)
    }
    pop() {let s = items.get(this)
      return s.pop() }
    peek() {let s = items.get(this)
      return s[s.length - 1]
    }
    isEmpty() {let s = items.get(this)
      return s.length === 0
    }
    clear() {items.set(this, [])
    }
    size() {let s = items.get(this)
      return s.length
    }
    print() {let s = items.get(this)
      console.log(s.toString())
    }
  }
  return Stack // 当构造函数被调用，返回一个类的实例
})()let stack = new Stack()
</code></pre>

<h2 id="toc_0">应用与算法</h2>

<ol>
<li>回溯问题，如存储访问过的任务或路径，撤销的操作等。在 JAVA 和 C# 中用栈来存储变量和方法调用。</li>
<li>进制转换问题</li>
<li>平衡圆括号问题</li>
<li>汉诺塔问题</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构之队列]]></title>
    <link href="https://evanoyam.github.io/16023382325000.html"/>
    <updated>2020-10-10T21:57:12+08:00</updated>
    <id>https://evanoyam.github.io/16023382325000.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="16023382883992.html">数据结构之数组</a></li>
<li><a href="16023382325000.html">数据结构之队列</a></li>
<li><a href="16023382564461.html">数据结构之栈</a></li>
<li><a href="16023381818411.html">数据结构之链表</a></li>
<li><a href="16023382142420.html">数据结构之树</a></li>
<li><a href="16023383038322.html">数据结构之图</a></li>
</ul>

<p>队列是一种先来先服务，先进先出（FIFO）的数据结构。日常中排队就是最常见的队列。在计算机科学中，打印队列就是一种很常见的队列。</p>

<blockquote>
<p>与创建栈类似，可以利用数组来创建队列，需要 enqueue（入列），dequeue（出列），front（返回队顶），isEmpty（是否为空），size（长度），print（打印）等方法。</p>
</blockquote>

<pre><code class="language-javascript">function Queue() {let items = []
  this.enqueue = function(elem) {items.push(elem)
  }
  this.dequeue = function() {return items.shift()
  }
  this.front = function() {return items[0]
  }
  this.isEmpty = function() {return items.length === 0}
  this.size = function() {return items.length}
  this.print = function() {console.log(items.toString())
  }
}
</code></pre>

<p>以构造函数式声明类，与栈有相同的问题，虽然可以保证私有变量，但是当创建多个实例，类也会创建多个 items 副本，这样的情况下，无疑对性能损耗十分大。可以利用闭包，ES6 和 WeakMap 封装成一个高效且有私有变量 items 的队列类。注意声明的闭包切记 return Queue 的类，不然会报错 Queue not a constructor。</p>

<pre><code class="language-javascript">let Queue = (function() {const items = new WeakMap()
  class Queue {constructor() {items.set(this, [])
    }
    enqueue(elem) {let queue = items.get(this)
      queue.push(elem)
    }
    dequeue() {let queue = items.get(this)
      return queue.shift() }
    front() {let queue = items.get(this)
      return queue[0]
    }
    isEmpty() {let queue = items.get(this)
      return queue.length === 0
    }
    size() {let queue = items.get(this)
      return queue.length
    }
    print() {let queue = items.get(this)
      console.log(queue.toString())
    }
  }
  return Queue
})()
</code></pre>

<h2 id="toc_0">优先队列</h2>

<p>类似医院急诊，或者登机头等舱等，队列有时也需要分队列等级，优先处理的队列叫做优先队列。可以这么理解，队列中有若干元素，而不同等级的元素扎堆，按等级形成不同等级的优先队列，如默认队列 <code>[1,2,3,4,5,6,7]</code>，根据优先级排列后，可以理解成 <code>[[1,2,5][3,4][6,7]]</code>。同一优先级按照 FIFO 原则。定义这类队列与传统队列不同的地方在于，在插入队列元素的时候，还要传一个代表优先级的参数，判断当前插入元素的优先级。</p>

<pre><code class="language-javascript">function PriorityQueue() {let items = [] // 私有变量 items，保证外界不能直接访问
  function QueueElement(elem, priority) {
    // 创建一个构造函数，每次插入就生成等待队列
    this.elem = elem
    this.priority = priority
  }
  this.enqueue = function(elem, priority) {
    // 优先队列的核心，插入方法
    let queueElement = new QueueElement(elem, priority) // 每次插入都生成等待队列的实例
    let added = false // 初始化已插入状态
    for (let i in items) {
      // 遍历 items 中的元素
      // 如果待插入元素的优先级高于（优先级数值越小，优先等级越高）items 中元素的优先级，则插入在 items 中原有的元素之前，同时将已插入状态（added）修改成 true
      if (queueElement.priority &lt; items[i].priority) {items.splice(i, 0, queueElement)
        added = true
        break
      }
    }
    // 如果待插入元素的优先级比所有的 items 都小，那么就直接插入队列即可
    if (!added) {items.push(queueElement)
    }
  }
  this.dequeue = function() {return items.shift()
  }
  this.front = function() {return items[0]
  }
  this.isEmpty = function() {return items.length === 0}
  this.size = function() {return items.length}
  this.print = function() {for (let i in items) {console.log(`${items[i].elem} - ${items[i].priority}`)}}
}
</code></pre>

<p>封装成 ES6:</p>

<pre><code class="language-javascript">let PriorityQueue = (function() {const items = new WeakMap()
  class QueueElement {constructor(elem, priority) {
      this.elem = elem
      this.priority = priority
    }
  }
  class Queue {constructor() {items.set(this, [])
    }
    enqueue(elem, priority) {let queueElement = new QueueElement(elem, priority)
      let added = false
      let queue = items.get(this)
      for (let i in queue) {if (queueElement.priority &lt; queue[i].priority) {queue.splice(i, 0, queueElement)
          added = true
          break
        }
      }
      if (!added) {queue.push(queueElement)
      }
    }
    dequeue() {let queue = items.get(this)
      return queue.shift() }
    front() {let queue = items.get(this)
      return queue[0]
    }
    isEmpty() {let queue = items.get(this)
      return queue.length === 0
    }
    size() {let queue = items.get(this)
      return queue.length
    }
    print() {let queue = items.get(this)
      for (let i in queue) {console.log(`${queue[i].elem} - ${queue[i].priority}`)}}
  }
  return Queue
})()
</code></pre>

<h2 id="toc_1">循环队列</h2>

<p>队列还有一种特殊形态，最常见的循环队列就是击鼓传花（传递热土豆）：</p>

<pre><code class="language-javascript">function hotPotato(nameList, num) {let queue = new Queue() // 声明一个队列
  for (let i in nameList) {queue.enqueue(nameList[i]) // 元素插入队列
  }
  let eliminated = &#39;&#39; // 初始化淘汰者
  while (queue.size() &gt; 1) {
    // 若队列元素（人数）不止一个
    for (let i = 0; i &lt; num; i++) {
      // 模拟鼓声停止之前，第一个人（拿着热土豆）把土豆传给下一个（也就是等价于自己排到队列最后了，所以自己出队列，插入队列最后）
      queue.enqueue(queue.dequeue())
    }
    eliminated = queue.dequeue() // 鼓声停止，第一个人淘汰（拿着热土豆）
    console.log(`${eliminated} 在游戏中被淘汰 `) }
  return ` 胜利者：${queue.dequeue()}` // 所有人出队列，最后的人胜出
}
</code></pre>

<blockquote>
<p>此外，js 的任务处理也是队列，当浏览器打开新标签时，就会创建一个任务队列，因为每个标签都是单线程，所以这个标签内的所有事件（包括渲染 HTML，执行 js 脚本，io 处理，交互，http 请求，ajax 网络请求等）都会进入一个待处理队列，一项一项进行。这被称为事件循环。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构之树]]></title>
    <link href="https://evanoyam.github.io/16023382142420.html"/>
    <updated>2020-10-10T21:56:54+08:00</updated>
    <id>https://evanoyam.github.io/16023382142420.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="16023382883992.html">数据结构之数组</a></li>
<li><a href="16023382325000.html">数据结构之队列</a></li>
<li><a href="16023382564461.html">数据结构之栈</a></li>
<li><a href="16023381818411.html">数据结构之链表</a></li>
<li><a href="16023382142420.html">数据结构之树</a></li>
<li><a href="16023383038322.html">数据结构之图</a></li>
</ul>

<h2 id="toc_0">基础概念</h2>

<ol>
<li>树是一种非顺序数据结构</li>
<li>根节点是没有父节点的节点</li>
<li>一个节点允许有祖先和后代</li>
<li>节点的深度 = 祖先节点的个数 = 自身层数-1</li>
</ol>

<blockquote>
<p>通常我们指的树是二叉搜索树，这种树的特性是每个节点都只有两个子节点，且左子节点比父节点小，右子节点比父节点大。这种特性有助于我们在树中插入、删除和查找元素</p>
</blockquote>

<h2 id="toc_1">JavaScript 构建一颗树</h2>

<p><strong>树的类有以下实例方法:</strong></p>

<ol>
<li>insert 插入节点</li>
<li>preOrderTraverse 先序遍历</li>
<li>inOrderTraverse 中序遍历</li>
<li>postOrderTraverse 后序遍历</li>
<li>min 查找并返回最小节点</li>
<li>max 查找并返回最大节点</li>
<li>has 查找树是否有某个节点</li>
<li>delete 移除节点</li>
</ol>

<p><strong>树的类有以下静态方法:</strong></p>

<ol>
<li>createNode 创建一个节点</li>
<li>traverse 遍历一棵树</li>
<li>minNode 查找一颗树的最小节点</li>
<li>maxNode 查找一颗树的最大节点</li>
</ol>

<blockquote>
<p>后面会补充各个方法</p>
</blockquote>

<pre><code class="language-javascript">class BinarySearchTree {
  /**
   * 初始化有一个根节点
   */
  constructor(key) {
    this.root = BinarySearchTree.createNode(key)
  }

  /**
   * 插入节点
   * @param {Number} key 需要插入的节点的值
   */
  insert(key) {}

  /**
   * 先序遍历
   * @param {Function} callback 回调函数
   */
  preOrderTraverse(callback) {}

  /**
   * 中序遍历
   * @param {Function} callback 回调函数
   */
  inOrderTraverse(callback) {}

  /**
   * 后序遍历
   * @param {Function} callback 回调函数
   */
  postOrderTraverse(callback) {}

  /**
   * 查找并返回最小节点
   */
  mix() {}

  /**
   * 查找并返回最大节点
   */
  max() {}

  /**
   * 查找树是否有某个节点
   * @param {Number} key 需要查找的节点的值
   */
  has(key) {}

  /**
   * 移除节点
   * @param {Number} key 需要移除的节点的值
   */
  delete(key) {}

  /**
   * 创建一个节点
   * @param {Number} key 节点的值
   */
  static createNode(key) {}

  /**
   * 静态方法，遍历一棵树
   * @param {Node} root 树的根节点
   * @param {Number} type 遍历类型，1先序遍历，2中序遍历，3后序遍历
   * @param {Function} callback 回调函数，回调函数接受 key，leftKey，rightKey，node四个参数
   */
  static traverse(root, type, callback) {}

  /**
   * 查找一棵树的最小节点
   * @param {Node} root 树的根节点
   */
  static minNode(root) {}

  /**
   * 查找一棵树的最大节点
   * @param {Node} root 树的根节点
   */
  static maxNode(root) {}
}
</code></pre>

<h3 id="toc_2">插入节点</h3>

<p>树的大部分方法的核心都是递归思想，插入节点比较简单，具体看代码注释。</p>

<pre><code class="language-javascript">class BinarySearchTree {
  // ...

  /**
   * 插入节点
   * @param {Number} key 需要插入的节点的值
   */
  insert(key) {
    // 初始化一个节点
    const newNode = BinarySearchTree.createNode(key)

    /**
     * 插入函数
     * @param {Node} curNode 当前节点
     * @param {Node} newNode 需要被插入的节点
     */
    const insertNode = function(curNode, newNode) {
      // 1. 如果要插入的节点比当前节点的值小，插入到当前节点的左边
      // 2. 如果要插入的节点比当前节点的值大，插入到当前节点的右边
      if (newNode.key &lt; curNode.key) {
        // 1. 如果当前节点的左子节点不存在，则新节点就做为左子节点
        // 2. 否则就继续递归下去
        curNode.left === null ? (curNode.left = newNode) : insertNode(curNode.left, newNode)
      } else {
        // 1. 如果当前节点的右子节点不存在，则新节点就做为右子节点
        // 2. 否则就继续递归下去
        curNode.right === null ? (curNode.right = newNode) : insertNode(curNode.right, newNode)
      }
    }

    // 插入
    // 1. 如果插入的是根节点，则根节点为新插入的节点
    // 2. 如果插入的不是根节点，那么就执行插入函数
    this.root.key === null ? (this.root = newNode) : insertNode(this.root, newNode)
  }

  /**
   * 生成一个树节点
   * @param {Number} key 节点的值
   */
  static createNode(key) {
    key = key || null
    function Node(key) {
      this.key = key
      this.left = null
      this.right = null
    }
    return new Node(key)
  }

  // ...
}
</code></pre>

<h3 id="toc_3">树的遍历</h3>

<p>树有三种遍历方式，分别是<strong>先序遍历</strong>，<strong>中序遍历</strong>，和<strong>后序遍历</strong>，无论是哪种遍历，思路都是递归。树的递归都是分左子树和右子树一直递归下去，跳出条件都是直到空为止。</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>应用</th>
</tr>
</thead>

<tbody>
<tr>
<td>先序遍历</td>
<td>祖先到后代遍历，遍历过程是根 -&gt; 左 -&gt; 右</td>
<td>打印文档的结构</td>
</tr>
<tr>
<td>中序遍历</td>
<td>由小到大遍历，遍历过程是左 -&gt; 根 -&gt; 右</td>
<td>树排序</td>
</tr>
<tr>
<td>后序遍历</td>
<td>后代到祖先遍历，遍历过程是左 -&gt; 右 -&gt; 根</td>
<td>计算目录及其子目录大小</td>
</tr>
</tbody>
</table>

<h4 id="toc_4">先序遍历:</h4>

<p>我们先写一个简单的先序遍历，甚至整个函数只需要一行代码即可。</p>

<p>我们的目标是输入一个根节点，输出一个遍历后的数组。我们先来分析一下：</p>

<ol>
<li>整个过程是一个递归，也就是说左右子树如果有值，就递归下去；没有值，则跳出。</li>
<li>如果子树没有值则跳出，而最终输出结果又是数组，即 <code>if(!root) return []</code></li>
<li>如果左右子树有值，那就递归下去，即 <code>preOrderTraverse(root.left)</code> 和 <code>preOrderTraverse(root.right)</code></li>
<li>因为先序遍历是 <code>根 -&gt; 左 -&gt; 右</code> 的遍历顺序，所以递归的每个子树的返回值应该是 <code>[root, left, right]</code> 的顺序</li>
</ol>

<p>组合一下代码:</p>

<pre><code class="language-javascript">const preOrderTraverse = root =&gt; {
  if (root) {
    return [root.key, ...preOrderTraverse(root.left), ...preOrderTraverse(root.right)]
  } else {
    return []
  }
}
</code></pre>

<p>精简成一行:</p>

<pre><code class="language-javascript">/**
 * 简单版先序遍历
 * @param {Node} root 树的根节点
 */
const preOrderTraverse = root =&gt; {
  return root ? [root.key, ...preOrderTraverse(root.left), ...preOrderTraverse(root.right)] : []
}
</code></pre>

<h4 id="toc_5">中序遍历:</h4>

<p>与先序遍历类似，只是返回的顺序不同，中序遍历的顺序是 <code>左 -&gt; 根 -&gt; 右</code></p>

<pre><code class="language-javascript">/**
 * 简单版中序遍历
 * @param {Node} root 树的根节点
 */
const inOrderTraverse = root =&gt; {
  return root ? [...inOrderTraverse(root.left), root.key, ...inOrderTraverse(root.right)] : []
}
</code></pre>

<h4 id="toc_6">后序遍历:</h4>

<p>与先序遍历类似，只是返回的顺序不同，中序遍历的顺序是 <code>左 -&gt; 右 -&gt; 根</code></p>

<pre><code class="language-javascript">/**
 * 简单版中序遍历
 * @param {Node} root 树的根节点
 */
const postOrderTraverse = root =&gt; {
  return root ? [...postOrderTraverse(root.left), ...postOrderTraverse(root.right), root.key] : []
}
</code></pre>

<h4 id="toc_7">带回调的遍历:</h4>

<p>上面的方法已经能满足对一颗树进行遍历并且返回遍历后的值了，但是我们还希望在遍历的过程中对每一个节点都执行一个回调函数。</p>

<blockquote>
<p>正如 <code>[].forEach(item =&gt; {})</code> 一样，遍历到每一项都能执行一个回调。我们希望在树的回调函数中，能拿到当前遍历的值 key，左子树的值 leftKey，右子树的值 rightKey 以及当前节点 node 的相关信息</p>
</blockquote>

<p><strong>注意：</strong> 回调即遍历到当前节点的时候就执行，所以要注意回调和递归之间的执行顺序</p>

<ol>
<li>先序列遍历是 <code>根 -&gt; 左 -&gt; 右</code> 的遍历顺序，也就是说在递归之前就已经遍历到当前节点了，所以回调需要在递归前执行。</li>
<li>中序遍历是 <code>左 -&gt; 根 -&gt; 右</code> 的遍历顺序，也就是说递归了左子树后就遍历到了当前节点，所以回调需要在左子树递归后，右子树递归前执行。</li>
<li>后序遍历是 <code>左 -&gt; 右 -&gt; 根</code> 的遍历顺序，也就是说在左右子树都递归完了才遍历到当前节点，所以回调需要在左右子树递归完之后执行。</li>
</ol>

<p>具体解释请看代码中的注释</p>

<pre><code class="language-javascript">/**
 * 带回调的先序遍历
 * @param {Node} root 树的根节点
 * @param {Function} callback 回调函数，回调函数接受 key，leftKey，rightKey，node四个参数
 */
const preOrderTraverse = (root, callback) =&gt; {
  // 跳出条件与简单版一样，没有值则跳出
  if (!root) return []

  // 定义回调需要的几个值
  // 当前节点 node 即 root，无需定义
  const key = root.key
  const leftKey = root.left ? root.left.key : null
  const rightKey = root.right ? root.right.key : null

  // 因为是先序遍历，回调需要在递归前执行
  callback(key, leftKey, rightKey, root) // *1
  // 左子树递归
  const preLeft = BinarySearchTree.traverse(root.left, type, callback) // *2
  // 右子树递归
  const preRight = BinarySearchTree.traverse(root.right, type, callback) // *3
  // 和简单版一样，返回 根 -&gt; 左 -&gt; 右 的遍历顺序
  return [root.key, ...preLeft, ...preRight] // *4
}
</code></pre>

<blockquote>
<p>带回调的中序遍历，带回调的后序遍历与上面的代码类似，只是 <code>*1，*2，*3</code> 三行代码的顺序不同罢了。此外 <code>*4</code> 返回的顺序也不同</p>
</blockquote>

<h4 id="toc_8">整合后的遍历:</h4>

<p>我们把上述的遍历整合一下，写到树的类中。</p>

<ol>
<li>我们希望树的类有先序遍历，中序遍历，后序遍历的实例方法，可以通过 <code>tree.preOrderTraverse(callback)</code> 来遍历一棵树，并且支持回调函数。</li>
<li>树的类还能提供一个静态的遍历方法，可以通过 <code>BinarySearchTree.traverse(root, type, callback)</code> 的方式来遍历一棵树，接收三个参数，root 是树的根节点，type 是遍历方法，callback 是回调函数</li>
</ol>

<pre><code class="language-javascript">class BinarySearchTree {
  // ...
  // 实例的方法都很简单，其实就是执行静态遍历方法 traverse

  /**
   * 先序遍历
   * @param {Function} callback 回调函数
   */
  preOrderTraverse(callback) {
    return BinarySearchTree.traverse(this.root, 1, callback)
  }

  /**
   * 中序遍历
   * @param {Function} callback 回调函数
   */
  inOrderTraverse(callback) {
    return BinarySearchTree.traverse(this.root, 2, callback)
  }

  /**
   * 后序遍历
   * @param {Function} callback 回调函数
   */
  postOrderTraverse(callback) {
    return BinarySearchTree.traverse(this.root, 3, callback)
  }

  /**
   * 静态遍历方法
   * @param {Node} root 树的根节点
   * @param {Number} type 遍历类型，1先序遍历，2中序遍历，3后序遍历
   * @param {Function} callback 回调函数，回调函数接受 key，leftKey，rightKey，node四个参数
   */
  static traverse(root, type, callback) {
    // 这里与上文中 “带回调的遍历” 是一样的
    if (!root) return []
    const key = root.key
    const leftKey = root.left ? root.left.key : null
    const rightKey = root.right ? root.right.key : null

    // 根据不同的遍历类型，进行不同的遍历，注意回调与递归之间的执行顺序，以及不同遍历返回的排序也不同
    switch (type) {
      // 先序遍历
      case 1:
        callback(key, leftKey, rightKey, root)
        const preLeft = BinarySearchTree.traverse(root.left, type, callback)
        const preRight = BinarySearchTree.traverse(root.right, type, callback)
        return [root.key, ...preLeft, ...preRight]
      // 中序遍历
      case 2:
        const inLeft = BinarySearchTree.traverse(root.left, type, callback)
        callback(key, leftKey, rightKey, root)
        const inRight = BinarySearchTree.traverse(root.right, type, callback)
        return [...inLeft, root.key, ...inRight]
      // 后序遍历
      case 3:
        const postLeft = BinarySearchTree.traverse(root.left, type, callback)
        const postRight = BinarySearchTree.traverse(root.right, type, callback)
        callback(key, leftKey, rightKey, root)
        return [...postLeft, ...postRight, root.key]
      default:
        break
    }
  }

  // ...
}
</code></pre>

<h3 id="toc_9">树的查询</h3>

<p>二叉树有个特点，那就是最左边的节点肯定是最小值，最右边的节点肯定是最大值。根据这个特性我们可以很轻松找出树的最大值和最小值。</p>

<h4 id="toc_10">树的最小值</h4>

<ol>
<li>我们希望树的类提供一个静态的查找最小值的方法，如 <code>BinarySearchTree.minNode(root)</code></li>
<li>提供一个查找当前树实例最小值的方法，如 <code>tree.min()</code></li>
</ol>

<blockquote>
<p>其实查找实例最小值就是把实例的根扔到 <code>BinarySearchTree.minNode()</code> 中执行一次</p>
</blockquote>

<pre><code class="language-javascript">/**
 * 查找一棵树的最小值
 * @param {Node} root 树的根节点
 */
const minNode = root =&gt; {
  if (!root) return null
  // 一直找到最左节点
  while (root &amp;&amp; root.left !== null) root = root.left
  return root
}

/**
 * 查找并返回最小节点
 */
const min = () =&gt; {
  return BinarySearchTree.minNode(this.root).key
}
</code></pre>

<h4 id="toc_11">树的最大值</h4>

<p>与树的最小值类似</p>

<pre><code class="language-javascript">/**
 * 查找一棵树的最大值
 * @param {Node} root 树的根节点
 */
const maxNode = root =&gt; {
  if (!root) return null
  // 一直找到最右节点
  while (root &amp;&amp; root.right !== null) root = root.right
  return root
}

/**
 * 查找并返回最小节点
 */
const max = () =&gt; {
  return BinarySearchTree.maxNode(this.root).key
}
</code></pre>

<h4 id="toc_12">查找树的特定节点</h4>

<pre><code class="language-javascript">/**
 * 查找树是否有某个节点
 * @param {Number} key 需要查找的节点的值
 */
const has = key =&gt; {
  const searchNode = (root, key) =&gt; {
    // 如果找不到，返回 false
    if (root === null) return false
    // 如果找到了，返回 true
    if (key === root.key) return true
    // 递归左右子树
    return key &lt; root.key ? searchNode(root.left, key) : searchNode(root.right, key)
  }
  return searchNode(this.root, key)
}
</code></pre>

<h4 id="toc_13">整合代码</h4>

<pre><code class="language-javascript">class BinarySearchTree {
  // ...

  /**
   * 查找并返回最小节点
   */
  min() {
    return BinarySearchTree.minNode(this.root).key
  }

  /**
   * 查找并返回最大节点
   */
  max() {
    return BinarySearchTree.maxNode(this.root).key
  }

  /**
   * 查找树是否有某个节点
   * @param {Number} key 需要查找的节点的值
   */
  has(key) {
    const searchNode = (root, key) =&gt; {
      if (root === null) return false
      if (key === root.key) return true
      return key &lt; root.key ? searchNode(root.left, key) : searchNode(root.right, key)
    }
    return searchNode(this.root, key)
  }

  /**
   * 查找一棵树的最小值
   * @param {Node} root 树的根节点
   */
  static minNode(root) {
    if (!root) return null
    while (root &amp;&amp; root.left !== null) root = root.left
    return root
  }

  /**
   * 查找一棵树的最大值
   * @param {Node} root 树的根节点
   */
  static maxNode(root) {
    if (!root) return null
    while (root &amp;&amp; root.right !== null) root = root.right
    return root
  }

  // ...
}
</code></pre>

<h3 id="toc_14">移除节点</h3>

<p>这是树类中最复杂的方法。我们先分类讨论，整理一下思路。假设我们要从树 Tree 中删除节点 X</p>

<p><strong>首先有个大前提: BST 树的特性是根节点比左节点大，比右节点小。</strong></p>

<p>第一步: 找出要删掉的 X</p>

<ol>
<li>X 比 Tree 的根节点小，那我们就从 Tree 的左子树中找 X，并且这个过程是递归的</li>
<li>X 比 Tree 的根节点大，那我们就从 Tree 的右子树中找 X，这个过程也是递归的</li>
<li>如果整棵树都找不到 X，那删除失败，返回 false</li>
<li>如果找到了 X，删除并返回 true</li>
</ol>

<p>第二部: 删掉 X</p>

<ol>
<li> X 没有子节点，令 X 为 null 即可</li>
<li> X 只有一个子节点，那么这个子节点代替 X（删掉 X 意味着他的唯一子节点就要代替自己的位置）</li>
<li> X 有两个子节点，我们需要从左右子节点（子树）中找到一个值代替 X<br/>
&gt; 1. 我们要从右边子树中找到用于替换 X 的值，因为 <strong>根据大前提</strong> ，左子树任意节点的值肯定比 X 的值小，他们不能代替 X<br/>
&gt; 2. 找到右边子树的最小节点，因为 <strong>根据大前提</strong> ，当它替换掉 X 的时候，能保证比 X 左子树所有值都大，比 X 右子树所有值都小</li>
</ol>

<pre><code class="language-javascript">class BinarySearchTree {
  // ...

  /**
   * 移除节点
   * @param {Number} key 需要移除的节点的值
   */
  delete(key) {
    let result = false // 是否删除成功

    /**
     * 用于递归的删除方法
     * @param {Node} node 当前树的根节点
     * @param {Number} key 删除的值
     */
    const _delete = (node, key) =&gt; {
      // 如果当前节点是空的，返回空
      if (node === null) return null

      // 目标删除节点的值比当前节点的值小，继续从左子树中找
      if (key &lt; node.key) {
        node.left = _delete(node.left, key)
        return node
      }

      // 目标删除节点的值比当前节点的值大，继续从右子树中找
      if (key &gt; node.key) {
        node.right = _delete(node.right, key)
        return node
      }

      // 找到要删除的目标节点
      if (key === node.key) {
        result = true
        // 第一种情况: 这个节点没有子节点，删掉当前节点
        if (node.left === null &amp;&amp; node.right === null) {
          node = null
          return node
        }

        // 第二种情况: 这个节点只有一个子节点，子节点代替当前节点
        if (node.left === null &amp;&amp; node.right !== null) {
          node = node.right
          return node
        }
        if (node.right === null &amp;&amp; node.left !== null) {
          node = node.left
          return node
        }

        // 第三种情况: 这个节点有两个子节点，从左右子节点（子树）中找到一个值代替当前节点
        const rightSubTreeMinNode = BinarySearchTree.minNode(node.right) // 找到右子树的最小节点
        node.key = rightSubTreeMinNode.key // 右子树的最小节点的值赋给当前节点
        node.right = _delete(node.right, rightSubTreeMinNode.key) // 找到右子树最小节点，删掉
        return node
      }
    }
    this.root = _delete(this.root, key)
    return result
  }

  // ...
}
</code></pre>

<h3 id="toc_15">总结</h3>

<p>至此，JavaScript 版的搜索二叉树的类已经完成了，完整代码如下</p>

<pre><code class="language-javascript">class BinarySearchTree {
  /**
   * 初始化有一个根节点
   */
  constructor(key) {
    this.root = BinarySearchTree.createNode(key)
  }

  /**
   * 插入节点
   * @param {Number} key 需要插入的节点的值
   */
  insert(key) {
    const newNode = BinarySearchTree.createNode(key)
    const insertNode = function(curNode, newNode) {
      if (newNode.key &lt; curNode.key) {
        curNode.left === null ? (curNode.left = newNode) : insertNode(curNode.left, newNode)
      } else {
        curNode.right === null ? (curNode.right = newNode) : insertNode(curNode.right, newNode)
      }
    }
    this.root.key === null ? (this.root = newNode) : insertNode(this.root, newNode)
  }

  /**
   * 先序遍历
   * @param {Function} callback 回调函数
   */
  preOrderTraverse(callback) {
    return BinarySearchTree.traverse(this.root, 1, callback)
  }

  /**
   * 中序遍历
   * @param {Function} callback 回调函数
   */
  inOrderTraverse(callback) {
    return BinarySearchTree.traverse(this.root, 2, callback)
  }

  /**
   * 后序遍历
   * @param {Function} callback 回调函数
   */
  postOrderTraverse(callback) {
    return BinarySearchTree.traverse(this.root, 3, callback)
  }

  /**
   * 查找并返回最小节点
   */
  min() {
    return BinarySearchTree.minNode(this.root).key
  }

  /**
   * 查找并返回最大节点
   */
  max() {
    return BinarySearchTree.maxNode(this.root).key
  }

  /**
   * 查找树是否有某个节点
   * @param {Number} key 需要查找的节点的值
   */
  has(key) {
    const searchNode = (root, key) =&gt; {
      if (root === null) return false
      if (key === root.key) return true
      return key &lt; root.key ? searchNode(root.left, key) : searchNode(root.right, key)
    }
    return searchNode(this.root, key)
  }

  /**
   * 移除节点
   * @param {Number} key 需要移除的节点的值
   */
  delete(key) {
    let result = false
    const _delete = (node, key) =&gt; {
      if (node === null) return null
      if (key &lt; node.key) {
        node.left = _delete(node.left, key)
        return node
      }
      if (key &gt; node.key) {
        node.right = _delete(node.right, key)
        return node
      }
      if (key === node.key) {
        result = true
        if (node.left === null &amp;&amp; node.right === null) {
          node = null
          return node
        }
        if (node.left === null &amp;&amp; node.right !== null) {
          node = node.right
          return node
        }
        if (node.right === null &amp;&amp; node.left !== null) {
          node = node.left
          return node
        }
        const rightSubTreeMinNode = BinarySearchTree.minNode(node.right)
        node.key = rightSubTreeMinNode.key
        node.right = _delete(node.right, rightSubTreeMinNode.key)
        return node
      }
    }
    this.root = _delete(this.root, key)
    return result
  }

  /**
   * 生成一个树节点
   * @param {Number} key 节点的值
   */
  static createNode(key) {
    key = key || null
    function Node(key) {
      this.key = key
      this.left = null
      this.right = null
    }
    return new Node(key)
  }

  /**
   * 静态遍历方法
   * @param {Node} root 树的根节点
   * @param {Number} type 遍历类型，1先序遍历，2中序遍历，3后序遍历
   * @param {Function} callback 回调函数，回调函数接受 key，leftKey，rightKey，node四个参数
   */
  static traverse(root, type, callback) {
    if (!root) return []
    const key = root.key
    const leftKey = root.left ? root.left.key : null
    const rightKey = root.right ? root.right.key : null
    switch (type) {
      case 1:
        callback(key, leftKey, rightKey, root)
        const preLeft = BinarySearchTree.traverse(root.left, type, callback)
        const preRight = BinarySearchTree.traverse(root.right, type, callback)
        return [root.key, ...preLeft, ...preRight]
      case 2:
        const inLeft = BinarySearchTree.traverse(root.left, type, callback)
        callback(key, leftKey, rightKey, root)
        const inRight = BinarySearchTree.traverse(root.right, type, callback)
        return [...inLeft, root.key, ...inRight]
      case 3:
        const postLeft = BinarySearchTree.traverse(root.left, type, callback)
        const postRight = BinarySearchTree.traverse(root.right, type, callback)
        callback(key, leftKey, rightKey, root)
        return [...postLeft, ...postRight, root.key]
      default:
        break
    }
  }

  /**
   * 查找一棵树的最小节点
   * @param {Node} root 树的根节点
   */
  static minNode(root) {
    if (!root) return null
    while (root &amp;&amp; root.left !== null) root = root.left
    return root
  }

  /**
   * 查找一棵树的最大节点
   * @param {Node} root 树的根节点
   */
  static maxNode(root) {
    if (!root) return null
    while (root &amp;&amp; root.right !== null) root = root.right
    return root
  }
}
</code></pre>

<p>测试用例:</p>

<pre><code class="language-javascript">// 初始化测试
const tree = new BinarySearchTree(11)
console.log(&#39;初始化测试&#39;, tree)

// 插入测试
tree.insert(9)
tree.insert(15)
tree.insert(3)
console.log(&#39;插入测试&#39;, tree)

// 先序遍历测试
const preList = tree.preOrderTraverse((key, leftKey, rightKey, node) =&gt; {
  console.log(&#39;先序遍历回调&#39;, key, leftKey, rightKey, node)
})
console.log(&#39;先序遍历测试&#39;, preList)

// 中序遍历测试
const inList = tree.inOrderTraverse((key, leftKey, rightKey, node) =&gt; {
  console.log(&#39;中序遍历回调&#39;, key, leftKey, rightKey, node)
})
console.log(&#39;中序遍历测试&#39;, inList)

// 后序遍历测试
const postList = tree.postOrderTraverse((key, leftKey, rightKey, node) =&gt; {
  console.log(&#39;后序遍历回调&#39;, key, leftKey, rightKey, node)
})
console.log(&#39;后序遍历测试&#39;, postList)

// 查找最小值测试
const min = tree.min()
console.log(&#39;查找最小值测试&#39;, min)

// 查找最大值测试
const max = tree.max()
console.log(&#39;查找最大值测试&#39;, max)

// 查找特定值测试
const has9 = tree.has(9)
const has100 = tree.has(100)
console.log(&#39;查找特定值9&#39;, has9)
console.log(&#39;查找特定值100&#39;, has100)

// 删除测试
const delete9 = tree.delete(9)
const delete100 = tree.delete(100)
console.log(&#39;删除9&#39;, delete9)
console.log(&#39;删除100&#39;, delete100)
console.log(&#39;删除9后查找9&#39;, tree.has(9))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构之链表]]></title>
    <link href="https://evanoyam.github.io/16023381818411.html"/>
    <updated>2020-10-10T21:56:21+08:00</updated>
    <id>https://evanoyam.github.io/16023381818411.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="16023382883992.html">数据结构之数组</a></li>
<li><a href="16023382325000.html">数据结构之队列</a></li>
<li><a href="16023382564461.html">数据结构之栈</a></li>
<li><a href="16023381818411.html">数据结构之链表</a></li>
<li><a href="16023382142420.html">数据结构之树</a></li>
<li><a href="16023383038322.html">数据结构之图</a></li>
</ul>

<p>链表是用来存储多个数据的一种结构。链表由节点构成，每个节点是<code>数据 + 指针</code>的构成方式。与数组不同，链表在内存里并不是连续放置的，是由指针指向下一个引用地址。这种结构的好处是增删元素不需要大量移动其他元素，只需要断开插入位置的连接，重新拼接新数据节点即可。但也有缺点，就是不能像数组一样通过下标直接定位到一个元素，而是要遍历链表，一节一节地去找到目标元素</p>

<blockquote>
<p>和火车的结构类似，链表的每个节点就是一个车厢，每个车厢能连接起来</p>
</blockquote>

<h2 id="toc_0">实现一个链表类</h2>

<p>链表类有以下实例方法</p>

<ol>
<li><code>append(value)</code>
&gt; 向链表尾部追加一个节点</li>
<li><code>insert(position, value)</code>
&gt; 链表特定位置插入节点</li>
<li><code>removeAt(position)</code>
&gt; 移除链表某个位置的节点</li>
<li><code>getNode(position)</code>
&gt; 获取某个节点</li>
<li><code>size()</code>
&gt; 查看链表的长度</li>
<li><code>getHead()</code>
&gt; 返回头节点</li>
<li><code>toString()</code>
&gt; 输出链表每个节点的值</li>
</ol>

<p>还需要一个静态方法</p>

<ol>
<li><code>createNode(value)</code>
&gt; 生成一个节点</li>
</ol>

<pre><code class="language-javascript">class LinkedList {
  #length = 0
  #head = null
  /**
   * 链表类
   * @param {String | Number} value 元素
   */
  constructor(value) {
    this.#head = LinkedList.createNode(value)
    this.#length++
  }

  /**
   * 在链表尾部追加一个节点
   * @param {String | Number} value 节点的值
   */
  append(value) {}

  /**
   * 在链表的指定位置插入元素
   * @param {Number} position 位置下标
   * @param {String | Number} value 插入的元素
   */
  insert(position, value) {}

  /**
   * 根据元素的位置，从链表中删除元素
   * @param {Number} position
   */
  removeAt(position) {}

  /**
   * 将链表转成字符串输出
   */
  toString() {}

  /**
   * 查找目标元素
   * @param {Number} position 目标元素位置
   */
  getNode(position) {}

  /**
   * 查看链表长度
   */
  size() {}

  /**
   * 生成一个 node 节点
   * @param {String | Number} value 节点的值
   */
  static createNode(value = null) {}
}
</code></pre>

<h2 id="toc_1">生成一个节点</h2>

<p>链表的核心就是节点。链表是由一个个节点拼接而成的，每个节点有自身的值，以及指向下一个节点地址的指针。节点很简单，本质上就是一个对象，这个对象有两个属性：一是自身的值，二是指针。</p>

<pre><code class="language-javascript">const node1 = {
  value: &#39;&#39;,
  next: node2
}

const node2 = {
  value: &#39;&#39;,
  next: node3
}

const node3 = {
  value: &#39;&#39;,
  next: null
}
</code></pre>

<p>链表的类提供一个静态方法，能生成一个 node 节点的实例</p>

<pre><code class="language-javascript">class LinkedList {
  // ...

  /**
   * 生成一个 node 节点
   * @param {String | Number} value 节点的值
   */
  static createNode(value = null) {
    function Node(val) {
      this.value = val
      this.next = null
    }
    const node = new Node(value)
    return node
  }

  // ...
}
</code></pre>

<h2 id="toc_2">向链表追加节点</h2>

<p>操作任何数据结构，无非都围绕着增删改查。对链表来说，增有两种实现方式：第一种是在尾部追加一个最新的节点，第二种是将节点插入到链表的指定位置。我们先从第一种开始说起。</p>

<blockquote>
<p>要向链表追加节点，只要遍历到最后一个节点，让最后一个节点的指针指向新节点即可。但如果当前链表是空的，那么只需要让头节点为新插入的节点即可</p>
</blockquote>

<pre><code class="language-javascript">class LinkedList {
  // ...

  /**
   * 在链表尾部追加一个节点
   * @param {String | Number} value 节点的值
   */
  append(value) {
    // 初始化一个节点
    const node = LinkedList.createNode(value)
    // 初始化指针，指向头节点
    let currentNode = this.#head
    // 如果是空的链表，头节点为新节点
    if (this.#head === null) {
      this.#head = node
    } else {
      // 遍历整个链表，找到最后一个节点
      while (currentNode.next) currentNode = currentNode.next
      // 修改指针，指向新节点
      currentNode.next = node
    }
    // 更新链表长度
    this.#length++
    return this.#head
  }

  // ...
}
</code></pre>

<h2 id="toc_3">在链表特定位置插入节点</h2>

<p>在特定位置插入节点，需要做以下 3 步：</p>

<ol>
<li>找到目标位置的前一个节点 A 和目标位置节点 B</li>
<li>将新节点的指针指向 B</li>
<li>将 A 的指针指向新节点</li>
</ol>

<pre><code class="language-javascript">class LinkedList {
  // ...

  /**
   * 在链表的指定位置插入节点
   * @param {Number} position 位置下标
   * @param {String | Number} value 插入的元素
   */
  insert(position, value) {
    // 判断临界条件
    if (position &lt; 0 || position &gt; this.#length) return false
    let node = LinkedList.createNode(value)
    // 如果插入的位置是第一个节点
    if (position === 0) {
      node.next = this.#head
      this.#head = node
    } else {
      // 如果插入的位置非第一个节点
      let index = 0
      let currentNode = this.#head
      // 找到目标节点的前一个节点 A 和目标节点 B
      // currentNode 即 A，currentNode.next 即 B
      while (index++ &lt; position - 1) currentNode = currentNode.next
      // 将新节点的指针指向目标节点 B
      node.next = currentNode.next
      // 将 A 节点的指针指向新节点
      currentNode.next = node
    }
    this.#length++
    return true
  }

  // ...
}
</code></pre>

<h2 id="toc_4">移除链表某个位置的节点</h2>

<p>移除链表的某个节点有两种情况：</p>

<ol>
<li>移除的是头节点，只需要让当前头节点的下一个节点成为头节点即可</li>
<li>移除的不是头节点，找到需要移除的节点的前一个节点 A，让节点 A 的指针绕过下一个节点，直接指向下下个节点</li>
</ol>

<pre><code class="language-javascript">class LinkedList {
  // ...

  /**
   * 根据元素的位置，从链表中删除节点
   * @param {Number} position
   */
  removeAt(position) {
    // 不在链表长度内 return null
    if (position &lt; 0 || position &gt; this.#length - 1) return null
    let removeNode
    // 移除第一个节点
    if (position === 0) {
      removeNode = this.#head.value
      this.#head = this.#head.next
    } else {
      // 移除非第一个节点
      let index = 0
      let currentNode = this.#head
      while (index++ &lt; position - 1) currentNode = currentNode.next
      removeNode = currentNode.next.value
      // 指针绕过需要被删除的节点
      currentNode.next = currentNode.next.next
    }
    this.#length--
    return removeNode
  }

  // ...
}
</code></pre>

<h2 id="toc_5">获取某个节点</h2>

<p>从头节点开始遍历，直到找到元素或者返回 null</p>

<pre><code class="language-javascript">class LinkedList {
  // ...

  /**
   * 查找目标节点
   * @param {Number} position 目标元素位置
   */
  getNode(position) {
    if (position &lt; 0 || position &gt; this.#length - 1) return null
    let currentNode = this.#head
    while (position--) currentNode = currentNode.next
    return currentNode.value
  }

  // ...
}
</code></pre>

<h2 id="toc_6">查看链表的长度</h2>

<p>返回私有属性 length 即可</p>

<pre><code class="language-javascript">class LinkedList {
  // ...

  /**
   * 查看链表长度
   */
  size() {
    return this.#length
  }

  // ...
}
</code></pre>

<h2 id="toc_7">返回头节点</h2>

<p>返回私有属性 head 即可</p>

<pre><code class="language-javascript">class LinkedList {
  // ...

  /**
   * 返回头节点
   */
  getHead() {
    return this.#head
  }

  // ...
}
</code></pre>

<h2 id="toc_8">输出链表每个节点的值</h2>

<p>遍历整个链表，把每个节点的 value 串起来即可。如果链表为空，返回空字符串</p>

<pre><code class="language-javascript">class LinkedList {
  // ...

  /**
   * 将链表转成字符串输出
   */
  toString() {
    if (this.#head === null) return &#39;&#39;
    let currentNode = this.#head
    let string = &#39;&#39;
    while (currentNode) {
      string += currentNode.value + (currentNode.next ? &#39;,&#39; : &#39;&#39;)
      currentNode = currentNode.next
    }
    return string
  }

  // ...
}
</code></pre>

<h2 id="toc_9">双向链表与循环链表</h2>

<p>双向链表的每个节点除了有指向下一个节点的next指针之外，还有指向上一个节点的prev指针。除了头节点之外，还有尾节点。</p>

<p>循环链表的尾节点不再指向空，而是指向头节点</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[leetcode 刷题之旅]]></title>
    <link href="https://evanoyam.github.io/16023381126025.html"/>
    <updated>2020-10-10T21:55:12+08:00</updated>
    <id>https://evanoyam.github.io/16023381126025.html</id>
    <content type="html"><![CDATA[
<p>整理了一些平时看到的算法题，以及部分真题。平时积累提升自己的思维能力，面试前也方便自己复习。</p>

<ul>
<li><a href="16023497016429.html">这里还有一篇面经</a></li>
<li><a href="16023381126025.html">leetcode 刷题之旅</a></li>
</ul>

<h2 id="toc_0">1. 两数之和</h2>

<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>

<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>

<p><strong>示例:</strong></p>

<blockquote>
<ul>
<li>给定 nums = [2, 7, 11, 15], target = 9</li>
<li>因为 nums[0] + nums[1] = 2 + 7 = 9</li>
<li>所以返回 [0, 1]</li>
</ul>
</blockquote>

<pre><code class="language-javascript">// 解法1
const twoSum = (nums, target) =&gt; {
  let nextIdx
  const idx = nums.findIndex((item, index) =&gt; {
    nextIdx = nums.indexOf(target - item)
    return nextIdx !== -1 &amp;&amp; index !== nextIdx
  })
  return idx == -1 ? [] : [idx, nextIdx]
}

// 解法2
const twoSum = (nums, target) =&gt; {
  let map = new Map()
  for (let i = 0; i &lt; nums.length; i++) {
    let x = target - nums[i]
    if (map.has(x)) return [map.get(x), i]
    map.set(nums[i], i)
  }
  return []
}

// 解法3
const twoSum = (nums, target) =&gt; {
  let map = {}
  for (let i = 0; i &lt; nums.length; i++) {
    let x = target - nums[i]
    if (map[x] !== undefined) return [map[x], i]
    map[nums[i]] = i
  }
  return []
}

// 测试用例: twoSum([12, 8, 1, 11], 9) =&gt; [1, 2]
</code></pre>

<h4 id="toc_1">3. 无重复字符的最长子串</h4>

<p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>

<p>示例1:</p>

<p>输入: &quot;abcabcbb&quot;<br/>
输出: 3 <br/>
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br/>
示例 2:</p>

<p>输入: &quot;bbbbb&quot;<br/>
输出: 1<br/>
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br/>
示例 3:</p>

<p>输入: &quot;pwwkew&quot;<br/>
输出: 3<br/>
解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。<br/>
请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;是一个子序列，不是子串。</p>

<pre><code class="language-javascript">/**
 * @param {string} s
 * @return {number}
 */
const lengthOfLongestSubstring = s =&gt; {
  let map = new Map() // 记录每个字符的下标，key是字符，val是下标
  let startIndex = -1 // 记录最长字符串的开始下标
  let max = 0 // 最长字符串个数
  for (let i in s) {
    if (map.has(s[i])) {
      startIndex = Math.max(map.get(s[i]), startIndex)
    }
    max = Math.max(max, i - startIndex)
    map.set(s[i], i)
  }
  return max
}

</code></pre>

<h4 id="toc_2">14. 最长公共前缀</h4>

<p>示例1:</p>

<p>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br/>
输出: &quot;fl&quot;</p>

<p>示例2:</p>

<p>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]<br/>
输出: &quot;&quot;<br/>
解释: 输入不存在公共前缀。</p>

<pre><code class="language-javascript">const longestCommonPrefix = strs =&gt; {
  if (strs.length == 0) return &#39;&#39;
  let maxCommonStr = strs[0]
  for (let i = 1; i &lt; strs.length; i++) {
    let j = 0
    for (j; j &lt; strs[i].length; j++) {
      if (strs[i][j] !== maxCommonStr[j]) break
    }
    maxCommonStr = maxCommonStr.substr(0, j)
  }
  return maxCommonStr
}
</code></pre>

<h4 id="toc_3">15. 三数之和</h4>

<p>给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>

<p>注意：答案中不可以包含重复的三元组。</p>

<p>示例：</p>

<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>

<p>满足要求的三元组集合为：<br/>
[[-1, 0, 1], [-1, -1, 2]]</p>

<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[][]}
 */
const threeSum = nums =&gt; {
  nums.sort((a, b) =&gt; a - b) // 递增排序
  let res = []
  // 因为排序完了，如果全部正数或者负数，则不存在结果，返回
  if (nums[0] * nums[nums.length - 1] &gt; 0) return res
  for (let i = 0; i &lt; nums.length; i++) {
    // 因为排序完了，所以如果出现连续两个相同的数，就跳过
    if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue
    let lp = i + 1 // 初始化左指针
    let rp = nums.length - 1 // 初始化右指针
    while (lp &lt; rp) {
      // 找到目标，插入结果队列
      if (nums[i] + nums[lp] + nums[rp] == 0) {
        res.push([nums[i], nums[lp], nums[rp]])
        lp++ // 左指针递增
        rp-- // 右指针递减
        // 如果递增/递减后的指针元素和刚刚的一样，那么跳过
        while (lp &lt; rp &amp;&amp; nums[lp] == nums[lp - 1]) lp++
        while (lp &lt; rp &amp;&amp; nums[rp] == nums[rp + 1]) rp--
      }
      // 找不到目标，如果相加大于0，表示需要小一点的结果，右指针递减
      // 如果结果小于0，表示需要大一点的结果，左指针递增
      if (nums[i] + nums[lp] + nums[rp] &gt; 0) rp--
      if (nums[i] + nums[lp] + nums[rp] &lt; 0) lp++
    }
  }
  return res
}
</code></pre>

<h4 id="toc_4">19. 删除链表的倒数第N个节点</h4>

<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>

<p>示例：</p>

<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>

<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br/>
说明：</p>

<p>给定的 n 保证是有效的。</p>

<p>进阶：</p>

<p>你能尝试使用一趟扫描实现吗？</p>

<pre><code class="language-javascript">const removeNthFromEnd = (head, n) =&gt; {
  // 假设输入的链表为 1-2-3-4-5
  let preHead = new ListNode(0) // 初始化一个只有一个节点的链表，作为目标链表的虚拟头部
  preHead.next = head // 将输入的链表和新链表连起来 0-1-2-3-4-5
  let slow = preHead // 慢指针
  let fast = preHead // 快指针
  // 让快指针 j 先走 n 步
  // 0-1-2-3-4-5
  // |   |
  // s   f
  while (n) {
    fast = fast.next
    n--
  }
  // 快慢指针同时走，直到快指针到尽头，即 fast.next 不存在
  // 0-1-2-3-4-5
  //       |   |
  //       s   f
  while (fast.next) {
    slow = slow.next
    fast = fast.next
  }
  // 此时 fast 走到了最后一个节点，slow 是需要删除节点的前一节点
  // 删除节点，返回剩余节点
  slow.next = slow.next.next // 0-1-2-3-5
  return preHead.next // 1-2-3-5
}
</code></pre>

<h4 id="toc_5">20. 有效的括号</h4>

<p>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。</p>

<p>有效字符串需满足：</p>

<p>左括号必须用相同类型的右括号闭合。<br/>
左括号必须以正确的顺序闭合。<br/>
注意空字符串可被认为是有效字符串。</p>

<pre><code class="language-javascript">/**
 * @param {string} s
 * @return {boolean}
 */
const isValid = s =&gt; {
  // 思路就是用栈，匹配的左右括号相加为 0
  // 遇到左括号入栈，遇到右括号就弹出栈顶
  // 如果两者相加不为0，return false
  // 如果遍历完栈长度大于0，意味着左右括号不对称，return false
  // 其他情况return true
  let map = {
    &#39;(&#39;: 1,
    &#39;)&#39;: -1,
    &#39;{&#39;: 2,
    &#39;}&#39;: -2,
    &#39;[&#39;: 3,
    &#39;]&#39;: -3
  }
  let stack = []
  for (let i in s) {
    if (map[s[i]] &gt; 0) {
      stack.push(s[i])
    } else {
      const target = stack.pop()
      if (map[target] + map[s[i]] !== 0) return false
    }
  }
  if (stack.length &gt; 0) return false
  return true
}
</code></pre>

<h4 id="toc_6">94. 二叉树的中序遍历</h4>

<p>给定一个二叉树，返回它的中序遍历。</p>

<p>示例:</p>

<pre><code class="language-text">输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
</code></pre>

<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
const inorderTraversal = function(root) {
  return root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : []
}

</code></pre>

<h4 id="toc_7">104. 二叉树的最大深度</h4>

<pre><code class="language-javascript">/**
 * @param {TreeNode} root
 * @return {number}
 */
const maxDepth = root =&gt; {
  if (!root) {
    return 0
  } else {
    const left = maxDepth(root.left)
    const right = maxDepth(root.right)
    return Math.max(left, right) + 1
  }
}

</code></pre>

<h4 id="toc_8">107. 二叉树的层次遍历</h4>

<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>

<p>例如：<br/>
给定二叉树 [3,9,20,null,null,15,7],</p>

<pre><code class="language-text">     3  
    / \  
   9  20  
     /  \  
    15   7  
</code></pre>

<p>返回其自底向上的层次遍历为：</p>

<pre><code class="language-text">[
  [15,7],
  [9,20],
  [3]
]
</code></pre>

<pre><code class="language-javascript">const levelOrderBottom = root =&gt; {
  let res = []
  const dfs = (node, depth) =&gt; {
    if (!node) return
    res[depth] ? res[depth].push(node.val) : (res[depth] = [node.val])
    dfs(node.left, depth + 1)
    dfs(node.right, depth + 1)
  }
  dfs(root, 0)
  return res.reverse()
}
</code></pre>

<h4 id="toc_9">112. 路径总和</h4>

<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>

<p>说明: 叶子节点是指没有子节点的节点。</p>

<p>示例: <br/>
给定如下二叉树，以及目标和 sum = 22，</p>

<pre><code class="language-text">              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</code></pre>

<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>

<pre><code class="language-javascript">const hasPathSum = (root, sum) =&gt; {
  if (!root) return false
  if (root.left === null &amp;&amp; root.right === null) return root.val === sum
  sum = sum - root.val
  return hasPathSum(root.left, sum) || hasPathSum(root.right, sum)
}

</code></pre>

<h4 id="toc_10">144. 二叉树的先序遍历</h4>

<p>给定一个二叉树，返回它的先序遍历。</p>

<p>示例:</p>

<pre><code class="language-text">输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
</code></pre>

<pre><code class="language-javascript">const preorderTraversal = root =&gt; {
  return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []
}
</code></pre>

<h4 id="toc_11">145. 二叉树的后序遍历</h4>

<p>给定一个二叉树，返回它的后序遍历。</p>

<p>示例:</p>

<pre><code class="language-text">输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
</code></pre>

<pre><code class="language-javascript">const postorderTraversal = root =&gt; {
  return root ? [...postorderTraversal(root.left), ...postorderTraversal(root.right), root.val] : []
}
</code></pre>

<h4 id="toc_12">151. 翻转字符串里的单词</h4>

<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>

<p>示例 1：</p>

<pre><code class="language-text">输入: &quot;the sky is blue&quot;
输出: &quot;blue is sky the&quot;
</code></pre>

<p>示例 2：</p>

<pre><code class="language-text">输入: &quot;  hello world!  &quot;
输出: &quot;world! hello&quot;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
</code></pre>

<p>示例 3：</p>

<pre><code class="language-text">输入: &quot;a good   example&quot;
输出: &quot;example good a&quot;
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
</code></pre>

<pre><code class="language-javascript">/**
 * @param {string} s
 * @return {string}
 */
const reverseWords = function(s) {
  let arr = s
    .split(&#39; &#39;)
    .filter(item =&gt; item.length)
    .reverse()
    .join(&#39; &#39;)
  return arr
}

</code></pre>

<h4 id="toc_13">155. 最小栈</h4>

<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>

<p>push(x) —— 将元素 x 推入栈中。<br/>
pop() —— 删除栈顶的元素。<br/>
top() —— 获取栈顶元素。<br/>
getMin() —— 检索栈中的最小元素。</p>

<p>示例:</p>

<pre><code class="language-text">输入：
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.
</code></pre>

<pre><code class="language-javascript">/**
 * initialize your data structure here.
 */
let MinStack = function() {
  this.stack = []
}

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  this.stack.push(x)
  return this.stack
}

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
  return this.stack.pop()
}

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1]
}

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  return Math.min(...this.stack)
}

/**
 * Your MinStack object will be instantiated and called as such:
 * let obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * let param_3 = obj.top()
 * let param_4 = obj.getMin()
 */

</code></pre>

<h4 id="toc_14">160. 相交链表</h4>

<p>编写一个程序，找到两个单链表相交的起始节点。</p>

<pre><code class="language-javascript">// 解法一: 标记法
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
const getIntersectionNode = (headA, headB) =&gt; {
  while (headA) {
    headA.temp = 1
    headA = headA.next
  }
  while (headB) {
    if (headB.temp) return headB
    headB = headB.next
  }
}
</code></pre>

<pre><code class="language-javascript">// 解法二: 变轨链法
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
const getIntersectionNode = (headA, headB) =&gt; {
  let pA = headA
  let pB = headB
  while (pA !== pB) {
    pA = pA ? pA.next : headB
    pB = pB ? pB.next : headA
  }
  return pA
}

</code></pre>

<h4 id="toc_15">236. 二叉树的最近公共祖先</h4>

<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
const lowestCommonAncestor = (root, p, q) =&gt; {
  if (!root || root == p || root == q) return root
  let left = lowestCommonAncestor(root.left, p, q)
  let right = lowestCommonAncestor(root.right, p, q)
  if (left &amp;&amp; right) return root
  return left ? left : right
}

</code></pre>

<h4 id="toc_16">349. 两个数组的交集</h4>

<p>给定两个数组，编写一个函数来计算它们的交集。</p>

<p>示例 1：</p>

<p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br/>
输出：[2]<br/>
示例 2：</p>

<p>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br/>
输出：[9,4]</p>

<pre><code class="language-javascript">/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
const intersection = (nums1, nums2) =&gt; {
  return [...new Set(nums1.filter(item =&gt; nums2.includes(item)))]
}

</code></pre>

<h4 id="toc_17">567. 字符串的排列</h4>

<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>

<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>

<pre><code class="language-text">示例1:

输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;
输出: True
解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).
</code></pre>

<pre><code class="language-javascript">/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function(s1, s2) {
    let lp = 0
    let rp = 0
    let needs = {}
    let windows = {}
    let match = 0

    for(let i in s1) {
        needs[s1[i]] ? needs[s1[i]]++ : (needs[s1[i]] = 1)
    }

    while(rp &lt; s2.length) {
        if(needs[s2[rp]]) {
            windows[s2[rp]] ? windows[s2[rp]]++ : (windows[s2[rp]] = 1)
            if(windows[s2[rp]] === needs[s2[rp]]) match++
        }
        rp++
        while(match === Object.keys(needs).length) {
            if(rp - lp === s1.length) return true
            if(needs[s2[lp]]) {
                windows[s2[lp]]--
                if(windows[s2[lp]] &lt; needs[s2[lp]]) match--
            }
            lp++
        }
    }

    return false
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见算法思路]]></title>
    <link href="https://evanoyam.github.io/16023380956095.html"/>
    <updated>2020-10-10T21:54:55+08:00</updated>
    <id>https://evanoyam.github.io/16023380956095.html</id>
    <content type="html"><![CDATA[
<p>这篇文章介绍了一些常见的算法思路，包括尾递归优化，回溯剪枝，贪心算法等等。目前还没写完，以后会慢慢扩展更多的算法介绍。</p>

<h2 id="toc_0">尾递归优化</h2>

<p>某个函数的最后一步是调用另一个函数，就称之为尾调用。如果最后一步调用的函数是其本身（递归）就称之为尾递归。</p>

<pre><code class="language-javascript">// 正常写法
function factorialA(n) {if (n === 1) return 1
  return n * factorialA(n - 1)
}

// 尾递归优化
function factorialB(n, x) {if (n === 1) return x
  return factorialB(n - 1, n + x)
}
</code></pre>

<p>使用尾递归的原因也很简单，防止爆栈。</p>

<p>在 js 中，函数的调用会在内存中形成一个调用记录，保存着当前调用的位置和内部变量。假如一个函数 A，在其内部调用了函数 B，那么将在 A 的调用记录之上建立一个 B 的调用记录，这种形态称之为 ** 调用栈 **</p>

<p>对上面的两个例子来说，第一种写法有自身的调用记录，而最终的执行结果返回的是一个计算值，那么就需要保存 <code>n</code> 这个变量以及参与计算的函数的调用记录</p>

<p>而第二种写法在函数的末尾直接返回函数，对这个函数来说，并没有别的函数记录需要保存，所以调用栈一直都是 1</p>

<blockquote>
<ul>
<li>要开启尾递归需要用严格模式，因为非严格模式下有 <code>arguments</code> 和 <code>func.caller</code> 两个隐式变量会被调用，破坏了尾递归的条件</li>
<li>在新版的 node 中，不再支持尾递归优化，因为尾递归的条件比较苛刻，即没有中间函数调用记录。但是在实际开发过程中开发者很难去判断自己写的代码是否符合这一条件，导致有些时候我们希望尾递归，但是却触发不了 v8 的优化。另一个问题就是尾递归导致执行栈信息丢失，调试和错误信息的收集都变得比较麻烦。因为执行栈永远是 1，也不知道错误是从哪一次调用被抛出</li>
</ul>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见的排序]]></title>
    <link href="https://evanoyam.github.io/16023380524964.html"/>
    <updated>2020-10-10T21:54:12+08:00</updated>
    <id>https://evanoyam.github.io/16023380524964.html</id>
    <content type="html"><![CDATA[
<p>这篇文章主要介绍常见的几种排序，除了工作中可能用到之外，面试时被问也不会尴尬。</p>

<p>排序过程中有几个概念：</p>

<ol>
<li>稳定性：如果a原本在b前面，而a = b，稳定的排序之后a仍然在b的前面。不稳定的排序有可能b在a前面</li>
<li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
</ol>

<h2 id="toc_0">冒泡排序</h2>

<p>是一种交换类的排序。两两比较相邻元素，如果大小排序不正确，就交换位置。这种排序不需要额外的存储空间。只有交换两个数据位置的时候，需要一个temp位置暂存某一个数据的值</p>

<p><img src="http://upload.eiona.ink/bIkrE/849589-20171015223238449-2146169197.gif" alt="image"/></p>

<h2 id="toc_1">快速排序</h2>

<p>是一种交换类的排序。核心的递归。</p>

<ol>
<li>先找到一个基准数，然后把比基准数大的归类到一个大数组A中，比基准数小的归类到另一个小数组B中</li>
<li>把基准数，A数组，B数组按 <code>B -&gt; 基准数 -&gt; A</code> 的顺序拼接起来</li>
<li>A，B两个数组继续递归执行快速排序，也就是在其各自数组中找出基准数，以及其对应的大小数组</li>
</ol>

<p><img src="http://upload.eiona.ink/o5Lc9/849589-20171015230936371-1413523412.gif" alt="image"/></p>

<h2 id="toc_2">插入排序</h2>

<p>是一种插入类排序，类似打牌的时候排序。</p>

<ol>
<li>从未排序的数据中找出一个值</li>
<li>在已排序的数据中找到对应的位置</li>
<li>把这个值插入找到的目标位置</li>
</ol>

<blockquote>
<p>在寻找合适的插入位置时，已排序的数据需要腾出一个位置来给新数据插入，所以只需要一个数据空间即可</p>
</blockquote>

<p><img src="http://upload.eiona.ink/vUgzt/849589-20171015225645277-1151100000.gif" alt="image"/></p>

<h2 id="toc_3"><a href="https://www.jianshu.com/p/d730ae586cf3">希尔排序</a></h2>

<p>希尔排序是一种优化版的插入排序，这是史上第一种突破O(n<sup>2)时间复杂度的排序。核心是根据增量把一个大数组拆成若干个小数组，每个数组自己用插入排序。<strong>这个增量需要让小数组的成员位置在大数组中尽可能相隔最远。</strong></sup></p>

<ol>
<li>假设有15个数，第一次排序增量为 15 / 2 向下取整为 7</li>
<li>每各7位组队，下标0和下标7的数据为一组，1和8，一直下去直到7和14（下标14即第15个数了）</li>
<li>分组后每个小组用插入排序排好，然后修改增量为 7 / 2 向下取整为 3</li>
<li>每隔3位组队，下标0，3，6，9，12组队，以此类推</li>
<li>这些小组按插入排序排序好，继续修改增量，3 / 2 向下取整为 1</li>
<li>只分成一组，这一个大组用插入排序</li>
</ol>

<h2 id="toc_4">选择排序</h2>

<p>简单粗暴，从一堆数中找出最小（或者最大）的值，暴力排序。最稳定的排序，也是最无脑的排序，时间复杂度和空间复杂度都是最稳定的。</p>

<h2 id="toc_5"><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">堆排序</a></h2>

<ol>
<li>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</li>
<li>将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</li>
</ol>

<h2 id="toc_6"><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">归并排序</a></h2>

<p>归并排序的核心是分治思想。把一个大数组逐步切成一个个小数组，有点类似切成一棵树，再组合这棵树</p>

<blockquote>
<p>归并排序和选择排序，堆排序类似，这玩意时间复杂度是恒定的，最优，最差，平均时间复杂度都是一样的。但是需要额外的内存空间。所以如果有堆排序可选，肯定选堆排序，一样的时间复杂度，还省了内存</p>
</blockquote>

<h2 id="toc_7">计数排序</h2>

<ol>
<li>计数排序要求输入的数据必须是有确定范围的整数。</li>
<li>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</li>
</ol>

<p><img src="http://upload.eiona.ink/WnzuH/849589-20171015231740840-6968181.gif" alt="image"/></p>

<h2 id="toc_8">基数排序</h2>

<p>基数排序从个位数开始，把个位数一样的数据集合在一块，然后排序一次。然后向前统计下一位数，把下一位数一样的数据集合在一块，再排序一次。直到最后排序完。<br/>
<img src="http://upload.eiona.ink/kP83n/849589-20171015232453668-1397662527.gif" alt="image"/></p>

<h2 id="toc_9">总结</h2>

<table>
<thead>
<tr>
<th>种类</th>
<th>子分类</th>
<th>名称</th>
<th>最好时间复杂度</th>
<th>最坏时间复杂度</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>

<tbody>
<tr>
<td>比较类</td>
<td>交换类</td>
<td>冒泡排序</td>
<td>O(n)</td>
<td>O(n<sup>2)</sup></td>
<td>O(n<sup>2)</sup></td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td></td>
<td></td>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n<sup>2)</sup></td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>不稳定</td>
</tr>
<tr>
<td></td>
<td>插入类</td>
<td>直接插入排序</td>
<td>O(n)</td>
<td>O(n<sup>2)</sup></td>
<td>O(n<sup>2)</sup></td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td></td>
<td></td>
<td>希尔排序</td>
<td>O(n)</td>
<td>O(n<sup>2)</sup></td>
<td>O(n<sup>1.3)</sup></td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td></td>
<td>选择类</td>
<td>直接选择排序</td>
<td>O(n<sup>2)</sup></td>
<td>O(n<sup>2)</sup></td>
<td>O(n<sup>2)</sup></td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td></td>
<td></td>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td></td>
<td>归并类</td>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>非比较类</td>
<td>计数类</td>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
<tr>
<td></td>
<td>基数类</td>
<td>基数排序</td>
<td>O(nk)</td>
<td>O(nk)</td>
<td>O(nk)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
</tbody>
</table>

<p>选择合适的排序：</p>

<ol>
<li><p>首先考虑有没有时间复杂度的要求</p>
<blockquote>
<ul>
<li>考虑数据无序性如何。如果数据非常混乱，优先看最坏时间复杂度；如果相对没这么混乱，优先看平均时间复杂度。最好时间复杂度就是不用排，已经有序了。</li>
<li>考虑数据量。根据数据量n的大小去选择对数复杂度，指数复杂度还是线性复杂度</li>
</ul>
</blockquote></li>
<li><p>再考虑有没有空间复杂度的要求</p></li>
<li><p>最后考虑有没有稳定性要求</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web Component]]></title>
    <link href="https://evanoyam.github.io/16023377632943.html"/>
    <updated>2020-10-10T21:49:23+08:00</updated>
    <id>https://evanoyam.github.io/16023377632943.html</id>
    <content type="html"><![CDATA[
<p>现在的前端生态都推崇组件式开发，无论是 React，Vue 还是 Angular 都是组建开发的形式。原生的 HTML 其实也支持组建开发，所有的框架组件化都是在这个基础上做的二次改进。</p>

<p>Web Component 就是前端组件化的一种社区实践，由模板、<code>shadow DOM</code>、自定义标签三部分组成</p>

<h2 id="toc_0">HTML template &amp; HTML slot</h2>

<p>template 组件和和 Vue 的 template 语法类似。</p>

<pre><code class="language-markup">&lt;!-- html --&gt;
&lt;template id=&quot;custom-template&gt;
    &lt;p&gt;&lt;slot name=&quot;custom-text&quot;&gt;We can put whatever we want here!&lt;/slot&gt;&lt;/p&gt;
&lt;/template&gt;
</code></pre>

<p>它允许开发者定义一个直到被复制使用时才会进行渲染的 HTML 标签块。而 slot 标签允许开发者通过特定接入点来动态替换模板中的 HTML 内容。它用 name 属性来作为唯一识别标志</p>

<pre><code class="language-javascript">// js
// 获取 template
const template = document.getElementById(&quot;custom-template&quot;);
const templateContent = template.content;

// 复制节点
const templateInstance = templateContent.cloneNode(true);

// 渲染到真实的 DOM 上
const container = document.getElementById(&quot;container&quot;);
container.appendChild(templateInstance);
</code></pre>

<h2 id="toc_1">Shadow DOM</h2>

<p>我们用 template 封装之后，虽然节点是可以复用了，但是里面的样式和属性都是对外暴露的，换句话说如果有一样的 class 或者 id 或者其他属性，都是会对环境造成污染的</p>

<p>Shadow DOM 就是用来隐藏节点的。他的作用就是将某些节点隔离进一个沙箱，是一颗不对外开放的，隐藏的 DOM 树</p>

<pre><code class="language-javascript">// 给 ele 节点添加一颗隐藏的 DOM 树，其内容是 template 的节点
// 开启 Shadow DOM 之后，ele 内的元素将被隔离
const element = document.getElementById(&#39;ele&#39;)
// mode: &#39;open&#39; 表示可被读取 Shadow DOM 内部属性，如果是 closed 表示对外不可见，读取结果是 null
const shadowRoot = element.attachShadow({mode: &#39;open&#39;});
shadowRoot.appendChild(templateContent.cloneNode(true));
</code></pre>

<h2 id="toc_2">Custom Element</h2>

<p>有了 template 和 shadow DOM，其实就已经能安全复用组件了。但是总不能每次都引入一大坨东西进去，Custom Element 就是把组件内容封装成一个标签，如 <code>&lt;my-div&gt;&lt;/my-div&gt;</code> 这样可以方便引用</p>

<p>Custom Element 需要继承自 HTMLElement 类，并且需要通过 <code>window.customElements.define</code> 来声明标签名</p>

<pre><code class="language-javascript">class UserCard extends HTMLElement {constructor() {super();
    
    // 开启 shadow DOM
    var shadow = this.attachShadow({ mode: &#39;closed&#39;} );
    
    // 获取模版内容
    var templateElem = document.getElementById(&#39;userCardTemplate&#39;);
    var content = templateElem.content.cloneNode(true);
    
    // 设置模板中的 DOM 节点
    content.querySelector(&#39;img&#39;).setAttribute(&#39;src&#39;, this.getAttribute(&#39;image&#39;));
    content.querySelector(&#39;.container&gt;.name&#39;).innerText = this.getAttribute(&#39;name&#39;);
    content.querySelector(&#39;.container&gt;.email&#39;).innerText = this.getAttribute(&#39;email&#39;);
    
    // 插入 shadow DOM
    shadow.appendChild(content);
  }
}

// 声明标签
window.customElements.define(&#39;user-card&#39;, UserCard);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS 常问手写题汇总]]></title>
    <link href="https://evanoyam.github.io/16023377061345.html"/>
    <updated>2020-10-10T21:48:26+08:00</updated>
    <id>https://evanoyam.github.io/16023377061345.html</id>
    <content type="html"><![CDATA[
<p>总结了一些常见的 JS 手写面试题，分享给大家，也供自己复习的时候看。</p>

<ul>
<li><a href="16023497016429.html">这里还有一篇面经</a></li>
<li><a href="16023381126025.html">leetcode 刷题之旅</a></li>
</ul>

<h2 id="toc_0">1. 找出数组中出现次数最高的元素</h2>

<pre><code class="language-javascript">/**
 * 找到数组中出现频率最高的元素和其频率
 * @param {Array} arr 数组
 * @return {Object}
 */
const findMostFrequency = arr =&gt; {
  let mostFrequency = 0
  let mostFrequencyArr = []

  // 这一步能获取到一个Map对象，key是元素，val是其出现的频率
  const map = arr.reduce((pre, cur) =&gt; {
    let frequency = pre.has(cur) ? pre.get(cur) : 0
    frequency ? pre.set(cur, ++frequency) : pre.set(cur, 1)
    // 确定最高频率
    mostFrequency = Math.max(mostFrequency, frequency)
    return pre
  }, new Map())

  // 遍历Map，把出现最高频的元素push到mostFrequencyArr
  for (const item of map) {
    if (item[1] == mostFrequency) mostFrequencyArr.push(item[0])
  }

  // 返回结果
  return {
    mostFrequency,
    mostFrequencyArr
  }
}
</code></pre>

<h2 id="toc_1">2. 展平多维数组</h2>

<pre><code class="language-javascript">let arr = [
  [0, 1],
  [2, 3],
  [4, [5, 6, 7]]
]
const tileArr = arr =&gt; {
  return arr.reduce((pre, cur) =&gt; pre.concat(Array.isArray(cur) ? tileArr(cur) : cur), [])
}
console.log(tileArr(arr)) // [0, 1, 2, 3, 4, 5, 6, 7]
</code></pre>

<h2 id="toc_2">3. 随机洗牌算法</h2>

<pre><code class="language-javascript">Array.prototype.shuffle = function() {
  for (let i = this.length - 1; i &gt;= 0; i--) {
    let randomIndex = Math.floor(Math.random() * (i + 1))
    ;[this[randomIndex], this[i]] = [this[i], this[randomIndex]]
  }
  return this
}
</code></pre>

<h2 id="toc_3">4. 全文单词首字母大写</h2>

<pre><code class="language-javascript">const upperCase = strs =&gt; {
  return strs.replace(/\b[a-zA-Z]/g, str =&gt; str.toUpperCase())
}
</code></pre>

<h2 id="toc_4">5. 斐波那契数列</h2>

<pre><code class="language-javascript">const fibonacci = n =&gt; {
  if (n === 1 || n === 2) return n === 1 ? 0 : 1
  return fibonacci(n - 1) + fibonacci(n - 2)
}
</code></pre>

<h2 id="toc_5">冒泡排序</h2>

<pre><code class="language-javascript">Array.prototype.bubbleSort = function() {
  for (let i = 0; i &lt; this.length - 1; i++) {
    for (let j = 0; j &lt; this.length - i - 1; j++) {
      if (this[j] &gt; this[j + 1]) {
        ;[this[j], this[j + 1]] = [this[j + 1], this[j]]
      }
    }
  }
}


let arr = [1, 7, 3, 8, 2, 11, 100, -29, 0, -17]
console.log(bubbleSort(arr))
</code></pre>

<h2 id="toc_6">快排</h2>

<pre><code class="language-javascript">Array.prototype.quickSort = function() {
  if (!this.length) return []
  let leftArr = []
  let rightArr = []
  for (let i = 1; i &lt; this.length; i++) {
    if (this[i] &gt;= this[0]) rightArr.push(this[i])
    if (this[i] &lt; this[0]) leftArr.push(this[i])
  }
  return [...leftArr.quickSort(), this[0], ...rightArr.quickSort()]
}

let arr = [1, 7, 3, 8, 2, 11, 100, -29, 0, -17]
console.log(quickSort(arr))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS 中的类与继承]]></title>
    <link href="https://evanoyam.github.io/16023376018689.html"/>
    <updated>2020-10-10T21:46:41+08:00</updated>
    <id>https://evanoyam.github.io/16023376018689.html</id>
    <content type="html"><![CDATA[
<p>这篇文章主要介绍 JS 面向对象的一些概念。很多人觉得前端面向对象没什么用，其实不然。如果你觉得前端就是写写页面写写样式，那是没什么用的。但是一但涉及到项目架构，或者封装什么库或者 SDK 之类的，面向对象就很有帮助了。</p>

<h2 id="toc_0">组合继承</h2>

<p>组合继承指的是将 <strong>原型继承</strong> 和 <strong>构造函数继承</strong> 结合起来</p>

<blockquote>
<ul>
<li>原型继承即 <code>Sub.prototype = new Super()</code>，这种继承的确能继承父类实例（this）和原型（prototype）上的方法，但是如果父类实例中有引用类型的数据结构，那这个继承复制下来的其实是引用类型的指针。这样多个子类的实例其实是共享一个引用数据类型的，修改实例 a 的引用类型，实例 b 的也会受到影响。此外，由于改了 Sub.prototype，导致子类原型链上的 constructor 指向丢失，会导致子类实例找不到子类的原型。</li>
<li>构造函数继承即 <code>Super.call(this, arguments)</code>，这种继承相当于把父类的实例（父类 return 的对象）复制给子类。这样能解决不共享引用数据类型的问题，但是这样也没法继承父类原型上的方法。并且每个子类都会有父类实例的副本，这些是子类不需要的。</li>
</ul>
</blockquote>

<pre><code class="language-javascript">// 简单的原型继承，缺点是继承父类函数的时候调用了父类的构造函数（子类原型指向父类实例）
// 使得子类原型身上带有很多不需要的父类属性
// 注意：子类原型需要先指向父类实例，才能在子类原型上定义其他

// 定义父类与父类原型
function SuperClass(name) {this.name = name}
SuperClass.prototype.showName = function() {console.log(&#39;name&#39;, this.name)
}

// 定义子类且调用一次父类，子类原型继承，定义子类原型上的其他方法，这里顺序不能乱
function SubClass(name, age) {SuperClass.call(this, name)
  this.age = age
}
SubClass.prototype = new SuperClass()SubClass.prototype.showAge = function() {console.log(&#39;age&#39;, this.age)
}

// 测试
const subClass = new SubClass(&#39;Evan&#39;, 21)
subClass.showName()subClass.showAge()

// 需要注意的是，子类原型指向父类实例之后，子类原型的 constructor 就不能正确找到子类构造函数了
// 因为原型上有一个 constructor 方法，它能让原型找到构造函数，也就是 Fn.prototype.constructor = Fn
// 但是子类原型也就是 SubClass.prototype = new SuperClass() 之后，SubClass.prototype.constructor 就丢失了
// 需要重写 constructor 让这老铁能正确找回自己的构造函数

// 第一个 log 通过，第二个不通过
const superClass = new SuperClass(&#39;Van&#39;)
console.log(SuperClass.prototype.constructor === SuperClass)
console.log(SubClass.prototype.constructor === SubClass)

// 为了解决 constructor 丢失的问题，我们需要重写 constructor
Object.defineProperty(SubClass.prototype, &#39;constructor&#39;, {
  enumerable: false,
  value: SubClass,
  writable: true
})

// 重新跑一次，指向正常了
console.log(SubClass.prototype.constructor === SubClass)

// instanceof 检查右边的函数原型是否存在于操作符左边的对象的原型链上
console.log(subClass instanceof SubClass)
console.log(subClass instanceof SuperClass)

// 如果把构造函数的原型修改了，instanceof 就会失效
SubClass.prototype = {}
console.log(subClass instanceof SubClass)
console.log(subClass instanceof SuperClass)

</code></pre>

<h2 id="toc_1">寄生组合继承</h2>

<pre><code class="language-javascript">// 解决组合继承时，子类带有父类构造函数上多余属性的问题
// 关键在于让子类的原型不再指向父类实例，而是指向一个有父类原型方法的对象
// 需要注意的是，这个对象的构造函数（constructor）需要指回子类
function SuperClass(name) {this.name = name}
SuperClass.prototype.showName = function() {console.log(&#39;name:&#39;, this.name)
}

function SubClass(name, age) {SuperClass.call(this, name)
  this.age = age
}

// 这里顺便把丢失的 constructor 也加上
SubClass.prototype = Object.create(SuperClass.prototype, {
  constructor: {
    value: SubClass,
    writable: true,
    enumerable: false,
    configurable: true
  }
})SubClass.prototype.showAge = function() {console.log(&#39;age:&#39;, this.age)
}

const sub = new SubClass(&#39;Van&#39;, 21)
sub.showName()sub.showAge()
</code></pre>

<h2 id="toc_2">类继承</h2>

<pre><code class="language-javascript">//es6 的类继承，所有的属性都写在 constructor 中
// 继承者需要在 constructor 中 super 声明
class SuperClass {constructor(name) {this.name = name}
  showName() {console.log(this.name)
  }
}

class SubClass extends SuperClass {constructor(name, age) {super(name)
    this.age = age
  }
  showAge() {console.log(this.age)
  }
}

let subClass = new SubClass(&#39;Evan&#39;, 21)
subClass.showName()subClass.showAge()
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化]]></title>
    <link href="https://evanoyam.github.io/16023373532350.html"/>
    <updated>2020-10-10T21:42:33+08:00</updated>
    <id>https://evanoyam.github.io/16023373532350.html</id>
    <content type="html"><![CDATA[
<ol>
<li>首屏优化（sw，骨架屏）</li>
<li>渲染优化（无限滚动，Intersection Observer API，图片懒加载，路由按需加载）</li>
</ol>

<h2 id="toc_0">首屏优化</h2>

<h4 id="toc_1">service-worker</h4>

<ol>
<li>以文件夹作为域，只能控制自身层级及以下层级的文件夹</li>
<li>有installing，installed / waiting，activating，activated，redundant等生命周期</li>
</ol>

<blockquote>
<p>installing失败会被放弃，一个域名下最多只能存在两个worker，一个是激活态的，另一个是等待态的。有新的worker来会替换掉旧的等待态worker。直到页面所有线程被释放，等待态的worker才会替换掉激活态的worker</p>
</blockquote>

<ol>
<li>能拦截几乎所有请求，可以重新组装响应包</li>
<li>配合CacheStorage能缓存大部分响应类型，不能缓存POST响应</li>
<li>缓存最佳实践是区分缓存池，对不同类型的资源采用不同的缓存策略</li>
</ol>

<blockquote>
<ul>
<li>长期不变动的资源，缓存到静态缓存池中</li>
<li>业务级的资源，缓存到动态缓存池中，每次打包利用webpack自动更新缓存池名字，当新的worker激活后会比对缓存池，清理过期缓存</li>
<li>更新策略需要穿透http缓存，请求的worker注册文件应该带时间戳，如sw.js?v=xxxxxxx</li>
<li>启用黑白名单，过滤不需要缓存的资源</li>
</ul>
</blockquote>

<h4 id="toc_2">骨架屏</h4>

<p>对于单页应用而言，首屏加载慢一直是个问题。因为单页应用拉回来的html是没有dom节点的，dom依赖js去动态渲染。于是有了骨架屏的方案，首屏出来之前，展示一个骨架，ui更友好。</p>

<p>骨架屏的思想就是，build出来的index.html里面就有骨架的dom，等js加载完再把骨架屏的dom移除。对vue来说就是 <code>#app</code> 内的东西还没出来，就展示骨架屏；出来了就移除骨架屏。</p>

<p>骨架屏要解决两个问题：<strong>一是如何生成骨架屏文件，二是如何注入骨架屏文件</strong></p>

<p><strong>生成：</strong><br/>
采用 <a href="https://github.com/kaola-fed/awesome-skeleton/blob/master/README-zh_CN.md">awesome-skeleton</a> 插件的方案。原理是开一个 Chromium，用 Puppeteer 抓页面，生成一个骨架的html或者png</p>

<p><strong>注入：</strong><br/>
采用 <a href="https://github.com/lavas-project/vue-skeleton-webpack-plugin">vue-skeleton-webpack-plugin</a> 插件的方案。原理是利用 <code>html-webpack-plugin</code> 插件的  <code>html-webpack-plugin-before-html-processing</code> 事件钩子，在处理 <code>index.html</code> 之前，把某个vue文件（骨架屏）预渲染注入到 html 中，使得构建完的 html 文件有骨架屏的dom，script和样式</p>

<p><strong>实现：</strong><br/>
对h5项目来说，生成骨架屏可以在项目内用 <code>awesome-skeleton</code> 抓取配置文件中指定的页面，输出到固定的目录中。也可以起一个node服务专门就来生成骨架屏，暴露一个API，接收一个url，输出骨架屏。</p>

<p>注入骨架屏可以写一个node的脚本。执行脚本的时候，遍历骨架屏文件夹里的所有html文件，然后重组之后生成对应的vue文件和入口文件。有了vue和入口文件，按照 <code>vue-skeleton-webpack-plugin</code> 的用法就能轻松把骨架屏注入到html中。</p>

<blockquote>
<ul>
<li>注入html时，cli3的 <code>mini-css-extract-plugin</code> 会把样式注入到bundle的js中，这样骨架屏的样式是不生效的。需要把样式分离，注入的时候改成style注入到html的head标签里。</li>
<li>其实真正的预渲染，是根据不同的路由访问不同的index文件。但是这样每次都要变更ng的配置去配合预渲染的index，路由也只能是history模式。而这里选用的方案是把所用的骨架屏全部注入到index.html中，访问不同的路由，加载的都是同一份html，只是控制展示不同的骨架。</li>
</ul>
</blockquote>

<h2 id="toc_3">渲染优化</h2>

<h4 id="toc_4">无限滚动列表</h4>

<p>对一个长列表来说，用户所能看见的仅仅是其中的一部分DOM，大部分的DOM节点是在屏幕外的。这部分节点是没有意义的，用户看不见，却又消耗性能去渲染，处理。尤其是滚动时还要不断触发无用的重绘。于是诞生<strong>无限滚动列表</strong>的概念</p>

<p>无限滚动列表，也叫虚拟渲染列表。指的是<strong>对一个长列表，只渲染其中的一部分，对于那些用户看不见的DOM节点，采用回收处理</strong>。无论渲染多少数据，始终渲染一定个数的DOM节点。用户滚动列表时修改渲染的DOM节点内容，再通过某些手段强制让滚动视窗的内容一直停留在屏幕内。</p>

<p><strong>需要解决的问题：</strong></p>

<ol>
<li>用户滚动时，动态从总数据数据中筛选出需要渲染的部分数据</li>
</ol>

<blockquote>
<p>比如有1000条数据的list，需要渲染的仅仅是30条，用户滚动时从1000条中挑选出需要渲染的30条。可能是1-30，也可能是11-40，根据不同的滚动高度选出不同的区间</p>
</blockquote>

<ol>
<li>即使修改了渲染的数据，但是由于用户滚动视窗，导致容器向上滑动，我们需要修正偏差</li>
</ol>

<blockquote>
<p>用户向上（向下）滑动了多少，我们就要向下（向上）“拉”回多少，保证用户视觉内看到的容器没有偏移</p>
</blockquote>

<p><strong>解决方法：</strong></p>

<ol>
<li>关于上述第一个问题，我们需要知道需要渲染的数据区间是多少，初始化时和每次滚动时，都要计算出数据区间。假设容器内能展示 X 个元素，为了防止快速滚动时出现白屏，我们需要在容器可视区上方多渲染 2X 个元素，在容器可视区下方多渲染 X 个元素。那么整个渲染区间所需的元素个数的 4X 个。</li>
</ol>

<blockquote>
<p>我们需要计算出list中一个item的高度，再根据当前容器的高度，计算出当前容器可视区域能展示多少个元素，这个数值*4即整个渲染区间所需的元素个数</p>
</blockquote>

<ol>
<li>关于上述第二个问题，我们需要这么设计DOM结构</li>
</ol>

<pre><code class="language-markup">&lt;div class=&quot;content&quot;&gt;
    &lt;ul class=&quot;list&quot;&gt;
        &lt;li class=&quot;item&quot;&gt;&lt;/li&gt;
        &lt;li class=&quot;item&quot;&gt;&lt;/li&gt;
        &lt;li class=&quot;item&quot;&gt;&lt;/li&gt;
        &lt;li class=&quot;item&quot;&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>ul就是整个渲染区间，ul在content里滚动。ul是list中所有数据渲染完后，item总和的高度。如1000条数据，ul的高度就是1000个item的高度。当用户向上滑动屏幕（越来越多的下方数据进入屏幕），ul向上移出content的高度就越来越大。当用户向下滑动屏幕则ul向下移除content的高度越来越大。如果我们什么都不做，渲染出来的内容就不能保证出现在视窗中（因为被滑动拖走了）</p>

<p>因此我们需要把偏移的ul“拉”回正确的位置。当用户向上滑动屏幕，ul向上移出，那我们就添加ul的paddingTop（或者marginTop）把ul“顶下去”；向下滑动屏幕，ul向下移出，那我们就添加ul的paddingBottom（或者marginBottom）把ul“顶上来”。只要保证这个“顶”的偏移量和“滑”走的偏移量相等，就能让ul渲染的内容始终在用户视窗内</p>

<blockquote>
<ul>
<li>content是明确高度的，因为我们需要根据content和item高度来计算容器可视区（content）能展示多少个item，进而计算出渲染区间展示多少个item</li>
<li>“拉”回ul的方法有很多，比如ul定高后，根据相对定位修改第一个item相对ul出现的高度，也能达到滑动后保证item还在视窗内</li>
</ul>
</blockquote>

<p><img src="http://upload.eiona.ink/GzAc9/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="image"/></p>

<p>例子：<a href="https://files.eiona.ink/files/code/test.vue">父组件</a>，<a href="https://files.eiona.ink/files/code/virtualScroll.vue">无限滚动组件</a></p>

<h4 id="toc_5"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">Intersection Observer API</a></h4>

<p>用于观察一个元素是否与目标元素产生交集。默认目标元素是浏览器视窗。当观察的元素与目标元素产生的交集大于阀值时，将执行一个回调。</p>

<p>利用这个特性，可以用来代替scroll事件完成一些事情，比如商品列表中某个商品出现在屏幕时加载更多，比如用来埋点等</p>

<pre><code class="language-javascript">const observe = domList =&gt; {
  let callback = (entries, observer) =&gt; {
    entries.forEach(entry =&gt; {
      if (entry.isIntersecting) {
        console.log(entry.target.dataset.id)
        observer.unobserve(entry.target) // 停止观察当前元素 避免不可见时候再次调用callback函数
      }
    })
  }

  let options = {
    threshold: 0.5
  }

  let observer = new IntersectionObserver(callback, options)

  domList.forEach(item =&gt; {
    observer.observe(item)
  })
}

</code></pre>

<h4 id="toc_6">图片懒加载 / 预加载</h4>

<p>vue-lazyload用来开启图片懒加载，原理是先用一个html属性暂存图片的真实地址，当图片出现在屏幕上或者距离屏幕一定距离时，才把地址设置成src的值，这时才去请求真实图片</p>

<h4 id="toc_7">路由按需加载</h4>

<p>通过 <code>component: () =&gt; import()</code> 的方式按需加载路由，用魔法注释来标记打包完的bundle名称。这种加载方式能将一个大的路由拆成多个子bundle，请求路由时只加载对应路由的依赖。</p>

<pre><code class="language-text">component: () =&gt;
    import(
        /* webpackChunkName: &quot;signinSharePage&quot; */
        &#39;@/views/group/components/signin/signinSharePage&#39;
    ),
</code></pre>

<p>可以开启 <a href="http://note.youdao.com/s/BiLI75Vy">prefetch</a> 让浏览器空闲时预先加载其他路由bundle</p>

]]></content>
  </entry>
  
</feed>
