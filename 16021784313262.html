<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title> 常见 Vue 面试题 - Evan的博客 </title>
     
    <link href="atom.xml" rel="alternate" title="Evan的博客" type="application/atom+xml" />
    
    <link rel="shortcut icon" href="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" type="image/png" />
    

    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>

    <script type="text/javascript">
      function before_search() {
        var searchVal = 'site:evanoyam.github.io ' + document.getElementById('search_input').value
        document.getElementById('search_q').value = searchVal
        return true
      }
    </script>
  </head>
  <body class="antialiased hide-extras">
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">
        <nav class="top-bar docs-bar hide-for-small" data-topbar>
          <section class="top-bar-section">
            <div class="row">
              <div style="position: relative; width: 100%">
                <div style="position: absolute; width: 100%">
                  <ul id="main-menu" class="left">
                    
                    <li id=""><a target="self" href="index.html">Home</a></li>
                    
                    <li id=""><a target="_self" href="archives.html">Archives</a></li>
                    
                  </ul>

                  <ul class="right" id="search-wrap">
                    <li>
                      <form
                        target="_blank"
                        onsubmit="return before_search();"
                        action="https://google.com/search"
                        method="get"
                      >
                        <input type="hidden" id="search_q" name="q" value="" />
                        <input tabindex="1" type="search" id="search_input" placeholder="Search" />
                      </form>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </section>
        </nav>

        <nav class="tab-bar show-for-small">
          <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
            <span> &nbsp; Evan的博客</span>
          </a>
        </nav>

        <aside class="left-off-canvas-menu">
          <ul class="off-canvas-list">
            
            <li><a target="self" href="index.html">Home</a></li>
            
            <li><a target="_self" href="archives.html">Archives</a></li>
            

            <li><label>Categories</label></li>

            
            <li><a href="Interface.html">面试</a></li>
            
            <li><a href="%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A.html">七牛图床</a></li>
            
          </ul>
        </aside>

        <a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container"></section>
      </div>
    </div>
  </body>
</html>
 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>常见 Vue 面试题</h1>
     
        <div class="read-more clearfix">
          <span class="date">2020/10/09</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Interface.html'>面试</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <p>总结了一些常见的 Vue 面试题</p>

<h4 id="toc_0">1. vue组件传值有哪些方式</h4>

<ol>
<li>最简单的 props 和 emit</li>
<li>利用一个新的 vue 实例做监听<br/>
```js<br/>
// bus.js<br/>
import Vue from &#39;vue&#39;<br/>
export default new Vue()</li>
</ol>

<p>// 组件a<br/>
import Bus from ./bus.js<br/>
methods: {<br/>
  emitSth() {<br/>
    Bus.$emit(&#39;fromA&#39;)<br/>
  }<br/>
}</p>

<p>// 组件b<br/>
import Bus from ./bus.js<br/>
mounted() {<br/>
  Bus.$on(&#39;fromA&#39;, () =&gt; {<br/>
    ...<br/>
  })<br/>
}</p>

<pre><code class="language-text">
3. 利用vuex

#### 2. vue router 有哪些钩子，分别是什么作用
1. 全局前置守卫：```router.beforeEach((to,from,next)=&gt;{})```
&gt; - to是去哪个路由，from是来自哪个路由，next()交接钩子状态
&gt; - 路由守卫是一个promise，一定要交接next()，不然不会触发resolve
&gt; - 在next中可以传递一个路由，如next(&#39;/&#39;)去根路径
&gt; - to和from中除了有path，name等基础信息之外，还有个matched数组，存储所有匹配到的路由，在这里可以查看更多的详细信息，包括meta中的自定义信息

2. 全局后置钩子：```router.afterEach((to,from)=&gt;{})```
&gt; - 后置钩子不存在next了，有to和from，与前置钩子类似

3. 全局解析守卫：```roter.beforeResolve```
&gt; - 全局守卫是自定义的一个守卫，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

4. 独享路由前置守卫：```beforeEnter((to,from,next)=&gt;{})```
&gt; - 独享路由守卫就是某个路由专有的守卫，用法与全局路由一致，只不过定义在具体路由内

5. 组件前置路由守卫：```beforeRouteEnter((to,from,next)=&gt;{})```
&gt; - 组件内路由指的是，当触发某个路由后，路由会依次加载路由页面内所需的组件，这些组件都可以在自身组件内定义前置路由。
&gt; - 在路由被comfirm之前，每个组件都会依次调用组件内前置路由。在这个钩子中，是没办法用this（Vue实例）的，因为这个时候DOM还没初始化，还没挂载。
&gt; - 可以在next中将实例传进去next(vm=&gt;{}），next之后已经初始化完成。

6. 组件变更路由守卫：```beforeRouteUpdate((to,from,next)=&gt;{})```
&gt; - 当路由改变，但是组件被复用的时候会调用beforeRouteUpdate，比如一个页面调用了三次相同的button组件，第一次是beforeRouteEnter，后面两次调用beforeRouteUpdate
&gt; - 这个钩子中可以用this，因为DOM以及挂载好了，同时next中已经不能接受vue实例了（没意义）

7. 组件离开路由守卫：```beforeRouteLeave((to,from,next)=&gt;{})```
&gt; - 当导航（路由）离开的时候，路由内的组件开始注销，这个时候每个组件会执行这个路由守卫
&gt; - 同样可以用this，也不能在next中接受vue实例

#### 3. vuex 为什么要用单向数据流，单向数据流指的是什么
单项数据流就是数据流动方向是固定的，不能倒流。在vue中，数据流动方向都是由vue实例发起开始，最后状态池state数据变更后通知vue实例重新渲染：

</code></pre>

<p>sequenceDiagram<br/>
Vue Components-&gt;&gt;Actions: dispatch<br/>
Actions-&gt;&gt;Mutations: commit<br/>
Mutations-&gt;&gt;State: mutate<br/>
State-&gt;&gt;Vue Components: Render</p>

<pre><code class="language-text">
单项数据流是数据驱动视图的一个核心。因为数据的变更会导致视图的重新渲染，所以数据的变更需要是可追踪的。单项数据流的好处是可以追踪所有的数据（在state中）的变更都是单向的，这样保证变更状态可追溯，每次数据的变更都是由Vue实例派发出来的。保证了每个组件都是无副作用的（纯函数，函数式编程）

#### 4. 为什么要通过actions来触发mutations，直接用vue实例触发mutations不可以吗？
首先一个概念就是，mutation必须是同步的，因为mutation会修改state数据，异步的mutation状态是无法追踪的。假如mutation是异步，那action或vue实例commit一个mutation之后（比如请求数据），那不知道什么时候回调会有响应，也就无法得知state啥时候被修改。

因为mutation必须是同步的，所以如果涉及到异步的操作，那么需要一个东西能异步提交mutation，action就是这个东西。vue实例也可以发布commit触发mutation，只不过如果直接commit的mutation就必须是同步的了。

既然commit一个mutation必须是同步的，那就异步操作（dispatch）action，然后让action去commit同步的mutation就好了。dispatch可以是异步的也没关系，啥时候回调回来也没关系，反正最终他会commit，只需要追踪commit一个mutation的时间点的快照就好了，这样数据流仍然是可追踪的。

#### 5. vuex 中如何使用异步
vuex中，actions都是可异步的。并且每一个action都是返回一个promise，配合promise.then或者await/async写异步还是很舒服
```js
// 异步action
actions: {
  incrementAsync ({ commit }) {
    setTimeout(() =&gt; {
      commit(&#39;increment&#39;)
    }, 1000)
  }
}

// await / async
// 假设 getData() 和 getOtherData() 返回的是 Promise
actions: {
  async actionA ({ commit }) {
    commit(&#39;gotData&#39;, await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch(&#39;actionA&#39;) // 等待 actionA 完成
    commit(&#39;gotOtherData&#39;, await getOtherData())
  }
}
</code></pre>

<h4 id="toc_1">6. vuex 中如何使用module</h4>

<p>vuex支持模块化，模块化的时候，各个模块通过state访问自己的状态中心，通过rootState访问根状态中心</p>

<pre><code class="language-javascript">// 定义vuex
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})
store.state.a // -&gt; moduleA 的状态
store.state.b // -&gt; moduleB 的状态

// 使用时用map映射更方便
computed: {
  ...mapState(&#39;some/nested/module&#39;, {
    a: state =&gt; state.a,
    b: state =&gt; state.b
  })
},
methods: {
  ...mapActions(&#39;some/nested/module&#39;, [
    &#39;foo&#39;, // -&gt; this.foo()
    &#39;bar&#39; // -&gt; this.bar()
  ])
}
</code></pre>

<h4 id="toc_2">7. 如何监听第三方组件的声明周期</h4>

<pre><code class="language-markup">&lt;Child @hook:mounted=&quot;childMounted&quot;&gt;&lt;/Child&gt;
</code></pre>

<h4 id="toc_3">8. watch / methods / computed 的区别</h4>

<p><strong>watch：</strong></p>

<ol>
<li>watch 是监听某个数据的变化，是一个watcher，订阅一份数据，当数据改变的时候执行一个回调。如果要监听对象深层次的属性，可以用deep关键字，但是这样会深度遍历所有的属性。也可以用下面的方法针对某个深层次属性做监听</li>
<li>watch和vue响应式的watcher是类似的，只不过响应式是vue实例帮我们收集响应式data中的依赖，而watch是用户手动绑定的响应式</li>
<li>watch的初始化在data初始化之后会立马触发get获取value，此时如果有immediate属性那么立马执行watch对应的回调函数</li>
<li>当data对应的key发生变化时，触发setter，watch感知到后执行回调函数</li>
</ol>

<pre><code class="language-javascript">// 针对某个属性
watch: {
  &#39;queryData.name&#39;: {
    handler: function() {
      // do something
    }
  }
}

// 或者结合computed
computed: {
  getName: function() {
    return this.queryData.name;
  }
},
watch: {
  getName: {
    handler: function() {
      // do something
    }
  }
}
</code></pre>

<p><strong>methods：</strong></p>

<ol>
<li>methods 是方法的集合，每次调用都会执行一次方法</li>
</ol>

<p><strong>computed：</strong></p>

<ol>
<li>computed 是计算属性，他会依赖其他属性计算并且 return 一个值。和methods最大的区别是，computed会缓存，如果参数条件不变，将把缓存结果return出去，如果条件变了再重新计算。当然，也可以利用闭包保证每次执行的独立作用域，这样缓存就失效了，和methods就没差别了</li>
<li>假设 computed c 依赖 data a和b，当data初始化之后，开始初始化computed。这时候触发 c 的getter，c会去读取a和b，触发a和b的getter</li>
<li>在触发c的getter的时候，就可以缓存a和b。当下次再触发c的getter，c的getter同样去读取a和b，比对后如果发现值没有变更，那么c不触发视图更新。如果发现依赖变更，则触发更新</li>
</ol>

<h4 id="toc_4">9. 什么是mvvm</h4>

<p>mvvm是 Model-View-ViewModel 的缩写</p>

<ol>
<li>Model是模型，是数据</li>
<li>View是视图</li>
<li>ViewModel是Model和View的通信层，它不关心View如何处理数据如何渲染（但是他会帮View整理好需要的数据格式），也不关心Model变更，它只管告知双方彼此发生了变更（所谓的双向绑定）</li>
</ol>

<blockquote>
<p>传统的mvc模式是 Model-View-Controller 的缩写，Controller是在View和Model中间并且只能单向连接View和Model。Controller需要去修改Model的状态，同时还要告知View状态变了，你要如何渲染。这就导致Controller过于臃肿和庞大</p>
</blockquote>

<p>一句话总结就是mvvm使得view 和 model之间是双向通信的，而mvc是单向通信的</p>

<h4 id="toc_5">10. 什么是虚拟dom，优势是什么</h4>

<p>虚拟dom就是用js模拟一颗dom树的结构。</p>

<p>虚拟dom的优势:</p>

<ol>
<li>操作js比操作实际的dom性能好得多，避免大量的重绘回流</li>
<li>在没有dom结构的地方（比如ssr）也能用js模拟dom的结构然后解析成html的结构，直接返回给前端</li>
<li>利用diff算法（先序遍历深度优先）还能比对新旧dom树（js树）的不同，定向的修改dom节点</li>
</ol>

<blockquote>
<p>在vue 3.x 中还多了一些静态虚拟dom，事件缓存，dom提升等性能相关的优化</p>
</blockquote>

<h4 id="toc_6">11. 什么是diff算法</h4>

<p>diff是一个先序遍历，深度优先的算法，他主要是对比两个虚拟dom（obj树）的不同，然后只修改不同的树枝</p>

<h4 id="toc_7">12. history和hash模式的异同</h4>

<p>hash模式url后带有#号，通过哈希值的变更来确定路由的变更；history模式更像原生的url</p>

<p>history模式依赖h5的一些新特性，pushState和replaceState等，在不刷新当前页面的基础上修改路由</p>

<h4 id="toc_8">13. vue和react的区别</h4>

<ol>
<li>vue原生支持v-model的双向绑定，修改数据和变更视图都更容易，react有完善的state状态管理，使用jsx，可以完全用js控制整个页面，自由度更高</li>
<li>vue相对来说更简单上手，对新手和小团队快速搭建更友好，react自由度更高，从脚手架到开发到构建都提供了充分的可配自由度</li>
<li>diff和性能的选择有些差异，比如react把虚拟dom细化成一个个链表，在浏览器空闲的时候一个个慢慢diff，而vue则是利用一个Watcher做整体的发布订阅管控，包括3.x中一些静态dom提升等优化</li>
</ol>

<h4 id="toc_9">14. beforeCreated，created，mounted之间的区别</h4>

<ol>
<li>beforeCreated时vue实例还没初始化，this是不可用的，这里只能做一些和vue无关的东西</li>
<li>created的时候vue实例已经初始化完毕了，但是dom还没挂载，这里可以操作this但是不能操作dom</li>
<li>mounted的时候dom已经挂载了，可以用ref操作dom</li>
</ol>

<h4 id="toc_10">15. vue的生命周期有哪些</h4>

<ol>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
<li>beforeUpdate</li>
<li>updated</li>
<li>beforeActivate</li>
<li>activated</li>
<li>beforeDestroy</li>
<li>destroyed</li>
</ol>

<h4 id="toc_11">16. extend的作用</h4>

<p>extend生成一个构造器，能实例化一个vue。一般用来做组件（比如toast）每次实例化一个vue挂载到dom上</p>

<h4 id="toc_12">17. provide/inject的作用</h4>

<p>provide/inject 是为了提供一个全局的，父子组件通信的能力，这一般是常量且不是响应式的</p>

<pre><code class="language-javascript">// 父级组件提供 &#39;foo&#39;
var Provider = {
  provide: {
    foo: &#39;bar&#39;
  },
  // ...
}

// 子组件注入 &#39;foo&#39;
var Child = {
  inject: [&#39;foo&#39;],
  created () {
    console.log(this.foo) // =&gt; &quot;bar&quot;
  }
  // ...
}
</code></pre>

<blockquote>
<ul>
<li>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</li>
<li>但是非常不建议用provide/inject去做响应式的监听变更，因为这样数据流就不是单向流动的，你不知道是哪个组件修改了这个全局状态。</li>
</ul>
</blockquote>

<h4 id="toc_13">18. mixin和mixins的区别</h4>

<p>mixin是全局的混入，每个组件都会受到影响。mixins是单一组件混入。</p>

<p>当组件状态和混入状态冲突的时候，优先使用组件的状态</p>

<h4 id="toc_14">19. watch的对象写法</h4>

<p>watch 有对象写法，能深度监听，immediate立即执行等</p>

<pre><code class="language-javascript">watch: {
  initData: {
    handler(newV) {
      this.initSpuData(newV);
    },
    immediate: true,
    deep: true
  }
}
</code></pre>

<h4 id="toc_15">20. v-show和v-if的区别，分别适用于什么场景</h4>

<p>v-if是vue不渲染这个dom节点，在虚拟dom树中就不存在这个dom节点。</p>

<p>v-show是<code>display: none</code>，dom中是有这个节点的，只是这个节点不渲染</p>

<p>如果一个元素频繁切换状态，就用v-show，因为不需要vue做diff去判断节点是否要挂载到dom树上</p>

<p>如果一个元素很大但不会频繁切换状态，那就用v-if，因为一开始不渲染还能减少diff的时间，而渲染过一次之后也不怎么变动</p>

<h4 id="toc_16">21. 组件中的data为什么是函数，什么时候可以用对象？</h4>

<p>如果一个组件是复用的，那如果data写成对象，那所有组件将共用这个对象的状态，毕竟是引用类型。</p>

<p>所以写成函数，每次返回一个新的对象，就算组件复用，返回的对象也是独享的</p>

<p>如果是 <code>new Vue()</code> 那就可以用对象了，因为new的都是一个Vue的实例，不存在共用data一说</p>

<h4 id="toc_17">22. vue的响应式原理是什么，手写一个</h4>

<p><a href="https://www.cnblogs.com/canfoo/p/6891868.html">双向绑定</a><br/>
<a href="https://juejin.im/post/5adf0085518825673123da9a">双向绑定</a></p>

<pre><code class="language-javascript">// vue 2.x
const observe = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj
  Reflect.ownKeys(obj).forEach(key =&gt; {
    reactiveFn(obj, key, obj[key])
  })
}

const reactiveFn = (obj, key, val) =&gt; {
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      console.log(&#39;get&#39;, val)
      return val
    },
    set(newV) {
      console.log(&#39;set&#39;, newV)
      val = newV
    }
  })
}

let userInfo = {
  name: &#39;Evan&#39;,
  age: 24
}

observe(userInfo)

const name = userInfo.name
userInfo.age = 25
</code></pre>

<pre><code class="language-javascript">// vue 3.x
const proxyGenerator = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj
  const handler = {
    get(obj, key) {
      console.log(&#39;get&#39;, obj[key])
      return proxyGenerator(obj[key])
    },
    set(obj, key, newV) {
      console.log(&#39;set&#39;, newV)
      obj[key] = newV
    }
  }
  return new Proxy(obj, handler)
}

let userInfo = {
  name: &#39;Evan&#39;,
  age: 24
}

let userInfoProxy = proxyGenerator(userInfo)

const name = userInfoProxy.name
userInfoProxy.age = 25
</code></pre>

<h4 id="toc_18">23. nexttick原理</h4>

<p>看一段代码：</p>

<pre><code class="language-javascript">export default {
  data () {
    return {
      msg: 0
    }
  },
  mounted () {
    this.msg = 1
    this.msg = 2
    this.msg = 3
  },
  watch: {
    msg () {
      console.log(this.msg)
    }
  }
}
</code></pre>

<p>对于上面的代码，watch只会执行一次。这是因为vue处理响应式是批量操作而不是每一次都操作的。</p>

<p>vue双向绑定的watcher源码中有这么一句 <code>queueWatcher(this)</code>，而这玩意内又有这么一句 <code>nextTick(flushSchedulerQueue)</code>。这个 flushSchedulerQueue 其实就是更新视图的函数。<a href="https://juejin.im/post/5ae3f0956fb9a07ac90cf43e#heading-1">nextTick的源码参考这里</a></p>

<p><strong>抽象概括一下nextTick的原理：</strong></p>

<ol>
<li><code>nextTick</code> 接收一个回调，返回一个闭包</li>
<li>回调的执行时机 <code>nextTick</code> 闭包中的 <code>timerFunc</code> 控制</li>
</ol>

<blockquote>
<p><code>timerFunc</code> 用以下优先级来处理出队时机。setImmediate -&gt; MessageChannel -&gt; Promise -&gt; setTimeout。优先使用宏任务，如果不支持就使用Promise的微任务，如果还不支持就用setTimeout兼容。虽然setTimeout是宏任务，但是在http声明中setTimeout有4ms的延时，所以只拿来做兼容处理，宏任务交给 <code>setImmediate</code> 和 <code>MessageChannel</code></p>
</blockquote>

<p>也就是说用于更新视图的 <code>nextTick(flushSchedulerQueue)</code> 其实以 <code>setImmediate -&gt; MessageChannel -&gt; Promise -&gt; setTimeout</code> 优先级塞入了 Event loop 中</p>

<p>这样更新的好处是：</p>

<p>假设有个值 <code>test</code> 被while循环执行1000次++操作。每次循环时，都会根据响应式触发 <code>compile -&gt; setter -&gt; Dep -&gt; Watcher -&gt; update -&gt; run</code> 如果没有异步更新，而是每次都更新DOM，那会十分消耗性能。所以Vue实现了一个queue队列，先把所有的watcher塞到队列里。在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行queue中Watcher的run</p>

<p><strong>整个过程如下：</strong></p>

<p><strong>第一阶段：queueWatcher(this) 收集watcher队列</strong></p>

<ol>
<li>响应式触发update，把watcher塞到queue队列，并且根据watcher.id去重</li>
</ol>

<p><strong>第二阶段：nextTick(flushSchedulerQueue) 更新视图</strong></p>

<ol>
<li><code>nextTick</code> 会返回一个闭包，通过 <code>timerFunc</code> 执行 <code>flushSchedulerQueue</code> 回调</li>
<li><code>flushSchedulerQueue</code> 执行watcher的run，更新视图</li>
</ol>

<p>回到第一段代码中，虽然修改了msg三次，但是因为vue更新视图的机制，首先把三次 <code>this.msg</code> 的变动塞到队列里，根据id去重只要了最后一次变更。之后异步执行视图更新，保证在下一个Tick（或者在当前Tick的微任务中）更新视图，也就直接把 msg 从 <code>0 -&gt; 3</code> 而不是 <code>0 -&gt; 1 -&gt; 2 -&gt; 3</code></p>

<h4 id="toc_19">24. Vue 插件的原理是什么</h4>

<p>Vue插件的的使用方法是 <code>Vue.use(xx)</code></p>

<p>所有被 Vue.use 的对象，都必须包含一个 <code>install</code> 的方法，<code>Vue.use</code>的本质就是执行这个方法罢了</p>

<blockquote>
<ul>
<li>如果use的是一个function而不是一个对象，那这个方法会被直接当成install方法来执行。</li>
<li>Vue use必须在vue实例化之前执行</li>
</ul>
</blockquote>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16021877148099.html" 
          title="Previous Post: 常见 JS 面试题">&laquo; 常见 JS 面试题</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="16021782785833.html" 
          title="Next Post: Vue 响应式原理">Vue 响应式原理 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" /></div>
            
                <h1>Evan的博客</h1>
                <div class="site-des">Evan 的博客 - 代码，摄影，音乐</div>
                <div class="social">






<a target="_blank" class="instagram" href="https://www.instagram.com/a953328679/" title="Instagram">Instagram</a>
<a target="_blank" class="weibo" href="https://weibo.com/wbxiaocong/" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com/EvanOyam/" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:o953328679@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Interface.html"><strong>面试</strong></a>
        
            <a href="%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A.html"><strong>七牛图床</strong></a>
         
        
            <a href="tag_JS.html"><strong>JS</strong></a>
            
            <a href="tag_Vue.html"><strong>Vue</strong></a>
            
        </p>
                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16022112559168.html">七牛图床测试</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16021877148099.html">常见 JS 面试题</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16021784313262.html">常见 Vue 面试题</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16021782785833.html">Vue 响应式原理</a>
			      </li>
		     
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
