<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    常见 Vue 面试题 - Evan的博客
    
    </title>
    <link rel="shortcut icon" href="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="Evan的博客" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        <a href="https://www.instagram.com/a953328679/" target="_blank" title="instagram">
                            <span class="icon is-large has-text-grey-darker">
                               <svg class="svg-inline--fa fa-instagram fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="instagram" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"></path></svg><!-- <i class="fab fa-instagram fa-lg"></i> -->
                            </span>
                          </a>
                        
                        
                        
                        
                        <a href="https://github.com/EvanOyam/" target="_blank" title="github">
                            <span class="icon is-large has-text-grey-darker">
                               <svg class="svg-inline--fa fa-github fa-w-16 fa-lg" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" data-fa-i2svg=""><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg><!-- <i class="fab fa-github fa-lg"></i> -->
                            </span>
                          </a>
                        
                        
                      
                      <a href="https://weibo.com/wbxiaocong/" target="_blank" title="weibo">
                          <span class="icon is-large has-text-grey-darker">
                            <svg class="svg-inline--fa fa-weibo fa-w-16 fa-lg" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="weibo" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M407 177.6c7.6-24-13.4-46.8-37.4-41.7-22 4.8-28.8-28.1-7.1-32.8 50.1-10.9 92.3 37.1 76.5 84.8-6.8 21.2-38.8 10.8-32-10.3zM214.8 446.7C108.5 446.7 0 395.3 0 310.4c0-44.3 28-95.4 76.3-143.7C176 67 279.5 65.8 249.9 161c-4 13.1 12.3 5.7 12.3 6 79.5-33.6 140.5-16.8 114 51.4-3.7 9.4 1.1 10.9 8.3 13.1 135.7 42.3 34.8 215.2-169.7 215.2zm143.7-146.3c-5.4-55.7-78.5-94-163.4-85.7-84.8 8.6-148.8 60.3-143.4 116s78.5 94 163.4 85.7c84.8-8.6 148.8-60.3 143.4-116zM347.9 35.1c-25.9 5.6-16.8 43.7 8.3 38.3 72.3-15.2 134.8 52.8 111.7 124-7.4 24.2 29.1 37 37.4 12 31.9-99.8-55.1-195.9-157.4-174.3zm-78.5 311c-17.1 38.8-66.8 60-109.1 46.3-40.8-13.1-58-53.4-40.3-89.7 17.7-35.4 63.1-55.4 103.4-45.1 42 10.8 63.1 50.2 46 88.5zm-86.3-30c-12.9-5.4-30 .3-38 12.9-8.3 12.9-4.3 28 8.6 34 13.1 6 30.8.3 39.1-12.9 8-13.1 3.7-28.3-9.7-34zm32.6-13.4c-5.1-1.7-11.4.6-14.3 5.4-2.9 5.1-1.4 10.6 3.7 12.9 5.1 2 11.7-.3 14.6-5.4 2.8-5.2 1.1-10.9-4-12.9z"></path></svg><!-- <i class="fab fa-weibo fa-lg"></i> -->
                          </span>
                      </a>
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            常见 Vue 面试题   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/10/09</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='Interface.html'>面试</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_Vue.html'>#Vue</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>总结了一些常见的 Vue 面试题</p>

<h4 id="toc_0">1. vue组件传值有哪些方式</h4>

<ol>
<li>最简单的 props 和 emit</li>
<li>利用一个新的 vue 实例做监听<br/>
```js<br/>
// bus.js<br/>
import Vue from &#39;vue&#39;<br/>
export default new Vue()</li>
</ol>

<p>// 组件a<br/>
import Bus from ./bus.js<br/>
methods: {<br/>
  emitSth() {<br/>
    Bus.$emit(&#39;fromA&#39;)<br/>
  }<br/>
}</p>

<p>// 组件b<br/>
import Bus from ./bus.js<br/>
mounted() {<br/>
  Bus.$on(&#39;fromA&#39;, () =&gt; {<br/>
    ...<br/>
  })<br/>
}</p>

<pre><code class="language-text">
3. 利用vuex

#### 2. vue router 有哪些钩子，分别是什么作用
1. 全局前置守卫：```router.beforeEach((to,from,next)=&gt;{})```
&gt; - to是去哪个路由，from是来自哪个路由，next()交接钩子状态
&gt; - 路由守卫是一个promise，一定要交接next()，不然不会触发resolve
&gt; - 在next中可以传递一个路由，如next(&#39;/&#39;)去根路径
&gt; - to和from中除了有path，name等基础信息之外，还有个matched数组，存储所有匹配到的路由，在这里可以查看更多的详细信息，包括meta中的自定义信息

2. 全局后置钩子：```router.afterEach((to,from)=&gt;{})```
&gt; - 后置钩子不存在next了，有to和from，与前置钩子类似

3. 全局解析守卫：```roter.beforeResolve```
&gt; - 全局守卫是自定义的一个守卫，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

4. 独享路由前置守卫：```beforeEnter((to,from,next)=&gt;{})```
&gt; - 独享路由守卫就是某个路由专有的守卫，用法与全局路由一致，只不过定义在具体路由内

5. 组件前置路由守卫：```beforeRouteEnter((to,from,next)=&gt;{})```
&gt; - 组件内路由指的是，当触发某个路由后，路由会依次加载路由页面内所需的组件，这些组件都可以在自身组件内定义前置路由。
&gt; - 在路由被comfirm之前，每个组件都会依次调用组件内前置路由。在这个钩子中，是没办法用this（Vue实例）的，因为这个时候DOM还没初始化，还没挂载。
&gt; - 可以在next中将实例传进去next(vm=&gt;{}），next之后已经初始化完成。

6. 组件变更路由守卫：```beforeRouteUpdate((to,from,next)=&gt;{})```
&gt; - 当路由改变，但是组件被复用的时候会调用beforeRouteUpdate，比如一个页面调用了三次相同的button组件，第一次是beforeRouteEnter，后面两次调用beforeRouteUpdate
&gt; - 这个钩子中可以用this，因为DOM以及挂载好了，同时next中已经不能接受vue实例了（没意义）

7. 组件离开路由守卫：```beforeRouteLeave((to,from,next)=&gt;{})```
&gt; - 当导航（路由）离开的时候，路由内的组件开始注销，这个时候每个组件会执行这个路由守卫
&gt; - 同样可以用this，也不能在next中接受vue实例

#### 3. vuex 为什么要用单向数据流，单向数据流指的是什么
单项数据流就是数据流动方向是固定的，不能倒流。在vue中，数据流动方向都是由vue实例发起开始，最后状态池state数据变更后通知vue实例重新渲染：

</code></pre>

<p>sequenceDiagram<br/>
Vue Components-&gt;&gt;Actions: dispatch<br/>
Actions-&gt;&gt;Mutations: commit<br/>
Mutations-&gt;&gt;State: mutate<br/>
State-&gt;&gt;Vue Components: Render</p>

<pre><code class="language-text">
单项数据流是数据驱动视图的一个核心。因为数据的变更会导致视图的重新渲染，所以数据的变更需要是可追踪的。单项数据流的好处是可以追踪所有的数据（在state中）的变更都是单向的，这样保证变更状态可追溯，每次数据的变更都是由Vue实例派发出来的。保证了每个组件都是无副作用的（纯函数，函数式编程）

#### 4. 为什么要通过actions来触发mutations，直接用vue实例触发mutations不可以吗？
首先一个概念就是，mutation必须是同步的，因为mutation会修改state数据，异步的mutation状态是无法追踪的。假如mutation是异步，那action或vue实例commit一个mutation之后（比如请求数据），那不知道什么时候回调会有响应，也就无法得知state啥时候被修改。

因为mutation必须是同步的，所以如果涉及到异步的操作，那么需要一个东西能异步提交mutation，action就是这个东西。vue实例也可以发布commit触发mutation，只不过如果直接commit的mutation就必须是同步的了。

既然commit一个mutation必须是同步的，那就异步操作（dispatch）action，然后让action去commit同步的mutation就好了。dispatch可以是异步的也没关系，啥时候回调回来也没关系，反正最终他会commit，只需要追踪commit一个mutation的时间点的快照就好了，这样数据流仍然是可追踪的。

#### 5. vuex 中如何使用异步
vuex中，actions都是可异步的。并且每一个action都是返回一个promise，配合promise.then或者await/async写异步还是很舒服
```js
// 异步action
actions: {
  incrementAsync ({ commit }) {
    setTimeout(() =&gt; {
      commit(&#39;increment&#39;)
    }, 1000)
  }
}

// await / async
// 假设 getData() 和 getOtherData() 返回的是 Promise
actions: {
  async actionA ({ commit }) {
    commit(&#39;gotData&#39;, await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch(&#39;actionA&#39;) // 等待 actionA 完成
    commit(&#39;gotOtherData&#39;, await getOtherData())
  }
}
</code></pre>

<h4 id="toc_1">6. vuex 中如何使用module</h4>

<p>vuex支持模块化，模块化的时候，各个模块通过state访问自己的状态中心，通过rootState访问根状态中心</p>

<pre><code class="language-javascript">// 定义vuex
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})
store.state.a // -&gt; moduleA 的状态
store.state.b // -&gt; moduleB 的状态

// 使用时用map映射更方便
computed: {
  ...mapState(&#39;some/nested/module&#39;, {
    a: state =&gt; state.a,
    b: state =&gt; state.b
  })
},
methods: {
  ...mapActions(&#39;some/nested/module&#39;, [
    &#39;foo&#39;, // -&gt; this.foo()
    &#39;bar&#39; // -&gt; this.bar()
  ])
}
</code></pre>

<h4 id="toc_2">7. 如何监听第三方组件的声明周期</h4>

<pre><code class="language-markup">&lt;Child @hook:mounted=&quot;childMounted&quot;&gt;&lt;/Child&gt;
</code></pre>

<h4 id="toc_3">8. watch / methods / computed 的区别</h4>

<p><strong>watch：</strong></p>

<ol>
<li>watch 是监听某个数据的变化，是一个watcher，订阅一份数据，当数据改变的时候执行一个回调。如果要监听对象深层次的属性，可以用deep关键字，但是这样会深度遍历所有的属性。也可以用下面的方法针对某个深层次属性做监听</li>
<li>watch和vue响应式的watcher是类似的，只不过响应式是vue实例帮我们收集响应式data中的依赖，而watch是用户手动绑定的响应式</li>
<li>watch的初始化在data初始化之后会立马触发get获取value，此时如果有immediate属性那么立马执行watch对应的回调函数</li>
<li>当data对应的key发生变化时，触发setter，watch感知到后执行回调函数</li>
</ol>

<pre><code class="language-javascript">// 针对某个属性
watch: {
  &#39;queryData.name&#39;: {
    handler: function() {
      // do something
    }
  }
}

// 或者结合computed
computed: {
  getName: function() {
    return this.queryData.name;
  }
},
watch: {
  getName: {
    handler: function() {
      // do something
    }
  }
}
</code></pre>

<p><strong>methods：</strong></p>

<ol>
<li>methods 是方法的集合，每次调用都会执行一次方法</li>
</ol>

<p><strong>computed：</strong></p>

<ol>
<li>computed 是计算属性，他会依赖其他属性计算并且 return 一个值。和methods最大的区别是，computed会缓存，如果参数条件不变，将把缓存结果return出去，如果条件变了再重新计算。当然，也可以利用闭包保证每次执行的独立作用域，这样缓存就失效了，和methods就没差别了</li>
<li>假设 computed c 依赖 data a和b，当data初始化之后，开始初始化computed。这时候触发 c 的getter，c会去读取a和b，触发a和b的getter</li>
<li>在触发c的getter的时候，就可以缓存a和b。当下次再触发c的getter，c的getter同样去读取a和b，比对后如果发现值没有变更，那么c不触发视图更新。如果发现依赖变更，则触发更新</li>
</ol>

<h4 id="toc_4">9. 什么是mvvm</h4>

<p>mvvm是 Model-View-ViewModel 的缩写</p>

<ol>
<li>Model是模型，是数据</li>
<li>View是视图</li>
<li>ViewModel是Model和View的通信层，它不关心View如何处理数据如何渲染（但是他会帮View整理好需要的数据格式），也不关心Model变更，它只管告知双方彼此发生了变更（所谓的双向绑定）</li>
</ol>

<blockquote>
<p>传统的mvc模式是 Model-View-Controller 的缩写，Controller是在View和Model中间并且只能单向连接View和Model。Controller需要去修改Model的状态，同时还要告知View状态变了，你要如何渲染。这就导致Controller过于臃肿和庞大</p>
</blockquote>

<p>一句话总结就是mvvm使得view 和 model之间是双向通信的，而mvc是单向通信的</p>

<h4 id="toc_5">10. 什么是虚拟dom，优势是什么</h4>

<p>虚拟dom就是用js模拟一颗dom树的结构。</p>

<p>虚拟dom的优势:</p>

<ol>
<li>操作js比操作实际的dom性能好得多，避免大量的重绘回流</li>
<li>在没有dom结构的地方（比如ssr）也能用js模拟dom的结构然后解析成html的结构，直接返回给前端</li>
<li>利用diff算法（先序遍历深度优先）还能比对新旧dom树（js树）的不同，定向的修改dom节点</li>
</ol>

<blockquote>
<p>在vue 3.x 中还多了一些静态虚拟dom，事件缓存，dom提升等性能相关的优化</p>
</blockquote>

<h4 id="toc_6">11. 什么是diff算法</h4>

<p>diff是一个先序遍历，深度优先的算法，他主要是对比两个虚拟dom（obj树）的不同，然后只修改不同的树枝</p>

<h4 id="toc_7">12. history和hash模式的异同</h4>

<p>hash模式url后带有#号，通过哈希值的变更来确定路由的变更；history模式更像原生的url</p>

<p>history模式依赖h5的一些新特性，pushState和replaceState等，在不刷新当前页面的基础上修改路由</p>

<h4 id="toc_8">13. vue和react的区别</h4>

<ol>
<li>vue原生支持v-model的双向绑定，修改数据和变更视图都更容易，react有完善的state状态管理，使用jsx，可以完全用js控制整个页面，自由度更高</li>
<li>vue相对来说更简单上手，对新手和小团队快速搭建更友好，react自由度更高，从脚手架到开发到构建都提供了充分的可配自由度</li>
<li>diff和性能的选择有些差异，比如react把虚拟dom细化成一个个链表，在浏览器空闲的时候一个个慢慢diff，而vue则是利用一个Watcher做整体的发布订阅管控，包括3.x中一些静态dom提升等优化</li>
</ol>

<h4 id="toc_9">14. beforeCreated，created，mounted之间的区别</h4>

<ol>
<li>beforeCreated时vue实例还没初始化，this是不可用的，这里只能做一些和vue无关的东西</li>
<li>created的时候vue实例已经初始化完毕了，但是dom还没挂载，这里可以操作this但是不能操作dom</li>
<li>mounted的时候dom已经挂载了，可以用ref操作dom</li>
</ol>

<h4 id="toc_10">15. vue的生命周期有哪些</h4>

<ol>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
<li>beforeUpdate</li>
<li>updated</li>
<li>beforeActivate</li>
<li>activated</li>
<li>beforeDestroy</li>
<li>destroyed</li>
</ol>

<h4 id="toc_11">16. extend的作用</h4>

<p>extend生成一个构造器，能实例化一个vue。一般用来做组件（比如toast）每次实例化一个vue挂载到dom上</p>

<h4 id="toc_12">17. provide/inject的作用</h4>

<p>provide/inject 是为了提供一个全局的，父子组件通信的能力，这一般是常量且不是响应式的</p>

<pre><code class="language-javascript">// 父级组件提供 &#39;foo&#39;
var Provider = {
  provide: {
    foo: &#39;bar&#39;
  },
  // ...
}

// 子组件注入 &#39;foo&#39;
var Child = {
  inject: [&#39;foo&#39;],
  created () {
    console.log(this.foo) // =&gt; &quot;bar&quot;
  }
  // ...
}
</code></pre>

<blockquote>
<ul>
<li>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</li>
<li>但是非常不建议用provide/inject去做响应式的监听变更，因为这样数据流就不是单向流动的，你不知道是哪个组件修改了这个全局状态。</li>
</ul>
</blockquote>

<h4 id="toc_13">18. mixin和mixins的区别</h4>

<p>mixin是全局的混入，每个组件都会受到影响。mixins是单一组件混入。</p>

<p>当组件状态和混入状态冲突的时候，优先使用组件的状态</p>

<h4 id="toc_14">19. watch的对象写法</h4>

<p>watch 有对象写法，能深度监听，immediate立即执行等</p>

<pre><code class="language-javascript">watch: {
  initData: {
    handler(newV) {
      this.initSpuData(newV);
    },
    immediate: true,
    deep: true
  }
}
</code></pre>

<h4 id="toc_15">20. v-show和v-if的区别，分别适用于什么场景</h4>

<p>v-if是vue不渲染这个dom节点，在虚拟dom树中就不存在这个dom节点。</p>

<p>v-show是<code>display: none</code>，dom中是有这个节点的，只是这个节点不渲染</p>

<p>如果一个元素频繁切换状态，就用v-show，因为不需要vue做diff去判断节点是否要挂载到dom树上</p>

<p>如果一个元素很大但不会频繁切换状态，那就用v-if，因为一开始不渲染还能减少diff的时间，而渲染过一次之后也不怎么变动</p>

<h4 id="toc_16">21. 组件中的data为什么是函数，什么时候可以用对象？</h4>

<p>如果一个组件是复用的，那如果data写成对象，那所有组件将共用这个对象的状态，毕竟是引用类型。</p>

<p>所以写成函数，每次返回一个新的对象，就算组件复用，返回的对象也是独享的</p>

<p>如果是 <code>new Vue()</code> 那就可以用对象了，因为new的都是一个Vue的实例，不存在共用data一说</p>

<h4 id="toc_17">22. vue的响应式原理是什么，手写一个</h4>

<p><a href="https://www.cnblogs.com/canfoo/p/6891868.html">双向绑定</a><br/>
<a href="https://juejin.im/post/5adf0085518825673123da9a">双向绑定</a></p>

<pre><code class="language-javascript">// vue 2.x
const observe = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj
  Reflect.ownKeys(obj).forEach(key =&gt; {
    reactiveFn(obj, key, obj[key])
  })
}

const reactiveFn = (obj, key, val) =&gt; {
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      console.log(&#39;get&#39;, val)
      return val
    },
    set(newV) {
      console.log(&#39;set&#39;, newV)
      val = newV
    }
  })
}

let userInfo = {
  name: &#39;Evan&#39;,
  age: 24
}

observe(userInfo)

const name = userInfo.name
userInfo.age = 25
</code></pre>

<pre><code class="language-javascript">// vue 3.x
const proxyGenerator = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj
  const handler = {
    get(obj, key) {
      console.log(&#39;get&#39;, obj[key])
      return proxyGenerator(obj[key])
    },
    set(obj, key, newV) {
      console.log(&#39;set&#39;, newV)
      obj[key] = newV
    }
  }
  return new Proxy(obj, handler)
}

let userInfo = {
  name: &#39;Evan&#39;,
  age: 24
}

let userInfoProxy = proxyGenerator(userInfo)

const name = userInfoProxy.name
userInfoProxy.age = 25
</code></pre>

<h4 id="toc_18">23. nexttick原理</h4>

<p>看一段代码：</p>

<pre><code class="language-javascript">export default {
  data () {
    return {
      msg: 0
    }
  },
  mounted () {
    this.msg = 1
    this.msg = 2
    this.msg = 3
  },
  watch: {
    msg () {
      console.log(this.msg)
    }
  }
}
</code></pre>

<p>对于上面的代码，watch只会执行一次。这是因为vue处理响应式是批量操作而不是每一次都操作的。</p>

<p>vue双向绑定的watcher源码中有这么一句 <code>queueWatcher(this)</code>，而这玩意内又有这么一句 <code>nextTick(flushSchedulerQueue)</code>。这个 flushSchedulerQueue 其实就是更新视图的函数。<a href="https://juejin.im/post/5ae3f0956fb9a07ac90cf43e#heading-1">nextTick的源码参考这里</a></p>

<p><strong>抽象概括一下nextTick的原理：</strong></p>

<ol>
<li><code>nextTick</code> 接收一个回调，返回一个闭包</li>
<li>回调的执行时机 <code>nextTick</code> 闭包中的 <code>timerFunc</code> 控制</li>
</ol>

<blockquote>
<p><code>timerFunc</code> 用以下优先级来处理出队时机。setImmediate -&gt; MessageChannel -&gt; Promise -&gt; setTimeout。优先使用宏任务，如果不支持就使用Promise的微任务，如果还不支持就用setTimeout兼容。虽然setTimeout是宏任务，但是在http声明中setTimeout有4ms的延时，所以只拿来做兼容处理，宏任务交给 <code>setImmediate</code> 和 <code>MessageChannel</code></p>
</blockquote>

<p>也就是说用于更新视图的 <code>nextTick(flushSchedulerQueue)</code> 其实以 <code>setImmediate -&gt; MessageChannel -&gt; Promise -&gt; setTimeout</code> 优先级塞入了 Event loop 中</p>

<p>这样更新的好处是：</p>

<p>假设有个值 <code>test</code> 被while循环执行1000次++操作。每次循环时，都会根据响应式触发 <code>compile -&gt; setter -&gt; Dep -&gt; Watcher -&gt; update -&gt; run</code> 如果没有异步更新，而是每次都更新DOM，那会十分消耗性能。所以Vue实现了一个queue队列，先把所有的watcher塞到队列里。在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行queue中Watcher的run</p>

<p><strong>整个过程如下：</strong></p>

<p><strong>第一阶段：queueWatcher(this) 收集watcher队列</strong></p>

<ol>
<li>响应式触发update，把watcher塞到queue队列，并且根据watcher.id去重</li>
</ol>

<p><strong>第二阶段：nextTick(flushSchedulerQueue) 更新视图</strong></p>

<ol>
<li><code>nextTick</code> 会返回一个闭包，通过 <code>timerFunc</code> 执行 <code>flushSchedulerQueue</code> 回调</li>
<li><code>flushSchedulerQueue</code> 执行watcher的run，更新视图</li>
</ol>

<p>回到第一段代码中，虽然修改了msg三次，但是因为vue更新视图的机制，首先把三次 <code>this.msg</code> 的变动塞到队列里，根据id去重只要了最后一次变更。之后异步执行视图更新，保证在下一个Tick（或者在当前Tick的微任务中）更新视图，也就直接把 msg 从 <code>0 -&gt; 3</code> 而不是 <code>0 -&gt; 1 -&gt; 2 -&gt; 3</code></p>

<h4 id="toc_19">24. Vue 插件的原理是什么</h4>

<p>Vue插件的的使用方法是 <code>Vue.use(xx)</code></p>

<p>所有被 Vue.use 的对象，都必须包含一个 <code>install</code> 的方法，<code>Vue.use</code>的本质就是执行这个方法罢了</p>

<blockquote>
<ul>
<li>如果use的是一个function而不是一个对象，那这个方法会被直接当成install方法来执行。</li>
<li>Vue use必须在vue实例化之前执行</li>
</ul>
</blockquote>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
