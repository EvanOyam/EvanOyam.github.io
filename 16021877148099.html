<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title> 常见 JS 面试题 - Evan的博客 </title>
     
    <link href="atom.xml" rel="alternate" title="Evan的博客" type="application/atom+xml" />
    
    <link rel="shortcut icon" href="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" type="image/png" />
    

    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>

    <script type="text/javascript">
      function before_search() {
        var searchVal = 'site:evanoyam.github.io ' + document.getElementById('search_input').value
        document.getElementById('search_q').value = searchVal
        return true
      }
    </script>
  </head>
  <body class="antialiased hide-extras">
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">
        <nav class="top-bar docs-bar hide-for-small" data-topbar>
          <section class="top-bar-section">
            <div class="row">
              <div style="position: relative; width: 100%">
                <div style="position: absolute; width: 100%">
                  <ul id="main-menu" class="left">
                    
                    <li id=""><a target="self" href="index.html">Home</a></li>
                    
                    <li id=""><a target="_self" href="archives.html">Archives</a></li>
                    
                  </ul>

                  <ul class="right" id="search-wrap">
                    <li>
                      <form
                        target="_blank"
                        onsubmit="return before_search();"
                        action="https://google.com/search"
                        method="get"
                      >
                        <input type="hidden" id="search_q" name="q" value="" />
                        <input tabindex="1" type="search" id="search_input" placeholder="Search" />
                      </form>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </section>
        </nav>

        <nav class="tab-bar show-for-small">
          <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
            <span> &nbsp; Evan的博客</span>
          </a>
        </nav>

        <aside class="left-off-canvas-menu">
          <ul class="off-canvas-list">
            
            <li><a target="self" href="index.html">Home</a></li>
            
            <li><a target="_self" href="archives.html">Archives</a></li>
            

            <li><label>Categories</label></li>

            
            <li><a href="Interface.html">面试</a></li>
            
            <li><a href="%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A.html">七牛图床</a></li>
            
          </ul>
        </aside>

        <a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container"></section>
      </div>
    </div>
  </body>
</html>
 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>常见 JS 面试题</h1>
     
        <div class="read-more clearfix">
          <span class="date">2020/10/09</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Interface.html'>面试</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <h4 id="toc_0">1. JS的基本数据类型和引用数据类型有哪些，他们的存储结构有什么不同？</h4>

<p>基本数据类型有String，Number，Boolean，Null，Undefined，Symbol。引用数据类型有Object，Array，Function。</p>

<blockquote>
<ul>
<li>基本数据类型存储在内存的栈空间中，每个自定义起就是唯一的</li>
<li>引用数据类型是存储在内存的堆空间中，然后堆地址存在栈空间里，其实读的是堆空间的引用。当一个引用类型赋值给一个变量，本质上是把这个地址的指针赋值过去了，这个地址指向的其实还是同一个堆空间</li>
</ul>
</blockquote>

<h4 id="toc_1">2. 如何判断JS数据类型？</h4>

<ol>
<li>基础类型用typeof就可以了，但是null是个例外，null要用 <code>===</code> 来判断，因为一个早期的bug导致了typeof null是Object</li>
<li>typeof引用数据类型（除了Function）都是Object，Array.isArray判断数组</li>
<li>isNaN来判断NaN，NaN连他自己都不等</li>
</ol>

<h4 id="toc_2">3. null，undefined 的区别？</h4>

<p>null表示这是一个空值，而undefined表示这是一个值，只是还没定义而已</p>

<h4 id="toc_3">4. NaN？</h4>

<p>NaN和全世界都不相等，包括它自己。用isNaN()判断一个参数是不是NaN</p>

<h4 id="toc_4">5. 介绍JavaScript的原型，原型链（画图）</h4>

<p><img src="https://img.bluepay.asia/upload/manual/20200426/17120534.png" alt="image"/></p>

<h4 id="toc_5">6. JavaScript如何实现一个类？</h4>

<p>JS的类是一个语法糖，本质上就是new一个对象出来，然后return出去，具体看new的原理，以及手写new</p>

<h4 id="toc_6">7. 什么是节流？介绍一下应用场景和原理，且手写一个节流函数</h4>

<p>节流指的是某一段时间内，某段代码或者说方法，仅执行一次。是触发立即执行的，然后某一段时间内重复执行将被无视，直到过了限制期，下一次触发才生效</p>

<p>常见的应用场景比如滚动触发某些事件，或者touchmove之类的事件，可以用节流</p>

<pre><code class="language-javascript">/**
 *
 * @param {Function} func 需要节流的函数
 * @param {Number} wait 需要节流的时间
 * @param {Boolean} immediate 是否立即执行
 * @param  {...any} args 节流函数的参数
 */
const throttle = (func, wait, immediate, ...args) =&gt; {
  if (immediate) {
    let pre = 0
    return function() {
      const now = +new Date()
      if (now - pre &gt; wait) {
        func.apply(this, args)
        pre = now
      }
    }
  } else {
    let timeout = null
    return function() {
      const ctx = this
      if (!timeout) {
        timeout = setTimeout(() =&gt; {
          timeout = null
          func.apply(ctx, args)
        }, wait)
      }
    }
  }
}

const fn = n =&gt; {
  console.log(n)
}

const run = throttle(fn, 1000, 1, 123)

setInterval(() =&gt; {
  run()
}, 0)
</code></pre>

<h4 id="toc_7">8. 什么是防抖？介绍一下应用场景和原理，且手写一个防抖函数</h4>

<p>防抖就是避免频繁触发同一个事件，两个事件之间必须相隔一段时间才可执行，如果一个事件触发后，还没间隔够就触发下一个事件，那么下一个事件不执行</p>

<pre><code class="language-javascript">/**
 *
 * @param {Function} func 需要防抖的方法
 * @param {Number} wait 等待时长
 * @param {Boolean} immediate 是否立即执行
 * @param  {...any} args 需要防抖的方法所需的参数
 */
const debounce = (func, wait, immediate, ...args) =&gt; {
  let timeout = null
  return function() {
    const ctx = this
    if (timeout) clearTimeout(timeout)
    if (immediate) {
      const callNow = !timeout
      timeout = setTimeout(() =&gt; {
        timeout = null
      }, wait)
      if (callNow) func.apply(ctx, args)
    } else {
      timeout = setTimeout(() =&gt; {
        func.apply(ctx, args)
      }, wait)
    }
  }
}
</code></pre>

<h4 id="toc_8">9. == 和 === 的区别</h4>

<p>双等号会做类型隐式转换，三等号不会做类型隐式转换</p>

<h4 id="toc_9">10. 什么是作用域，什么是作用域链</h4>

<p>作用域就是当前环境下的变量和内存空间的可访问性。在ES6的const和let出现之前，是没有块级作用域的，只有全局作用域和函数作用域。这也是为什么一些框架代码写在IIFE内，这是为了产生一个独立的作用域，避免污染全局环境。</p>

<p>当代码执行的时候，在当前作用域找不到变量，会去父级的作用域查找，这种链式查找就是作用域链。注意这里的作用域是定义时候就产生的，也就是说js在解释阶段就确定了作用域，而非在运行阶段</p>

<blockquote>
<p>JS是解释型语言，分为解释和执行两个阶段。  </p>

<p>解释阶段包括:</p>

<ul>
<li>语法分析</li>
<li>词法环境分析（也就是确定作用域）</li>
</ul>

<p>执行阶段包括:</p>

<ul>
<li>创建执行上下文</li>
<li>将函数推入执行栈顶并且执行函数</li>
<li>垃圾回收</li>
</ul>
</blockquote>

<h4 id="toc_10">11. 什么是闭包</h4>

<p>函数外部访问函数内部的变量。闭包本是为了纯函数式编程的。函数内声明函数的同时，还会保留当前函数作用域内的变量，return函数出去或者赋值给外部对象，这些变量会跟着携带出去。只要闭包函数还存在，就会一直携带这些变量</p>

<p>闭包能避免全局污染: 闭包携带了属于自己的函数执行时需要的上下文（私有属性）就像在气泡内，每个闭包环境有自己的变量，如果定义在全局，那变量是可共享的，状态不唯一就无法追踪</p>

<h4 id="toc_11">12. 介绍一下this</h4>

<p>this是执行时的上下文对象。一般可归纳为三种：</p>

<ol>
<li>正常执行语句，调用方法的时候，谁调用了方法，this就绑定在谁身上。如果直接使用方法，就绑定在window对象上（node在global上）
<code>js
const obj = {<br/>
name: &#39;Evan&#39;,<br/>
fn: function () {<br/>
console.log(this.name)<br/>
}<br/>
}<br/>
const newFn = obj.fn()<br/>
obj.fn() // obj调用fn，this（上下文对象）就是obj，输出obj.name 即 Evan<br/>
newFn() // 直接使用方法，浏览器中等价于window调用，this（上下文对象）就是window，输出window.name 即 undefined
</code></li>
<li>new xxx()的时候，会生成一个新的对象（最终构造函数会return这个对象）this就绑定在这个对象身上。this.xx 就相当于这个对象.xx</li>
<li>箭头函数没有this，而是继承于定义时的外层词法环境，如果没有则跟着作用域链一路查找直到最外层（浏览器是window对象，node环境是exports对象，后面解释）<br/>
```js<br/>
const obj = {<br/>
a: function() {<br/>
console.log(this)<br/>
},<br/>
b: () =&gt; {<br/>
console.log(this)<br/>
},<br/>
c: {<br/>
d: function() {<br/>
  console.log(this)<br/>
},<br/>
e: () =&gt; {<br/>
  console.log(this)<br/>
}<br/>
}<br/>
}</li>
</ol>

<p>// 正常函数，谁调用this就在谁身上<br/>
obj.a() // obj<br/>
// 箭头函数没有this，this取决于定义时的最外层上下文<br/>
obj.b() // 浏览器 =&gt; window；node =&gt; exports<br/>
// 正常函数，谁调用this就在谁身上<br/>
obj.c.d() // obj.c<br/>
// 箭头函数没有this，this取决于定义时的最外层上下文<br/>
obj.c.e() // 浏览器 =&gt; window；node =&gt; exports</p>

<pre><code class="language-text">&gt; 为什么在node环境执行箭头函数this会指向exports而不是global（module.exports），因为Node是模块化的，node执行每个文件会给一个单独的作用域（模块），这是一个闭包环境。
&gt; 
&gt; 在一个模块（文件）中，声明的变量都是在这个闭包环境内的，不会污染global，而this指向的是module.exports，而不是global
&gt; 
&gt; 如果直接调用一个正常定义的函数，那么这个就是由global对象调用的，this会绑定在global上。如果调用一个箭头函数，this是向上级词法环境查找的，如果上级没有作用域，就跟着作用域链一路找到定义时的最外层对象上（exports）
&gt; 
&gt; 所以 obj.c.e() 输出的是exports，也就是module.exports，这是当前文件的顶级对象，箭头函数没有this，依赖定义时的外层对象，外层对象也没有词法环境，就一路往上找到exports

#### 13. 箭头函数的特点
箭头函数没有this，而是继承于定义时的外层词法环境，如果没有则跟着作用域链一路查找直到最外层

#### 14. 原生JavaScript如何实现对DOM节点的增删查改
```js
// 增
const fatherDOM = document.querySelector(&#39;#father&#39;)
const sonDOM = document.createElement(&#39;div&#39;)
fatherDOM.appendChild(sonDOM)

// 删
const fatherDOM = document.querySelector(&#39;#father&#39;)
const sonDOM = document.querySelector(&#39;#son&#39;)
fatherDOM.removeChild(sonDOM)

// 查
const DOM = document.querySelectorAll(&#39;.box&#39;)
</code></pre>

<h4 id="toc_12">15. Array.slice() 与 Array.splice() 的区别？</h4>

<p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。</p>

<p>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p>

<h4 id="toc_13">16. 数组有哪些方法不改变原数组？有哪些方法会改变原数组？</h4>

<p>不改变原数组的方法:</p>

<ol>
<li>slice</li>
<li>map</li>
<li>fliter</li>
<li>concat</li>
<li>join</li>
</ol>

<p>改变原数组的方法:</p>

<ol>
<li>pop</li>
<li>push</li>
<li>shift</li>
<li>unshift</li>
<li>splice</li>
</ol>

<h4 id="toc_14">17. 介绍一下数组高阶方法</h4>

<ol>
<li>find：找出第一个符合条件的成员</li>
<li>findindex：找出第一个符合条件的成员下标</li>
<li>includes：数组中是否存在某成员</li>
<li>reduce：递归方法</li>
<li>map：映射方法</li>
<li>filter：过滤方法</li>
</ol>

<h4 id="toc_15">18. typeof 和 instanceof 的区别</h4>

<p>typeof是判断变量是否属于某个类型，instanceof是判断实例是否属于某个构造函数。</p>

<p>instanceof的原理就是，在对象的原型链中能否找到构造函数的prototype</p>

<pre><code class="language-javascript">function myInstanceof(left, right) {
  let rightPrototype = right.prototype
  let leftPrototype = left.__proto__
  while (true) {
    if (leftPrototype === null || leftPrototype === undefined) return false
    if (rightPrototype === leftPrototype) return true
    leftPrototype = leftPrototype.__proto__
  }
}
</code></pre>

<h4 id="toc_16">19. Javascript有哪些兼容性写法</h4>

<p>document.body 和 document.documentElement</p>

<h4 id="toc_17">20. 什么是变量提升</h4>

<p>var声明的变量会变量提升到顶部，也就是提前声明，但是还未赋值</p>

<h4 id="toc_18">21. 显示转换 / 隐式转换</h4>

<p><strong>强制转换:</strong></p>

<ol>
<li>Number<br/>
Number(Number) -&gt; 不变<br/>
Number(String) -&gt; 可解析成数字/NaN<br/>
Number(Boolean) -&gt; true为1，false为0<br/>
Number(undefined) -&gt; NaN<br/>
Number(null) -&gt; 0<br/>
Number(Array) -&gt; 单数字/NaN<br/>
Number(Object) -&gt; NaN</li>
<li>String<br/>
String(基础类型) -&gt; 字符串<br/>
String(Object) -&gt; [object object]（字符串）<br/>
String(Array) -&gt; 相当于Array.prototype.join</li>
<li>Boolean<br/>
Boolean(undefined、0、-0、NaN、null、&#39;&#39;) -&gt; false<br/>
Boolean(其他) -&gt; true</li>
</ol>

<p><strong>隐式转换</strong></p>

<ol>
<li>逻辑类（如if，三元运算，!等）以布尔类型为准，其他转换成布尔</li>
<li>算数类（+、-、*、/、%）以数字类型为准，其他转换成数字类型</li>
<li>特殊“+”以字符串为准，其他转换成字符串</li>
<li>“==”比较运算符<br/>
null == undefined<br/>
数字为准，其他遵循：obj先转，后转布尔，再转字符串</li>
</ol>

<h4 id="toc_19">22. 手写一个Promise</h4>

<p><a href="http://note.youdao.com/noteshare?id=f3a2cd6d1cbd16a833539bb355bdacfa">到这里看答案</a></p>

<h4 id="toc_20">23. promise和await async有什么差别</h4>

<ol>
<li>从用法上，promise是链式调用，await async是类似同步的写法，await async其实是自动执行next的generator的语法糖</li>
<li>从错误捕获上，promise有catch，await async可以用try catch</li>
<li>从性能上await async有堆栈追踪，性能比promise好。await/async本质是生成器和迭代器的语法糖，它是将异步暂停且挂起，它不需要保留完整的堆栈信息，只需要保留读取堆栈的地址指针就可以了。<br/>
而promise的链式调用并没有&quot;暂停代码&quot;，它通过then收集到了所有的回调依赖，保存在resolveQueue或者rejectQueue中。当它resolve或者reject的时候，从队列中把回调全部拿出来执行。这意味着它仍要保存回调的堆栈信息，那怕promise已经执行完毕了。</li>
</ol>

<h4 id="toc_21">24. 介绍一下promise.all和promise.race</h4>

<p>promise.all是等待一个promise数组，全部resolve了promise.all才会resolve，其中任何一个reject了，promise.all都会被reject</p>

<p>promise.race是等待若干个promise中最快resolve的那个结果</p>

<h4 id="toc_22">25. Object.create()的时候做了什么</h4>

<p>Object.create()用来创建一个对象，接收两个参数</p>

<ol>
<li>第一个是__proto__指向的对象，如果设置为null，那么这个新创建的对象不会拥有Object原型上的方法（包括toString()等）</li>
<li>第二个参数是对象上的属性所拥有的属性（是否可读写等，作用与Object.defineProperties一样）</li>
</ol>

<pre><code class="language-javascript">const obj = Object.create(null, {
  name: {
    writable: true,
    configurable: true,
    value: &#39;Evan&#39;
  }
})
</code></pre>

<h4 id="toc_23">26. 什么称之为“对象属性的属性”，如何查看，如何修改</h4>

<ol>
<li>对象上的属性都有其定义自身的属性，如是否可修改，删除，枚举等</li>
<li>通过Object.getOwnPropertyDescriptor(obj,&#39;property&#39;)可查看这个属性的属性</li>
<li>通过Object.defineProperty(obj,&#39;property&#39;,{define:prop})。接收3个参数，第一个是对象本身，第二个是对象所需要修改的属性，第三个是对这个属性的描述，是一个对象。常见的描述有：
<code>js
{ <br/>
value: &#39;Evan&#39;,  //值<br/>
writable: true,  //是否可修改value<br/>
enumerable: true,  //是否可枚举<br/>
configurable: true  //是否可删除<br/>
}
</code></li>
</ol>

<h4 id="toc_24">27. 介绍一下宏任务与微任务，且以下代码的输出结果是什么</h4>

<p>宏任务和微任务都是事件循环队列里的一部分。队列中的每个宏任务都有一个属于其自己的微任务队列。每一轮事件循环只会执行一个宏任务和其对应的微任务队列，当宏任务执行完，就会去执行其对应的微任务队列。其下所有微任务执行完，结束这轮的事件循环，回过头检查宏任务队列，执行新的宏任务和其下微任务队列中的所有微任务。</p>

<p>常见的宏任务有：</p>

<ol>
<li>同步的代码</li>
<li>setTimeout，setInterval</li>
<li>requestAnimationFrame</li>
<li>node中的setImmediate</li>
</ol>

<p>常见的微任务有：</p>

<ol>
<li>promise，await async等（注意如果用setTimeout模拟的promise，那还是宏任务）</li>
<li>node中的process.nextTick</li>
</ol>

<p>对于代码中的输出结果，思路只要找到所有宏任务和微任务就好了：第一轮宏任务输出 -&gt; 第一轮宏任务中的微任务输出 -&gt; 第二轮宏任务输出...</p>

<p>输出结果是：（开始输出第一轮宏任务）script start =&gt; async2 end =&gt; Promise =&gt; script end（第一轮宏任务输出结束） =&gt; （开始输出第一轮宏任务所属的微任务）async1 end =&gt; promise1 =&gt; promise2（第一轮宏任务所属的微任务结束） =&gt; （第二轮宏任务）setTimeout</p>

<h4 id="toc_25">28. 介绍一下Set数据结构何其方法，并说出常用的场景</h4>

<p>Set的成员都是唯一的，有add，delete，has，clear等方法，也是可枚举的，所以可遍历，也可以用扩展运算符展开。常用来存储唯一结果的数据，或者去重等</p>

<h4 id="toc_26">29. 介绍一下Map数据结构何其方法，并说出常用的场景</h4>

<p>Map是一种键值对形式的，映射（字典）数据结构。有set，delete，get，has，clear等方法。也是可以遍历的，常用于做映射</p>

<h4 id="toc_27">30. 介绍一下get和set方法</h4>

<p>get和set都是对象属性的一种特性（可通过Object.defineProperty设置）</p>

<p>在访问对象某个属性的时候，会触发get，比如obj.a将会触发a的getter；在设置对象某个属性的时候，会触发set，比如obj.a = 123将会触发a的setter。换句话说这两个东西可以作为钩子去处理一些逻辑。</p>

<h4 id="toc_28">31. 说一下运算符优先级</h4>

<p>算数类&gt;逻辑类&gt;赋值</p>

<p>括号&gt;算数运算符&gt;大小判断运算符&gt;等号与非&gt;与&gt;或&gt;三元运算&gt;赋值</p>

<h4 id="toc_29">32. 介绍一下深拷贝和浅拷贝，手写一个深拷贝</h4>

<p>对于引用类型来说，赋值的时候其实是把地址赋值过去，并不是真正意义上的复制。于是有了浅拷贝和深拷贝的概念。</p>

<p>浅拷贝就是把对象第一层拥有的属性复制一份，但是如果属性中有引用类型的话，还是复制了它的引用地址</p>

<p>深拷贝就是递归下去的浅拷贝，保证每个属性和他的子属性都复制一份</p>

<pre><code class="language-javascript">function deepClone(obj) {
  function isObject(o) {
    return (typeof o === &#39;object&#39; || typeof o === &#39;function&#39;) &amp;&amp; o !== null
  }
  if (!isObject(obj)) return obj
  let newObj = Array.isArray(obj) ? [] : {}
  Reflect.ownKeys(obj).forEach(key =&gt; {
    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
  })
  return newObj
}
</code></pre>

<h4 id="toc_30">33. indexOf() findIndex() find() 三者的区别</h4>

<ol>
<li>indexOf()在String和Array类型中都有，用来匹配字符串（如果是数组就匹配元素），找到了返回目标位置，找不到就返回-1</li>
<li>findIndex()是ES6数组新增的方法，查找数组中符合条件的下标，找不到就返回-1</li>
<li>find()是ES6数组新增的方法，查找符合条件的元素，找不到就返回-1</li>
</ol>

<h4 id="toc_31">34. 介绍一下Date对象常用方法</h4>

<p>Date是JS内置的日期对象，常用如getTime(),getFullYear(),getMonth(),getDate()等，通过<code>+new Date()</code>可以很方便转换为时间戳</p>

<h4 id="toc_32">35. 介绍一下Math对象常用方法</h4>

<p>Math是JS内置的数学处理库，常见如Math.floor(),Math.ceil(),Math.round()等</p>

<h4 id="toc_33">36. vue如何实现双向绑定</h4>

<p>Vue 2.x 是通过defineProperty来劫持对象的属性，从而感知数据的变化，进而驱动视图变更。 在这个过程中，通过一个发布订阅机制来控制什么数据需要响应式，什么数据又不需要响应</p>

<blockquote>
<p>比如没有渲染的数据，其实没必要追踪变化，只需要追踪template中的{{}}即可。需要渲染的数据发起订阅，收集依赖；数据改变时通知各个订阅方，未订阅的不通知</p>
</blockquote>

<p>defineProperty有几个弊端:</p>

<ol>
<li>并不能劫持数组，所以Vue重写了数组相关的劫持方法</li>
<li>defineProperty不能响应式追踪新增的元素，所以Vue提供了vue.$set</li>
<li>defineProperty是深度遍历的，不管多少层，反正就递归遍历完，对性能损耗很大</li>
</ol>

<p>Vue 3.x 是通过Proxy来劫持对象的（包括数组）所以原生上就解决了无法追踪数组的问题（包括新增元素也是一个道理）。而且这里不需要深度递归，只需要递归到目标层级就好了</p>

<blockquote>
<p>Proxy还能结合Reflect很方便的获取和设置函数，这里就不演示了</p>
</blockquote>

<pre><code class="language-javascript">// vue 2.x
const observe = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj
  Reflect.ownKeys(obj).forEach(item =&gt; {
    reactiveFn(obj, item, obj[item])
  })
}

const reactiveFn = (obj, key, val) =&gt; {
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      console.log(&#39;getter&#39;, val)
      return val
    },
    set(newV) {
      console.log(&#39;setter&#39;, newV)
      val = newV
    }
  })
}

let data = {
  name: &#39;Evan&#39;,
  age: 24
}

observe(data)
const name = data.name
data.age = 25
</code></pre>

<pre><code class="language-javascript">// vue 3.x
const proxyGenerator = obj =&gt; {
  if (!obj || typeof obj !== &#39;object&#39;) return obj

  const handler = {
    get(obj, key) {
      console.log(&#39;getter&#39;, obj[key])
      // 仅递归到目标层次，不用深度递归
      return proxyGenerator(obj[key])
    },
    set(obj, key, newV) {
      console.log(&#39;setter&#39;, newV)
      obj[key] = newV
    }
  }

  return new Proxy(obj, handler)
}

const userInfo = {
  name: &#39;Evan&#39;,
  age: 24
}

let userInfoProxy = proxyGenerator(userInfo)

const name = userInfoProxy.name
userInfoProxy.age = 25
</code></pre>

<h4 id="toc_34">37. new XXX() 的时候发生了什么</h4>

<ol>
<li>创建新对象并且this指向这个对象，即this就是这个对象。this.xx 其实就是这个对象.xx。</li>
<li>新对象的__proto__指向构造函数的原型，因此new的对象拥有构造函数原型上的所有属性与方法。这也是instanceof的原理。</li>
<li>最终构造函数会返回这个this对象。所以构造函数的目的本身是用于批量初始化对象，需要初始化某个对象就很适合用构造函数。</li>
<li>如果构造函数显式返回一个非对象返回值，则会被忽略，由新创建的对象（也就是this）所覆盖。如果显式返回一个对象，则这个对象会覆盖掉新创建的this对象</li>
<li>此外构造函数虽然可以直接调用，但是意义不大，因为这样window会被当作this传入，构造的对象属性全部会被绑定到全局上，容易造成污染。并且严格模式下由于this不再默认指向window，直接调用构造函数会导致this为定义，直接报错</li>
</ol>

<h4 id="toc_35">38. 说一下call，apply，bind的区别</h4>

<p>call、apply、bind三者都是显式绑定this的一种方法</p>

<p>call会执行方法，且带参是独立的一个个参数</p>

<p>apply会执行方法，且带参是一个参数数组</p>

<p>bind只是绑定this，并不会执行</p>

<pre><code class="language-javascript">const A = { name: &#39;Evan&#39; }
const B = { name: &#39;Fiona&#39; }
function showInfo(age) {
  this.age = age
  console.log(this.name, this.age)
}
// this绑定在对象A上，由对象A执行showInfo，带参21
showInfo.call(A, 21) // Evan，21
// this绑定在对象B上，由对象B执行showInfo，带参20
showInfo.call(B, 20) // Fiona，20
// this绑定在对象A上，由对象A执行showInfo，带参22
showInfo.apply(A, [22]) // Evan，22
// this绑定在对象A上，赋值给test，带参23
const test = showInfo.bind(A, 23) // Evan，23
test()
</code></pre>

<h4 id="toc_36">39. 说一下运算符优先级</h4>

<p>括号&gt;算数运算符&gt;大小判断运算符&gt;等号与非&gt;与&gt;或&gt;三元运算&gt;赋值。总结就是算数类&gt;逻辑类，逻辑类&gt;赋值</p>

<h4 id="toc_37">40. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h4>

<p>cookies只有4kb，sessionstorage和localstorage有5m。cookies在设置的时间之前不会过期，localstorange在本地不会过期，sessionstorage在窗口关闭之前不会过期</p>

<h4 id="toc_38">41. 什么是剩余参数数组，有什么用处</h4>

<p>函数接收的参数如果用扩展运算符去展开，将会得到一个数组</p>

<pre><code class="language-javascript">function plus(...arr) {
  let sum = 0
  for (const i in arr) {
    sum += arr[i]
  }
  return sum
}

const a = plus(1, 2, 3, 4, 5)
console.log(a)

</code></pre>

<h4 id="toc_39">42. 什么是类数组结构</h4>

<p>有length，可遍历，但是没有数组相关的方法</p>

<h4 id="toc_40">43. js如何追踪执行环境</h4>

<ol>
<li>如果是创建一个函数环境，那么创建形参及函数参数的默认值。如果是非函数环境，将跳过此步骤。</li>
<li>如果是创建全局或函数环境，就扫描当前代码进行函数声明(不会扫描其他函数的函数体)，但是不会扫描函数表达式或箭头函数。对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若该标识符已经存在，那么该标识符的值将被重写。如果是块级作川域，将跳过此步骤。</li>
<li>扫描当前代码进行变量声明。在函数或全局环境中，找到所有当前函数以及其他函数之外通过var声明的变量，并找到所有在其他函数或代码块之外通过let或const定义的变量。在块级环境中，仅查找当前块中通过let或const定义的变量。对于所査找到的变量，若该标识符不有在，进行注册并将其初始化为undefined。若该标识符已经存在，将保留</li>
</ol>

<h4 id="toc_41">44. 模拟私有变量</h4>

<pre><code class="language-javascript">// 构造函数模拟闭包
function SelfIncreasing() {
  let num = 0
  this.getNum = () =&gt; {
    return num
  }
  this.setNum = () =&gt; {
    num++
  }
}

// IIFE return 函数模拟闭包
const outter = (function() {
  let num = 0
  return function() {
    return {
      a: num,
      b: 1
    }
  }
})()
</code></pre>

<h4 id="toc_42">45. 闭包实现动画效果</h4>

<pre><code class="language-javascript">function animateBox() {
  const box = document.getElementById(&#39;box&#39;)
  var tick = 0
  var timer = setInterval(function() {
    if (tick &lt; 100) {
      box.style.left = box.style.top = tick + &#39;px&#39;
      tick++
    } else {
      clearInterval(timer)
    }
  }, 10)
}
</code></pre>

<h4 id="toc_43">46. 什么是生成器</h4>

<p>生成器通过 <code>function* (){}</code> 声明，在函数体内有 yield 关键字。生成器用于生成一系列返回值。</p>

<h4 id="toc_44">47. 什么是迭代器</h4>

<p>迭代器用来控制生成器的执行，它有一个 next()方法，每次执行这个方法。生成器就开始执行代码，当代码执行到 yield 关键字时，就会生成一个中间结果（生成值序列中的一项），然后返回一个新对象，其中封装了结果值和一个指示完成的指示器。</p>

<h4 id="toc_45">48. 描述一下生成器和迭代器的关系</h4>

<ol>
<li>初次运行生成器的时候并没有执行生成器内的任何代码，而是将生成器挂起并且生成了一个迭代器。</li>
<li>执行迭代器 next 方法的时候，生成器激活，执行代码直到遇到第一个 yield。这时生成器将会返回一个 yield 对象，这个对象包含一个生成的值（value）、下一个返回值的指示器（done，布尔类型），然后生成器挂起。</li>
<li>随后每次调用迭代器的 next，生成器就会重新激活，直到遇到 yield 再挂起，然后再 next 再激活，循环往复。当生成器无值返回时，value 将会返回 undefined，然后指示器 done 为 true，生成器结束。</li>
<li>用 for of 遍历迭代器时，将自动执行迭代器的 next 方法。</li>
</ol>

<h4 id="toc_46">49. 描述一下生成器是如果做到暂停代码的</h4>

<ol>
<li>运行生成器的时候，js 引擎会把生成器执行上下文（本质上生成器也是一个函数）推进执行上下文栈顶。这时候会创建并且返回一个迭代器。这个迭代器其实就是对生成器的引用。返回迭代器后，生成器挂起，其执行上下文从栈顶弹出。但是由于还有迭代器的存在（这玩意是生成器的引用）所以其实生成器没有被完全销毁（有点类似闭包）内存中仍然有生成器的堆空间，迭代器可以看成是他的地址指针。</li>
<li>每次执行迭代器的 next 方法时，迭代器再通过引用找到被保存下来的生成器的上下文，把它推进执行上下文栈顶。生成器开始运作，当遇到 yield 的时候，返回包含 value 和指示器的对象，执行上下文从栈顶弹出，迭代器仍然保存着引用</li>
<li>往后的每一次 next 和 yield，都是如此。这就是生成器与普通函数的不同，普通函数每次调用都是生成一个新的上下文推进栈顶，执行完毕从栈顶移除并销毁；而生成器是把之前的上下文重新找出来，执行完毕弹出栈顶但是保存引用。</li>
</ol>

<h4 id="toc_47">50. 使用生成器生成唯一 id</h4>

<pre><code class="language-javascript">function* IdGenerator() {
  let id = 0
  while (true) {
    yield ++id
  }
}
const idIterator = IdGenerator()
const id = idIterator.next().value
console.log(id)
</code></pre>

<h4 id="toc_48">51. Proxy 和 getter setter 的区别</h4>

<p>Proxy是代理一个对象，他接收两个参数，第一个参数是代理的目标，第二个参数是拦截处理器。</p>

<pre><code class="language-javascript">const handler = {
  get(obj, key) {
    console.log(&#39;getter&#39;, obj[key])
    return obj[key]
  },
  set(obj, key, newV) {
    console.log(&#39;setter&#39;, newV)
    obj[key] = newV
  }
}
const proxy = new Proxy(obj, handler)
</code></pre>

<blockquote>
<p>Proxy的handler可以做很多<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler">操作</a>，除了getter和setter之外，还能拦截属性的读取，设置，甚至拦截new实例化</p>
</blockquote>

<p>getter和setter是Object的一个特性，他允许返回动态计算值的属性，换句话说就是钩子。在获取属性的时候触发get，设置属性的时候触发set。getter和setter还能结合Object.defineProperty来做一些自定义的返回或者拦截</p>

<pre><code class="language-javascript">const obj = {
  log: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
  get latest() {
    if (this.log.length === 0) {
      return undefined;
    }
    return this.log[this.log.length - 1];
  }
};

console.log(obj.latest);
</code></pre>

<h4 id="toc_49">52. 描述一下事件循环</h4>

<p>每一轮事件循环都包含一个宏任务队列和一个微任务队列:</p>

<ol>
<li>每一轮循环只会处理队列中的第一个宏任务</li>
<li>每一轮循环会清空微任务队列，也就是说其实每个微任务队列是对应某一个宏任务的</li>
</ol>

<p>所以每一轮事件循环，只执行对顶的宏任务和其对应的微任务队列，完成后当前事件结束。下一事件再处理新的宏任务和其对应的微任务队列</p>

<blockquote>
<p>浏览器环境和node环境的事件循环有些不同，node事件循环请看 #55 号问题</p>
</blockquote>

<h4 id="toc_50">53. CommonJS 和 ES6 模块化有什么区别</h4>

<ol>
<li>CommonJS 是被加载的时候运行，ES6 模块化是编译的时候确定依赖，也就是说重复引入同一个模块，也只会执行一次代码。tree-sharking原理就是ES6模块依赖是编译时确定的。</li>
<li>CommonJS 输出的是值的浅拷贝，并且写到内存中。ES6 模块化输出值的引用</li>
<li>CommonJS 支持动态导入，也就是 require(${path}/xx.js)</li>
<li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
</ol>

<pre><code class="language-javascript">// CommonJS
// counter.js
let count = 1
function increment() {
  count++
}
module.exports = {
  count,
  increment
}

// main.js
const counter = require(&#39;counter.cjs&#39;)
counter.increment()
// CommonJS 这里输出1，因为 CommonJS 输出的是值的浅拷贝过后的对象
// count++ 修改的是模块内的值，和输出的对象无关
console.log(counter.count)
</code></pre>

<pre><code class="language-javascript">// ES6 模块
// counter.mjs
export let count = 1
export function increment() {
  count++
}

// main.mjs
import { increment, count } from &#39;./counter.mjs&#39;
increment()
// ES6 模块输出2，因为ES6 模块化输出值的引用
console.log(count) // 2
</code></pre>

<h4 id="toc_51">54. 手写call，apply，bind</h4>

<pre><code class="language-javascript">// call
Function.prototype.myCall = function(ctx, ...args) {
  ctx = ctx || window
  ctx.fn = this
  const result = ctx.fn(...args)
  delete ctx.fn
  return result
}

// apply
Function.prototype.myApply = function(ctx, params) {
  ctx = ctx || window
  ctx.fn = this
  const result = params ? ctx.fn(...params) : ctx.fn()
  delete ctx.fn
  return result
}

// bind
Function.prototype.myBind = function(ctx, ...args) {
  // 存一下调用者（需要被绑定）的this
  const _this = this
  // bind 返回的是一个 function，所以这个被返回的东西其实是可以 new 的
  return function F() {
    // 如果 new 了这个玩意，this会被new改变，所以需要手动重新设置this的指向
    return this instanceof F ? new _this(...args, ...arguments) : _this.apply(ctx, args.concat(...arguments))
  }
}
</code></pre>

<h4 id="toc_52">55. 解释一下node的事件循环</h4>

<p>node的事件循环，每个循环都有这几个阶段</p>

<ol>
<li><p>timers</p>
<blockquote>
<p>首先是执行定时器，如果在当前循环种存在setTimeout / setInterval之类的定时器，将在这时候处理</p>
</blockquote></li>
<li><p>pending callbacks</p>
<blockquote>
<p>这个阶段也称为 I/O callbacks 阶段，主要是执行一些从上个循环延迟过来的 I/O 回调</p>
</blockquote></li>
<li><p>idle, prepare</p>
<blockquote>
<p>node 内部机制</p>
</blockquote></li>
<li><p>poll</p>
<blockquote>
<p>轮询，在这里检索新的 I/O 事件;执行与 I/O 相关的回调，其余情况 node 将在适当的时候在此阻塞，直到达到最快的一个计时器阈值为止（比如setTimeout 100ms，那如果这时候没事做，那他就等这个setTimeout 100ms）</p>
</blockquote></li>
<li><p>check</p>
<blockquote>
<p>执行setImmediate的回调</p>
</blockquote></li>
<li><p>close callbacks</p>
<blockquote>
<p>关闭当前循环</p>
</blockquote></li>
</ol>

<p><strong>例子1:</strong></p>

<pre><code class="language-javascript">const fs = require(&#39;fs&#39;)

setTimeout(() =&gt; {
  // do something
}, 1000)

// 假设这个异步操作需要10s
fs.readFile(&#39;./Demo.txt&#39;, (err, data) =&gt; {
  // do something
  // 通过while循环将fs回调强制阻塞5s
  while (endTime - readFileStart &lt; 5000) {
    // do something
  }
})

setImmediate(() =&gt; {
  // do something
})

// 1. 首先进入timers阶段，这时候并没有需要执行的timers回调（1s后才会执行）代码进入异步的I/O操作
// 2. 进入pending callbacks后发现也没有要干的（这里假设异步10s）不讨论idle和prepare内部机制，代码进入poll阶段
// 3. 进入poll轮询，一开始没有什么要干的（队列为空），但是发现一个setImmediate，于是进入check阶段
// 4. 进入check阶段把setImmediate干了，结束当前循环
// 5. 开启新的一轮循环，这时候并没有需要执行的timers回调（可能还剩几百ms后才会执行）代码进入异步的I/O操作
// 6. 进入pending callbacks同理，没啥干的进入poll阶段
// 7. 进入poll轮询，但是也没啥干的，也没有setImmediate了，那就开始等待，然后等到了定时器的阀值到了，分发了一个事件这时候回到timer把定时器干了，然后开启下一轮事件循环
// 8. timer和pending callbacks同理，到了poll之后，fs终于好了，执行I/O的回调，结束循环
</code></pre>

<p><strong>例子2:</strong></p>

<pre><code class="language-javascript">const fs = require(&#39;fs&#39;);

fs.readFile(__filename, () =&gt; {
  setTimeout(() =&gt; {
    console.log(&#39;timeout&#39;);
  }, 0);
  setImmediate(() =&gt; {
    console.log(&#39;immediate&#39;);
  });
});

// 1. 首先进入timer，啥也没，进入I/O读写
// 2. I/O读写也没东西，进入轮询
// 3. 进入poll，这时候开始等待，直到I/O回调到来，回调带来一个setTimeout，写入timer（注意这时候已经在poll阶段了，当前循环的timer期已经过了，要等下一个循环的timer）还有一个setImmediate，到check阶段
// 4. check阶段把setImmediate干了，结束当前循环
// 5. 开启新的一轮循环，timer中有个setTimeout，把它干掉，继续当前循环
</code></pre>

<blockquote>
<p>setTimeout 和 setImmediate的区别在于，setTimeout是到了时间阀值之后执行回掉，而setImmediate是在check阶段执行的回调</p>
</blockquote>

<h4 id="toc_53">56. 手写new操作符</h4>

<pre><code class="language-javascript">// new的原理:
// 1. 生成一个新的对象
// 2. 这个对象拥有构造函数原型上的方法
// 3. this指向这个对象（利用apply绑定this）
// 4. 如果构造函数返回对象，则返回构造函数创建的对象，否则返回new出来的对象
function create(constructor, ...args) {
  let obj = {}
  obj.__proto__ = constructor.prototype
  const result = constructor.apply(obj, args)
  return result instanceof Object ? result : obj
}

// 测试
function Test(name, age) {
  this.name = name
  this.age = age
}
Test.prototype.sayName = function() {
  console.log(this.name)
}
const test = create(Test, &#39;Evan&#39;, 24)
console.log(test.name)
console.log(test.age)
</code></pre>

<h4 id="toc_54">57. 虚拟dom有什么优势</h4>

<p>虚拟dom就是一个js的树结构，模拟了一颗dom树。</p>

<p>虚拟dom的优势:</p>

<ol>
<li>直接操作dom效率是很低的，要重新布局，递归，渲染。但是操作js就很快了。如果是虚拟dom，直接在js层就能把树的更改给确定，然后重新渲染改动的节点就好了。这样就不需要频繁修改dom节点，不用频繁回流重绘。</li>
<li>虚拟dom还可以在一些没有dom环境的地方模拟dom，比如node实现ssr那也要虚拟dom来模拟一颗dom树，直接输出html给前端。</li>
</ol>

<blockquote>
<p>为了提高性能，dom树的更改只会更改变动的部分，这是用的diff算法，（先序遍历深度优先）来确定什么枝叶变动了，也就是对比两个新旧obj不同的地方。</p>
</blockquote>

<p>vue 3.x 的改动:</p>

<ol>
<li>2.x时代虚拟dom会记录所有的节点，无论这个节点是静态的（比如 <code>&lt;h1&gt;Evan&lt;/h1&gt;</code> 这种）还是动态的（<code>&lt;h1&gt;{{name}}&lt;/h1&gt;</code>）这样有个弊端就是，那种完全不会变的节点，每次diff遍历也要查一遍，白白浪费时间。3.x时代给每个dom打上标记，静态的就不遍历了</li>
</ol>

<blockquote>
<p>不单是静态节点，这个标记的种类有很多种，比如是否有key，是否带监听器之类的，每种类型都是一个数字。而且静态节点会被提前提升标记出来（类似变量提升）</p>
</blockquote>

<ol>
<li>3.x多了事件缓存，事件会被写到一个可追踪的cache中，然后绑定事件的dom就变成静态节点了，事件怎么改反正就是一个cache，拿出来用就好了</li>
</ol>

<h4 id="toc_55">58. 用genarator实现async await</h4>

<pre><code class="language-javascript">const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(&#39;data&#39;), 1000))

function asyncToGenerator(genF) {
  return function() {
    return new Promise(function(resolve, reject) {
      const gen = genF()
      const step = nextF =&gt; {
        let { value, done } = nextF()
        if (done) return resolve(value)
        Promise.resolve(value).then(
          res =&gt; step(() =&gt; gen.next(res)),
          err =&gt; step(() =&gt; gen.throw(err))
        )
      }
      step(() =&gt; gen.next())
    })
  }
}

// 实现一个类似 async await 的方法
// async 关键字由 generator 代替
// await 关键字由 yield 代替
const test = asyncToGenerator(function*() {
  console.log(yield &#39;start&#39;)
  console.log(&#39;data: &#39;, yield getData())
  console.log(&#39;data2: &#39;, yield getData())
  return &#39;end&#39;
})

test().then(res =&gt; console.log(res))

</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16022112559168.html" 
          title="Previous Post: 七牛图床测试">&laquo; 七牛图床测试</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="16021784313262.html" 
          title="Next Post: 常见 Vue 面试题">常见 Vue 面试题 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" /></div>
            
                <h1>Evan的博客</h1>
                <div class="site-des">Evan 的博客 - 代码，摄影，音乐</div>
                <div class="social">






<a target="_blank" class="instagram" href="https://www.instagram.com/a953328679/" title="Instagram">Instagram</a>
<a target="_blank" class="weibo" href="https://weibo.com/wbxiaocong/" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com/EvanOyam/" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:o953328679@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Interface.html"><strong>面试</strong></a>
        
            <a href="%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A.html"><strong>七牛图床</strong></a>
         
        
            <a href="tag_JS.html"><strong>JS</strong></a>
            
            <a href="tag_Vue.html"><strong>Vue</strong></a>
            
        </p>
                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16022112559168.html">七牛图床测试</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16021877148099.html">常见 JS 面试题</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16021784313262.html">常见 Vue 面试题</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16021782785833.html">Vue 响应式原理</a>
			      </li>
		     
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
